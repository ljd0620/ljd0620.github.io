<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://pub-dc7fa280ba2f4edea3f388602fa80bb0.r2.dev/favicon.ico?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://pub-dc7fa280ba2f4edea3f388602fa80bb0.r2.dev/favicon.ico?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="一个IT男的技术博客，记录学习的点点滴滴。博客内容涵盖Java编程、Go编程、Spring框架、Spring Boot、Spring Cloud、微服务、分布式、数据库、物联网、Linux、Docker、Kubernetes、DevOps、架构设计、面试经验等。">
<meta property="og:type" content="website">
<meta property="og:title" content="Just Do IT.">
<meta property="og:url" content="https://ljd0620.github.io/page/3/index.html">
<meta property="og:site_name" content="Just Do IT.">
<meta property="og:description" content="一个IT男的技术博客，记录学习的点点滴滴。博客内容涵盖Java编程、Go编程、Spring框架、Spring Boot、Spring Cloud、微服务、分布式、数据库、物联网、Linux、Docker、Kubernetes、DevOps、架构设计、面试经验等。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Liujiduo">
<meta name="twitter:card" content="summary"><title>Just Do IT.</title><link ref="canonical" href="https://ljd0620.github.io/page/3/index.html"><link rel="alternate" href="/atom.xml" type="application/atom+xml"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Just Do IT.</div><div class="header-banner-info__subtitle">一个程序员的自我修养</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/22/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/">分布式ID生成方案</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-22</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt">分布式ID生成方案是分布式系统中的核心问题之一，尤其是在高并发、高可用的场景下，需要保证生成的ID具备以下特性： 全局唯一性：ID在分布式系统中必须唯一。 有序性：ID最好是有序的，便于数据库索引和查询。 高性能：ID生成速度要快，不能成为系统瓶颈。 高可用性：ID生成服务必须高可用，避免单点故障。 可扩展性：支持水平扩展，适应业务增长。 以下是几种常见的分布式ID生成方案及其实现细节： 一、常见分布式ID生成方案 1. UUID 原理：基于随机数生成128位的唯一标识符。 优点： 简单易用，无需中心化服务。 生成速度快。 缺点： 无序，不适合作为数据库主键。 存储空间大（36字符）。 查询性……</div><div class="post-readmore"><a class="post-readmore__link" href="/2023/09/22/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/20/Java%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/">Java分布式事务方案</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt">在分布式系统中，事务的一致性是一个复杂的问题，因为数据可能分布在不同的服务或数据库中。Java 生态中有多种实现分布式事务的方案，以下是常见的几种方案及其详细说明： 1. 两阶段提交（2PC） 概述 2PC 是一种经典的分布式事务协议，分为准备阶段和提交阶段。 角色： 协调者（Coordinator）：负责协调事务的提交或回滚。 参与者（Participant）：执行本地事务并反馈结果。 流程 准备阶段： 协调者向所有参与者发送准备请求。 参与者执行本地事务，但不提交，反馈“准备成功”或“准备失败”。 提交阶段： 如果所有参与者都反馈“准备成功”，协调者发送提交请求。 如果任一参与者反馈“准备……</div><div class="post-readmore"><a class="post-readmore__link" href="/2023/08/20/Java%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/09/DDD%E4%B9%8BDP%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/">DDD之DP设计原则</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-09</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">10分</span></span></div></header><div class="post-body"><div class="post-excerpt">Domain Primitive (DP) 是一种领域驱动设计（DDD）中的设计原则，旨在通过将领域中的基本概念封装为不可变的值对象（Value Object），从而提高代码的可读性、可维护性和安全性。DP 的核心思想是将领域中的原始类型（如字符串、数字）封装为具有明确语义和行为的对象。 以下是 DP 设计原则的详细解析： 1. DP 的核心概念 (1) 什么是 Domain Primitive？ 定义： DP 是领域中最基本的概念，通常是一个不可变的值对象。 它封装了领域中的原始类型，并赋予其明确的语义和行为。 示例： 将 String 类型的电话号码封装为 PhoneNumber 类。 将……</div><div class="post-readmore"><a class="post-readmore__link" href="/2023/08/09/DDD%E4%B9%8BDP%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/02/26/PromQL%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97/">PromQL数据分析指南</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-02-26</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt">PromQL（Prometheus Query Language）是 Prometheus 用于查询和分析时间序列数据的强大语言。通过 PromQL，你可以从 Prometheus 中提取、聚合和操作时间序列数据，从而进行监控、告警和数据分析。以下是使用 PromQL 进行数据分析的详细指南： 1. PromQL 基础概念 在开始使用 PromQL 之前，需要了解一些基本概念： 时间序列（Time Series）： 时间序列是由指标名称（Metric Name）和一组标签（Labels）唯一标识的数据流。 例如：http_requests_total&#123;method="GET", st……</div><div class="post-readmore"><a class="post-readmore__link" href="/2023/02/26/PromQL%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/17/JVM%E5%92%8CJMM%E7%9A%84%E5%8C%BA%E5%88%AB/">JVM和JMM的区别</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-17</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt">JVM 内存模型和 JMM（Java Memory Model，Java 内存模型）是两个不同的概念，尽管它们都与 Java 程序的内存管理相关，但它们的目标、范围和实现方式有显著区别。以下是它们的详细对比： 1. 定义与目标 (1) JVM 内存模型 定义： JVM 内存模型是 Java 虚拟机（JVM）规范中定义的一种内存管理模型，用于描述 Java 程序在运行时的内存分配和管理。 目标： 管理 Java 程序运行时的内存分配，包括堆、栈、方法区等内存区域。 确保 Java 程序能够高效地使用内存资源。 (2) JMM 内存模型 定义： JMM 是 Java 语言规范中定义的一种抽象模型，……</div><div class="post-readmore"><a class="post-readmore__link" href="/2022/11/17/JVM%E5%92%8CJMM%E7%9A%84%E5%8C%BA%E5%88%AB/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/15/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/">JVM内存模型解析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt">JVM（Java Virtual Machine，Java 虚拟机）内存模型是 JVM 规范中定义的一种抽象模型，用于描述 Java 程序在运行时的内存分配和管理。JVM 内存模型将内存划分为多个区域，每个区域有不同的用途和生命周期。以下是 JVM 内存模型的主要组成部分及其详细解析： 1. 程序计数器（Program Counter Register） 定义： 程序计数器是一块较小的内存空间，用于记录当前线程执行的字节码指令地址。 特点： 每个线程都有一个独立的程序计数器。 如果线程正在执行 Java 方法，程序计数器记录的是当前字节码指令的地址；如果执行的是 Native 方法，程序计数器……</div><div class="post-readmore"><a class="post-readmore__link" href="/2022/11/15/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/11/11/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/">JMM内存模型解析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-11</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt">JMM（Java Memory Model，Java 内存模型）是 Java 虚拟机（JVM）规范中定义的一种抽象模型，用于描述多线程环境下，线程如何与内存交互以及如何保证内存的可见性、有序性和原子性。JMM 的主要目标是解决多线程并发编程中的内存一致性问题。以下是 JMM 的主要组成部分及其详细解析： 1. 主内存（Main Memory） 定义： 主内存是所有线程共享的内存区域，存储了所有的变量（包括实例字段、静态字段等）。 特点： 主内存是线程之间通信的桥梁。 线程对变量的读写操作最终都会反映到主内存中。 2. 工作内存（Working Memory） 定义： 每个线程都有自己的工作内存……</div><div class="post-readmore"><a class="post-readmore__link" href="/2022/11/11/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/08/15/%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94/">常用消息中间件对比</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-08-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt">一、核心工作原理对比 特性 RabbitMQ RocketMQ Kafka 协议 AMQP 自定义协议（基于TCP） 自定义协议（基于TCP） 消息模型 队列模型（点对点、发布订阅） 发布订阅模型 发布订阅模型（基于分区日志） 核心组件 Exchange, Queue, Binding Topic, Broker, NameServer Topic, Partition, Broker, ZooKeeper（旧版本） 数据存储 内存&#x2F;磁盘（持久化队列） Commit Log（顺序写磁盘） Partition 日志文件（顺序写磁盘） 消息路由 支持 Direct, Topic, Fan……</div><div class="post-readmore"><a class="post-readmore__link" href="/2022/08/15/%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/07/12/MySQL%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/">MySQL深度分页优化</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-07-12</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">7分</span></span></div></header><div class="post-body"><div class="post-excerpt">在 MySQL 中，深度分页（Deep Pagination）通常是指查询结果的分页参数 OFFSET 值较大的情况（例如 LIMIT 10000, 20）。深度分页会导致性能问题，因为 MySQL 需要扫描并跳过大量的行，这会消耗大量的 I&#x2F;O 和 CPU 资源。以下是优化 MySQL 深度分页性能的几种常见策略： 1. 避免深度分页 深度分页通常不是用户实际需要的场景。可以通过以下方式避免深度分页： 限制分页深度： 在前端或 API 层面限制 OFFSET 的最大值（例如 OFFSET <= 1000）。 优化用户体验： 提供更精确的搜索条件，减少结果集的大小。 使用排序和过滤条……</div><div class="post-readmore"><a class="post-readmore__link" href="/2022/07/12/MySQL%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2022/05/02/Java%E7%9A%84wait%E5%92%8Cyield%E5%8C%BA%E5%88%AB/">Java的wait和yield区别</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-05-02</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">931</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt">在Java中，wait()和yield()都是用于线程控制的方法，但它们的作用和使用场景完全不同。以下是它们的详细区别： 1. wait()方法 (1) 定义 wait()是Object类的方法，用于线程间通信。 调用wait()的线程会释放锁并进入等待状态，直到其他线程调用notify()或notifyAll()唤醒它，或者等待超时。 (2) 使用场景 用于多线程协作，通常与notify()或notifyAll()配合使用。 常用于生产者-消费者模型或线程间的条件等待。 (3) 特点 释放锁：调用wait()的线程会释放持有的锁。 需要同步块：wait()必须在synchronized块或方……</div><div class="post-readmore"><a class="post-readmore__link" href="/2022/05/02/Java%E7%9A%84wait%E5%92%8Cyield%E5%8C%BA%E5%88%AB/"><span class="post-readmore__text">阅读全文</span><span class="post-readmore__icon"><i class="fas fa-long-arrow-alt-right"></i></span></a></div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://pub-dc7fa280ba2f4edea3f388602fa80bb0.r2.dev/avatar.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">Liujiduo's Blog</p></div><div class="sidebar-ov-feed"><span class="sidebar-ov-feed-email"><a class="sidebar-ov-feed-email__link" href="mailto:liujiduo@sina.com" target="_blank" rel="noopener"><span class="sidebar-ov-feed-email__icon"><i class="fas fa-envelope"></i></span><span>Email 订阅</span></a></span><span class="sidebar-ov-feed-rss"><a class="sidebar-ov-feed-rss__link" href="/atom.xml" target="_blank" rel="noopener"><span class="sidebar-ov-feed-rss__icon"><i class="fas fa-rss"></i></span><span>RSS 订阅</span></a></span></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">51</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">17</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">44</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024~2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>All Rights Reserved</span></div><div class="busuanzi"></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>