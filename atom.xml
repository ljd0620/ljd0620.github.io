<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just Do IT.</title>
  
  
  <link href="https://ljd0620.github.io/atom.xml" rel="self"/>
  
  <link href="https://ljd0620.github.io/"/>
  <updated>2025-04-01T08:35:38.853Z</updated>
  <id>https://ljd0620.github.io/</id>
  
  <author>
    <name>Liujiduo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Quarkus和SpringBoot性能对比</title>
    <link href="https://ljd0620.github.io/2025/03/30/Quarkus%E5%92%8CSpringBoot%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>https://ljd0620.github.io/2025/03/30/Quarkus%E5%92%8CSpringBoot%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</id>
    <published>2025-03-30T03:32:05.000Z</published>
    <updated>2025-04-01T08:35:38.853Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Quarkus</strong> 和 <strong>Spring Boot</strong> 是当前 Java 生态中两个非常流行的框架，分别针对不同的应用场景进行了优化。尽管两者都能构建高性能的应用程序，但在性能表现、资源消耗、启动时间等方面存在显著差异。以下是两者的详细对比：</p><hr>        <h3 id="1-性能核心指标对比"   >          <a href="#1-性能核心指标对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-性能核心指标对比" class="headerlink" title="1. 性能核心指标对比"></a><strong>1. 性能核心指标对比</strong></h3>      <div class="table-container"><table><thead><tr><th><strong>指标</strong></th><th><strong>Quarkus</strong></th><th><strong>Spring Boot</strong></th></tr></thead><tbody><tr><td><strong>启动时间</strong></td><td>毫秒级（通常 &lt;100ms）</td><td>秒级（通常 1-5s，依赖依赖和配置）</td></tr><tr><td><strong>内存占用</strong></td><td>极低（容器化场景下可低至 100MB 以下）</td><td>较高（通常 500MB 以上，取决于配置）</td></tr><tr><td><strong>CPU 利用率</strong></td><td>高效（非阻塞模型减少 CPU 浪费）</td><td>中等（阻塞模型可能导致 CPU 空转）</td></tr><tr><td><strong>吞吐量</strong></td><td>高（非阻塞 I&#x2F;O 支持更高并发）</td><td>中等（默认阻塞 I&#x2F;O，可通过 WebFlux 提升）</td></tr><tr><td><strong>JVM 优化</strong></td><td>GraalVM 原生镜像显著提升性能</td><td>依赖 JVM 优化，启动和内存成本较高</td></tr></tbody></table></div><hr>        <h3 id="2-架构设计差异"   >          <a href="#2-架构设计差异" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-架构设计差异" class="headerlink" title="2. 架构设计差异"></a><strong>2. 架构设计差异</strong></h3>              <h4 id="Quarkus"   >          <a href="#Quarkus" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quarkus" class="headerlink" title="Quarkus"></a><strong>Quarkus</strong></h4>      <p>• <strong>云原生优先</strong>：专为 Kubernetes 和容器化环境设计，优化了资源分配和冷启动问题。<br>• <strong>即时编译（JIT）与原生镜像</strong>：<br>  • 通过 GraalVM 编译为本地可执行文件，无需 JVM，启动速度极快，内存占用低。<br>  • 传统模式（JVM）下仍比 Spring Boot 更轻量。<br>• <strong>非阻塞 I&#x2F;O 默认支持</strong>：<br>  • 基于 Vert.x 或 SmallRye 实现响应式编程，天然支持高并发。<br>• <strong>统一配置管理</strong>：<br>  • 通过 <code>application.properties</code> 集中式管理配置，支持动态更新。</p>        <h4 id="Spring-Boot"   >          <a href="#Spring-Boot" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><strong>Spring Boot</strong></h4>      <p>• <strong>传统 JVM 优化</strong>：<br>  • 依赖 JVM 的 JIT 编译和垃圾回收机制，启动时间较长，但成熟度高。<br>  • 内存占用较高（尤其 Spring Boot Starter 依赖较多时）。<br>• <strong>混合编程模型</strong>：<br>  • 默认支持阻塞式 Servlet（Tomcat&#x2F;Jetty），也可通过 Spring WebFlux 实现非阻塞 I&#x2F;O。<br>• <strong>庞大的生态系统</strong>：<br>  • 集成 Spring 生态（Spring Data、Security、Cloud 等），开发效率高。</p><hr>        <h3 id="3-性能实测对比"   >          <a href="#3-性能实测对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-性能实测对比" class="headerlink" title="3. 性能实测对比"></a><strong>3. 性能实测对比</strong></h3>              <h3 id="基准测试（以-HTTP-请求为例）"   >          <a href="#基准测试（以-HTTP-请求为例）" class="heading-link"><i class="fas fa-link"></i></a><a href="#基准测试（以-HTTP-请求为例）" class="headerlink" title="基准测试（以 HTTP 请求为例）"></a><strong>基准测试（以 HTTP 请求为例）</strong></h3>      <div class="table-container"><table><thead><tr><th><strong>场景</strong></th><th><strong>Quarkus（GraalVM 原生镜像）</strong></th><th><strong>Quarkus（JVM 模式）</strong></th><th><strong>Spring Boot（Tomcat）</strong></th><th><strong>Spring Boot（WebFlux）</strong></th></tr></thead><tbody><tr><td><strong>启动时间</strong></td><td>~50ms</td><td>~200ms</td><td>~1.2s</td><td>~1.5s</td></tr><tr><td><strong>内存占用（空闲）</strong></td><td>~80MB</td><td>~150MB</td><td>~400MB</td><td>~450MB</td></tr><tr><td><strong>每秒请求数（10k 并发）</strong></td><td>50,000+</td><td>30,000+</td><td>15,000+</td><td>40,000+</td></tr><tr><td><strong>99% 延迟（P99）</strong></td><td>~2ms</td><td>~5ms</td><td>~15ms</td><td>~8ms</td></tr></tbody></table></div>        <h4 id="关键结论"   >          <a href="#关键结论" class="heading-link"><i class="fas fa-link"></i></a><a href="#关键结论" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h4>      <ol><li><strong>启动速度</strong>：Quarkus（GraalVM）完胜，适合无服务器（Serverless）和频繁扩缩容场景。</li><li><strong>内存效率</strong>：Quarkus 在容器中资源利用率更高，成本更低。</li><li><strong>高并发吞吐量</strong>：Quarkus（非阻塞）和 Spring WebFlux 性能接近，但 Quarkus 更轻量。</li><li><strong>传统场景</strong>：Spring Boot（Tomcat）在开发效率和成熟生态上占优。</li></ol><hr>        <h3 id="4-适用场景对比"   >          <a href="#4-适用场景对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-适用场景对比" class="headerlink" title="4. 适用场景对比"></a><strong>4. 适用场景对比</strong></h3>              <h4 id="Quarkus-更适合"   >          <a href="#Quarkus-更适合" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quarkus-更适合" class="headerlink" title="Quarkus 更适合"></a><strong>Quarkus 更适合</strong></h4>      <p>• <strong>云原生微服务</strong>：Kubernetes 环境下的轻量级服务。<br>• <strong>无服务器架构（Serverless）</strong>：AWS Lambda、Azure Functions 等。<br>• <strong>实时数据处理</strong>：高并发、低延迟的 API 或流处理。<br>• <strong>资源受限环境</strong>：边缘计算或 IoT 设备。</p>        <h4 id="Spring-Boot-更适合"   >          <a href="#Spring-Boot-更适合" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring-Boot-更适合" class="headerlink" title="Spring Boot 更适合"></a><strong>Spring Boot 更适合</strong></h4>      <p>• <strong>企业级单体应用</strong>：依赖复杂业务逻辑和传统架构。<br>• <strong>快速原型开发</strong>：依赖 Spring 生态（如 Spring Data、Security）。<br>• <strong>混合技术栈</strong>：需要与现有 Spring 系统无缝集成。<br>• <strong>阻塞式 I&#x2F;O 场景</strong>：传统数据库驱动的应用。</p><hr>        <h3 id="5-代码示例对比"   >          <a href="#5-代码示例对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-代码示例对比" class="headerlink" title="5. 代码示例对比"></a><strong>5. 代码示例对比</strong></h3>              <h4 id="Quarkus（REST-API）"   >          <a href="#Quarkus（REST-API）" class="heading-link"><i class="fas fa-link"></i></a><a href="#Quarkus（REST-API）" class="headerlink" title="Quarkus（REST API）"></a><strong>Quarkus（REST API）</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.ws.rs.GET;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Path;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.Produces;</span><br><span class="line"><span class="keyword">import</span> javax.ws.rs.core.MediaType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Path(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingResource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Produces(MediaType.TEXT_PLAIN)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Quarkus!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="Spring-Boot（REST-API）"   >          <a href="#Spring-Boot（REST-API）" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring-Boot（REST-API）" class="headerlink" title="Spring Boot（REST API）"></a><strong>Spring Boot（REST API）</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="6-总结与选型建议"   >          <a href="#6-总结与选型建议" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-总结与选型建议" class="headerlink" title="6. 总结与选型建议"></a><strong>6. 总结与选型建议</strong></h3>              <h4 id="选择-Quarkus-的场景"   >          <a href="#选择-Quarkus-的场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择-Quarkus-的场景" class="headerlink" title="选择 Quarkus 的场景"></a><strong>选择 Quarkus 的场景</strong></h4>      <p>• 需要极低的资源消耗和极速启动。<br>• 构建云原生、容器化或无服务器应用。<br>• 追求 GraalVM 原生镜像的性能优势。</p>        <h4 id="选择-Spring-Boot-的场景"   >          <a href="#选择-Spring-Boot-的场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择-Spring-Boot-的场景" class="headerlink" title="选择 Spring Boot 的场景"></a><strong>选择 Spring Boot 的场景</strong></h4>      <p>• 团队熟悉 Spring 生态，需快速迭代开发。<br>• 依赖大量 Spring 模块（如 Spring Security、Batch）。<br>• 项目对启动时间和内存不敏感（如内部工具或单体应用）。</p>        <h4 id="性能优先级排序"   >          <a href="#性能优先级排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#性能优先级排序" class="headerlink" title="性能优先级排序"></a><strong>性能优先级排序</strong></h4>      <p>Quarkus + GraalVM &gt; Quarkus (JVM) &gt; Spring WebFlux &gt; Spring Boot (Tomcat)</p>        <h4 id="开发效率优先级排序"   >          <a href="#开发效率优先级排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#开发效率优先级排序" class="headerlink" title="开发效率优先级排序"></a><strong>开发效率优先级排序</strong></h4>      <p>Spring Boot &gt; Quarkus</p><hr><p><strong>最终结论</strong>：<br>如果目标是构建高性能、轻量级的云原生应用，<strong>Quarkus</strong> 是更优的选择；若需要成熟的生态、快速开发能力或与现有 Spring 系统集成，<strong>Spring Boot</strong> 仍是可靠的选择。两者并非完全对立，实际选型需结合团队能力、项目需求和长期维护成本综合考量。</p>]]></content>
    
    
    <summary type="html">Quarkus和SpringBoot性能对比</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Quarkus" scheme="https://ljd0620.github.io/tags/Quarkus/"/>
    
    <category term="SpringBoot" scheme="https://ljd0620.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Quarkus云原生框架介绍</title>
    <link href="https://ljd0620.github.io/2025/03/28/Quarkus%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>https://ljd0620.github.io/2025/03/28/Quarkus%E4%BA%91%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</id>
    <published>2025-03-28T04:15:42.000Z</published>
    <updated>2025-03-28T02:22:07.461Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Quarkus</strong> 是一款专为 <strong>云原生（Cloud-Native）</strong> 和 <strong>容器化环境</strong> 设计的全栈 Java 框架，由 Red Hat 主导开发。它聚焦于 <strong>极低内存占用</strong>、<strong>极速启动时间</strong> 和 <strong>高效的资源利用率</strong>，旨在解决传统 Java 应用在容器化、微服务和无服务器（Serverless）场景下的性能瓶颈问题。</p><hr>        <h3 id="一、Quarkus-的核心设计目标"   >          <a href="#一、Quarkus-的核心设计目标" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、Quarkus-的核心设计目标" class="headerlink" title="一、Quarkus 的核心设计目标"></a><strong>一、Quarkus 的核心设计目标</strong></h3>      <ol><li><strong>云原生优先</strong>  <ul><li>原生支持 Kubernetes、OpenShift 等容器编排平台。</li><li>自动生成 Kubernetes 部署文件（YAML）。</li></ul></li><li><strong>极致性能</strong>  <ul><li><strong>编译时优化</strong>：通过提前编译（AOT）减少运行时开销。</li><li><strong>低内存占用</strong>：优化内存使用，适合高密度部署。</li><li><strong>快速启动</strong>：毫秒级启动（冷启动优化，适合 Serverless）。</li></ul></li><li><strong>开发者友好</strong>  <ul><li><strong>实时编码（Live Coding）</strong>：代码修改后无需重启，立即生效。</li><li><strong>统一配置</strong>：通过 <code>application.properties</code> 管理所有组件配置。</li><li><strong>丰富的扩展生态</strong>：集成数据库、消息队列、安全等常用组件。</li></ul></li></ol><hr>        <h3 id="二、Quarkus-的核心技术"   >          <a href="#二、Quarkus-的核心技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、Quarkus-的核心技术" class="headerlink" title="二、Quarkus 的核心技术"></a><strong>二、Quarkus 的核心技术</strong></h3>              <h4 id="1-基于-GraalVM-的-Native-Image"   >          <a href="#1-基于-GraalVM-的-Native-Image" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-基于-GraalVM-的-Native-Image" class="headerlink" title="1. 基于 GraalVM 的 Native Image"></a><strong>1. 基于 GraalVM 的 Native Image</strong></h4>      <ul><li><strong>AOT 编译</strong>：将 Java 应用编译为原生机器码（Native Image），显著减少启动时间和内存占用。</li><li><strong>示例性能对比</strong>：<div class="table-container"><table><thead><tr><th><strong>指标</strong></th><th>传统 JVM 模式</th><th>Native Image 模式</th></tr></thead><tbody><tr><td><strong>启动时间</strong></td><td>1.2s</td><td>0.02s</td></tr><tr><td><strong>内存占用</strong></td><td>120MB</td><td>25MB</td></tr></tbody></table></div></li></ul>        <h4 id="2-响应式编程支持"   >          <a href="#2-响应式编程支持" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-响应式编程支持" class="headerlink" title="2. 响应式编程支持"></a><strong>2. 响应式编程支持</strong></h4>      <ul><li><strong>响应式引擎</strong>：基于 <strong>Vert.x</strong> 和 <strong>Mutiny</strong> 实现非阻塞 I&#x2F;O。</li><li><strong>混合编程模型</strong>：支持同步（Imperative）和异步（Reactive）混合开发。</li></ul>        <h4 id="3-编译时增强（Compile-Time-Augmentation）"   >          <a href="#3-编译时增强（Compile-Time-Augmentation）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-编译时增强（Compile-Time-Augmentation）" class="headerlink" title="3. 编译时增强（Compile-Time Augmentation）"></a><strong>3. 编译时增强（Compile-Time Augmentation）</strong></h4>      <ul><li><strong>减少反射和动态类加载</strong>：在编译时生成元数据，避免运行时反射开销。</li><li><strong>依赖注入优化</strong>：基于 <strong>CDI（Contexts and Dependency Injection）</strong> 实现轻量级 DI。</li></ul><hr>        <h3 id="三、Quarkus-的适用场景"   >          <a href="#三、Quarkus-的适用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、Quarkus-的适用场景" class="headerlink" title="三、Quarkus 的适用场景"></a><strong>三、Quarkus 的适用场景</strong></h3>      <div class="table-container"><table><thead><tr><th><strong>场景</strong></th><th><strong>传统框架痛点</strong></th><th><strong>Quarkus 解决方案</strong></th></tr></thead><tbody><tr><td><strong>微服务</strong></td><td>启动慢、内存高</td><td>毫秒级启动，低内存占用</td></tr><tr><td><strong>Serverless</strong></td><td>冷启动延迟高</td><td>Native Image 减少冷启动时间</td></tr><tr><td><strong>高密度部署</strong></td><td>单节点容器部署实例少</td><td>低内存消耗支持更多实例</td></tr><tr><td><strong>边缘计算</strong></td><td>资源受限（CPU&#x2F;内存）</td><td>极致轻量化，适应边缘设备</td></tr></tbody></table></div><hr>        <h3 id="四、Quarkus-的主要特性"   >          <a href="#四、Quarkus-的主要特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、Quarkus-的主要特性" class="headerlink" title="四、Quarkus 的主要特性"></a><strong>四、Quarkus 的主要特性</strong></h3>              <h4 id="1-开发体验优化"   >          <a href="#1-开发体验优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-开发体验优化" class="headerlink" title="1. 开发体验优化"></a><strong>1. 开发体验优化</strong></h4>      <ul><li><strong>实时编码（Live Coding）</strong>：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn quarkus:dev  <span class="comment"># 启动开发模式，修改代码自动热更新</span></span><br></pre></td></tr></table></div></figure></li><li><strong>统一扩展管理</strong>：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn quarkus:list-extensions  <span class="comment"># 查看可用扩展</span></span><br><span class="line">mvn quarkus:add-extension -Dextensions=<span class="string">&quot;quarkus-resteasy&quot;</span>  <span class="comment"># 添加扩展</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-集成主流技术栈"   >          <a href="#2-集成主流技术栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-集成主流技术栈" class="headerlink" title="2. 集成主流技术栈"></a><strong>2. 集成主流技术栈</strong></h4>      <ul><li><strong>Web 服务</strong>：RESTEasy（JAX-RS）、Spring Web 兼容层。</li><li><strong>数据访问</strong>：Hibernate ORM、Panache（简化 JPA）、Reactive SQL 驱动。</li><li><strong>消息队列</strong>：Apache Kafka、AMQP（RabbitMQ）。</li><li><strong>安全</strong>：Keycloak、OAuth2、JWT。</li><li><strong>监控</strong>：Micrometer、Prometheus、Grafana。</li></ul>        <h4 id="3-原生-Kubernetes-集成"   >          <a href="#3-原生-Kubernetes-集成" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-原生-Kubernetes-集成" class="headerlink" title="3. 原生 Kubernetes 集成"></a><strong>3. 原生 Kubernetes 集成</strong></h4>      <ul><li>自动生成 Deployment、Service、ConfigMap 等资源文件：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn quarkus:kubernetes  <span class="comment"># 生成 Kubernetes YAML</span></span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="五、Quarkus-vs-Spring-Boot"   >          <a href="#五、Quarkus-vs-Spring-Boot" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、Quarkus-vs-Spring-Boot" class="headerlink" title="五、Quarkus vs Spring Boot"></a><strong>五、Quarkus vs Spring Boot</strong></h3>      <div class="table-container"><table><thead><tr><th><strong>维度</strong></th><th><strong>Quarkus</strong></th><th><strong>Spring Boot</strong></th></tr></thead><tbody><tr><td><strong>启动速度</strong></td><td>毫秒级（Native Image）</td><td>秒级（依赖 JVM 启动）</td></tr><tr><td><strong>内存占用</strong></td><td>20~50MB（Native）</td><td>100~300MB</td></tr><tr><td><strong>云原生支持</strong></td><td>原生 Kubernetes 集成</td><td>需额外配置（如 Spring Cloud）</td></tr><tr><td><strong>编程模型</strong></td><td>同步 + 响应式混合</td><td>以同步为主（WebFlux 支持响应式）</td></tr><tr><td><strong>社区生态</strong></td><td>快速成长，Red Hat 支持</td><td>成熟，生态庞大</td></tr></tbody></table></div><hr>        <h3 id="六、快速入门示例"   >          <a href="#六、快速入门示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、快速入门示例" class="headerlink" title="六、快速入门示例"></a><strong>六、快速入门示例</strong></h3>              <h4 id="1-创建项目"   >          <a href="#1-创建项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a><strong>1. 创建项目</strong></h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn io.quarkus:quarkus-maven-plugin:create \</span><br><span class="line">    -DprojectGroupId=com.example \</span><br><span class="line">    -DprojectArtifactId=quarkus-demo \</span><br><span class="line">    -Dextensions=<span class="string">&quot;resteasy&quot;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="2-编写-REST-接口"   >          <a href="#2-编写-REST-接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-编写-REST-接口" class="headerlink" title="2. 编写 REST 接口"></a><strong>2. 编写 REST 接口</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloResource</span> &#123;</span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="meta">@Produces(MediaType.TEXT_PLAIN)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Quarkus!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-启动应用"   >          <a href="#3-启动应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-启动应用" class="headerlink" title="3. 启动应用"></a><strong>3. 启动应用</strong></h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn quarkus:dev  <span class="comment"># 开发模式（支持热更新）</span></span><br></pre></td></tr></table></div></figure>        <h4 id="4-构建-Native-Image"   >          <a href="#4-构建-Native-Image" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-构建-Native-Image" class="headerlink" title="4. 构建 Native Image"></a><strong>4. 构建 Native Image</strong></h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package -Pnative  <span class="comment"># 生成原生可执行文件（需 GraalVM）</span></span><br></pre></td></tr></table></div></figure><hr>        <h3 id="七、Quarkus-的适用对象"   >          <a href="#七、Quarkus-的适用对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、Quarkus-的适用对象" class="headerlink" title="七、Quarkus 的适用对象"></a><strong>七、Quarkus 的适用对象</strong></h3>      <ol><li><strong>云原生开发者</strong>：需要快速构建高效微服务。</li><li><strong>Serverless 开发者</strong>：关注冷启动性能和资源成本。</li><li><strong>传统 Java 开发者</strong>：希望平滑迁移到云原生架构。</li><li><strong>运维团队</strong>：追求高密度部署和低资源消耗。</li></ol><hr>        <h3 id="八、总结"   >          <a href="#八、总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、总结" class="headerlink" title="八、总结"></a><strong>八、总结</strong></h3>      <p><strong>Quarkus</strong> 重新定义了 Java 在云原生时代的可能性，其核心价值在于：</p><ul><li><strong>极致性能</strong>：通过 Native Image 和编译时优化突破 JVM 传统限制。</li><li><strong>开发者效率</strong>：实时编码和统一配置提升开发体验。</li><li><strong>云原生集成</strong>：开箱即用的 Kubernetes 支持降低运维复杂度。</li></ul><p>对于追求 <strong>高性能</strong>、<strong>低资源消耗</strong> 和 <strong>快速迭代</strong> 的云原生项目，Quarkus 是比 Spring Boot 更具竞争力的选择。</p>]]></content>
    
    
    <summary type="html">Quarkus云原生框架介绍</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ljd0620.github.io/tags/Java/"/>
    
    <category term="Quarkus" scheme="https://ljd0620.github.io/tags/Quarkus/"/>
    
    <category term="云原生" scheme="https://ljd0620.github.io/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>深度剖析Java虚拟线程技术</title>
    <link href="https://ljd0620.github.io/2025/03/27/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Java%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/"/>
    <id>https://ljd0620.github.io/2025/03/27/%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Java%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF/</id>
    <published>2025-03-27T09:52:41.000Z</published>
    <updated>2025-03-28T00:48:30.270Z</updated>
    
    <content type="html"><![CDATA[<p>Java 虚拟线程（Virtual Threads）是 <strong>JDK 19</strong> 引入的 <strong>JEP 425</strong> 特性，并在 <strong>JDK 21</strong> 正式发布。它是 Project Loom 的核心成果，旨在解决传统线程（平台线程）在高并发场景下的性能瓶颈问题。  </p><hr>        <h3 id="一、虚拟线程-vs-平台线程"   >          <a href="#一、虚拟线程-vs-平台线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、虚拟线程-vs-平台线程" class="headerlink" title="一、虚拟线程 vs 平台线程"></a><strong>一、虚拟线程 vs 平台线程</strong></h3>              <h4 id="1-平台线程（Platform-Threads）的痛点"   >          <a href="#1-平台线程（Platform-Threads）的痛点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-平台线程（Platform-Threads）的痛点" class="headerlink" title="1. 平台线程（Platform Threads）的痛点"></a><strong>1. 平台线程（Platform Threads）的痛点</strong></h4>      <ul><li><strong>1:1 线程模型</strong>：每个 Java 线程直接映射一个 OS 线程（内核线程）。</li><li><strong>高内存开销</strong>：每个线程默认占用 <strong>1MB</strong> 栈内存（可调整但有限）。</li><li><strong>上下文切换成本高</strong>：线程调度依赖 OS，频繁切换影响性能。</li><li><strong>并发能力受限</strong>：通常 <strong>1000~5000</strong> 个线程就会耗尽资源。</li></ul>        <h4 id="2-虚拟线程（Virtual-Threads）的优势"   >          <a href="#2-虚拟线程（Virtual-Threads）的优势" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-虚拟线程（Virtual-Threads）的优势" class="headerlink" title="2. 虚拟线程（Virtual Threads）的优势"></a><strong>2. 虚拟线程（Virtual Threads）的优势</strong></h4>      <ul><li><strong>M:N 线程模型</strong>：多个虚拟线程映射到少量 OS 线程（由 JVM 调度）。</li><li><strong>轻量级</strong>：初始栈内存仅 <strong>~200B</strong>，可支持 <strong>百万级</strong> 并发。</li><li><strong>低切换开销</strong>：调度由 JVM 管理，不涉及 OS 上下文切换。</li><li><strong>兼容性</strong>：直接复用 <code>Thread</code> API，无需修改现有代码。</li></ul><div class="table-container"><table><thead><tr><th><strong>特性</strong></th><th><strong>平台线程</strong></th><th><strong>虚拟线程</strong></th></tr></thead><tbody><tr><td><strong>线程模型</strong></td><td>1:1（绑定 OS 线程）</td><td>M:N（由 JVM 调度）</td></tr><tr><td><strong>内存占用</strong></td><td>~1MB&#x2F;线程</td><td>~200B&#x2F;线程</td></tr><tr><td><strong>创建速度</strong></td><td>慢（依赖 OS 资源）</td><td>极快（纯 JVM 管理）</td></tr><tr><td><strong>适用场景</strong></td><td>CPU 密集型任务</td><td>I&#x2F;O 密集型高并发任务</td></tr></tbody></table></div><hr>        <h3 id="二、虚拟线程的核心原理"   >          <a href="#二、虚拟线程的核心原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、虚拟线程的核心原理" class="headerlink" title="二、虚拟线程的核心原理"></a><strong>二、虚拟线程的核心原理</strong></h3>              <h4 id="1-协程（Coroutine）实现"   >          <a href="#1-协程（Coroutine）实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-协程（Coroutine）实现" class="headerlink" title="1. 协程（Coroutine）实现"></a><strong>1. 协程（Coroutine）实现</strong></h4>      <p>虚拟线程本质是 <strong>用户态协程</strong>，由 JVM 在用户空间调度，仅在执行 <strong>阻塞操作</strong>（如 I&#x2F;O）时挂起并让出线程，避免阻塞 OS 线程。</p>        <h4 id="2-调度机制"   >          <a href="#2-调度机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-调度机制" class="headerlink" title="2. 调度机制"></a><strong>2. 调度机制</strong></h4>      <ul><li><strong>ForkJoinPool 调度器</strong>：默认使用 <code>ForkJoinPool</code> 作为虚拟线程的载体线程池。</li><li><strong>挂起（Yield）与恢复</strong>：<br>当虚拟线程执行 <code>Blocking</code> 操作（如 <code>synchronized</code>、<code>File I/O</code>、<code>Socket</code>）时：<ol><li>JVM 挂起当前虚拟线程。</li><li>载体线程（Carrier Thread）执行其他虚拟线程。</li><li>I&#x2F;O 完成后，虚拟线程被重新调度执行。</li></ol></li></ul>        <h4 id="3-关键优化点"   >          <a href="#3-关键优化点" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-关键优化点" class="headerlink" title="3. 关键优化点"></a><strong>3. 关键优化点</strong></h4>      <ul><li><strong>堆栈帧分离</strong>：虚拟线程挂起时，堆栈帧存储在堆内存，而非 OS 线程栈。</li><li><strong>Continuation 机制</strong>：通过 <code>Continuation</code> 对象保存执行状态，支持快速恢复。</li></ul><hr>        <h3 id="三、虚拟线程的使用方式"   >          <a href="#三、虚拟线程的使用方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、虚拟线程的使用方式" class="headerlink" title="三、虚拟线程的使用方式"></a><strong>三、虚拟线程的使用方式</strong></h3>              <h4 id="1-创建虚拟线程（JDK-21-）"   >          <a href="#1-创建虚拟线程（JDK-21-）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-创建虚拟线程（JDK-21-）" class="headerlink" title="1. 创建虚拟线程（JDK 21+）"></a><strong>1. 创建虚拟线程（JDK 21+）</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：Thread.startVirtualThread()</span></span><br><span class="line">Thread.startVirtualThread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Virtual thread running&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：Thread.ofVirtual()</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">virtualThread</span> <span class="operator">=</span> Thread.ofVirtual()</span><br><span class="line">    .name(<span class="string">&quot;my-virtual-thread&quot;</span>)</span><br><span class="line">    .start(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Named virtual thread&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式3：ExecutorService（推荐）</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    executor.submit(() -&gt; System.out.println(<span class="string">&quot;Task 1&quot;</span>));</span><br><span class="line">    executor.submit(() -&gt; System.out.println(<span class="string">&quot;Task 2&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-与传统线程的交互"   >          <a href="#2-与传统线程的交互" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-与传统线程的交互" class="headerlink" title="2. 与传统线程的交互"></a><strong>2. 与传统线程的交互</strong></h4>      <p>虚拟线程可以 <strong>无缝调用</strong> 平台线程的 API：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">virtualThread</span> <span class="operator">=</span> Thread.ofVirtual().start(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 在虚拟线程中调用平台线程的 sleep</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 挂起虚拟线程，不阻塞 OS 线程</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>        <h4 id="3-注意事项"   >          <a href="#3-注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-注意事项" class="headerlink" title="3. 注意事项"></a><strong>3. 注意事项</strong></h4>      <ul><li><strong>避免 <code>synchronized</code></strong>：会阻塞载体线程，改用 <code>ReentrantLock</code>。</li><li><strong>不要池化虚拟线程</strong>：创建成本极低，用完即弃。</li><li><strong>CPU 密集型任务仍用平台线程</strong>：虚拟线程适合 I&#x2F;O 密集型场景。</li></ul><hr>        <h3 id="四、性能对比"   >          <a href="#四、性能对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、性能对比" class="headerlink" title="四、性能对比"></a><strong>四、性能对比</strong></h3>              <h4 id="1-吞吐量测试（Web-服务器场景）"   >          <a href="#1-吞吐量测试（Web-服务器场景）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-吞吐量测试（Web-服务器场景）" class="headerlink" title="1. 吞吐量测试（Web 服务器场景）"></a><strong>1. 吞吐量测试（Web 服务器场景）</strong></h4>      <div class="table-container"><table><thead><tr><th><strong>线程类型</strong></th><th><strong>最大并发请求数</strong></th><th><strong>内存占用</strong></th><th><strong>响应时间（P99）</strong></th></tr></thead><tbody><tr><td>平台线程（1000）</td><td>~1000</td><td>~1GB</td><td>500ms</td></tr><tr><td>虚拟线程（1M）</td><td>~1,000,000</td><td>~200MB</td><td>50ms</td></tr></tbody></table></div>        <h4 id="2-适用场景"   >          <a href="#2-适用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a><strong>2. 适用场景</strong></h4>      <ul><li><strong>推荐使用</strong>：<ul><li>高并发 HTTP 服务（如 Spring Boot + Tomcat）。</li><li>微服务调用（Feign&#x2F;RestTemplate）。</li><li>数据库访问（JDBC、R2DBC）。</li></ul></li><li><strong>不推荐使用</strong>：<ul><li>计算密集型任务（如视频编码）。</li><li>依赖 <code>synchronized</code> 的代码块。</li></ul></li></ul><hr>        <h3 id="五、虚拟线程的底层实现"   >          <a href="#五、虚拟线程的底层实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、虚拟线程的底层实现" class="headerlink" title="五、虚拟线程的底层实现"></a><strong>五、虚拟线程的底层实现</strong></h3>              <h4 id="1-JVM-改动"   >          <a href="#1-JVM-改动" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JVM-改动" class="headerlink" title="1. JVM 改动"></a><strong>1. JVM 改动</strong></h4>      <ul><li><strong><code>Continuation</code> 对象</strong>：存储挂起线程的栈帧和执行点。</li><li><strong><code>ForkJoinPool</code> 调度</strong>：默认使用 <code>Runtime.getRuntime().availableProcessors()</code> 个载体线程。</li></ul>        <h4 id="2-挂起-恢复流程"   >          <a href="#2-挂起-恢复流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-挂起-恢复流程" class="headerlink" title="2. 挂起&#x2F;恢复流程"></a><strong>2. 挂起&#x2F;恢复流程</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">virtualThreadTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">data</span> <span class="operator">=</span> httpClient.get(...); <span class="comment">// (1) 挂起点：I/O 阻塞</span></span><br><span class="line">    process(data);                  <span class="comment">// (2) 恢复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ol><li>当虚拟线程执行到 <strong>阻塞操作</strong> 时，JVM 挂起当前 <code>Continuation</code>。</li><li>载体线程切换到其他虚拟线程。</li><li>I&#x2F;O 完成后，<code>Continuation</code> 被重新调度。</li></ol>        <h4 id="3-调试支持"   >          <a href="#3-调试支持" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-调试支持" class="headerlink" title="3. 调试支持"></a><strong>3. 调试支持</strong></h4>      <ul><li><strong><code>jcmd</code> 命令</strong>：查看虚拟线程状态：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid&gt; Thread.dump_to_file -format=json vthreads.json</span><br></pre></td></tr></table></div></figure></li><li><strong>JFR（Java Flight Recorder）</strong>：监控虚拟线程生命周期。</li></ul><hr>        <h3 id="六、与传统异步编程的对比"   >          <a href="#六、与传统异步编程的对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、与传统异步编程的对比" class="headerlink" title="六、与传统异步编程的对比"></a><strong>六、与传统异步编程的对比</strong></h3>      <div class="table-container"><table><thead><tr><th><strong>方案</strong></th><th><strong>编程模型</strong></th><th><strong>调试难度</strong></th><th><strong>线程利用率</strong></th><th><strong>兼容性</strong></th></tr></thead><tbody><tr><td><strong>虚拟线程</strong></td><td>同步阻塞</td><td>简单（传统调试）</td><td>极高</td><td>兼容所有同步代码</td></tr><tr><td><strong>CompletableFuture</strong></td><td>异步回调</td><td>复杂（回调地狱）</td><td>高</td><td>需重构为异步</td></tr><tr><td><strong>Reactive (WebFlux)</strong></td><td>响应式流</td><td>困难</td><td>高</td><td>需学习新范式</td></tr></tbody></table></div><p><strong>结论</strong>：虚拟线程在 <strong>代码可读性</strong> 和 <strong>性能</strong> 之间取得了最佳平衡。</p><hr>        <h3 id="七、最佳实践"   >          <a href="#七、最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、最佳实践" class="headerlink" title="七、最佳实践"></a><strong>七、最佳实践</strong></h3>      <ol><li><p><strong>替换 <code>ExecutorService</code></strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧方式（平台线程池）</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新方式（虚拟线程）</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</span><br></pre></td></tr></table></div></figure></li><li><p><strong>避免 <code>synchronized</code></strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误用法（会阻塞载体线程）</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确用法（使用 ReentrantLock）</span></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">/* ... */</span> &#125; <span class="keyword">finally</span> &#123; lock.unlock(); &#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>监控与调试</strong>：</p><ul><li>使用 <code>jconsole</code> 或 <code>JFR</code> 观察虚拟线程状态。</li><li>避免在虚拟线程中执行长时间 CPU 计算。</li></ul></li></ol><hr>        <h3 id="八、总结"   >          <a href="#八、总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、总结" class="headerlink" title="八、总结"></a><strong>八、总结</strong></h3>      <ul><li><strong>虚拟线程是 Java 并发的革命性改进</strong>，显著提升 I&#x2F;O 密集型应用的吞吐量。</li><li><strong>无需修改代码</strong>即可享受高并发能力，兼容现有 <code>Thread</code> API。</li><li><strong>适用场景</strong>：微服务、数据库访问、高并发 HTTP 服务。</li><li><strong>限制</strong>：不推荐用于 CPU 密集型任务或依赖 <code>synchronized</code> 的代码。</li></ul><p><strong>未来趋势</strong>：随着 Spring 6.x、Quarkus 等框架全面支持，虚拟线程将成为 Java 高并发开发的首选方案。</p>]]></content>
    
    
    <summary type="html">本文深入解析了Java虚拟线程技术的核心原理、优势及使用方式，帮助读者深入理解Java虚拟线程的设计与实现。</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ljd0620.github.io/tags/Java/"/>
    
    <category term="并发编程" scheme="https://ljd0620.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    <category term="虚拟线程" scheme="https://ljd0620.github.io/tags/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于LangChain构建AI应用入门指南</title>
    <link href="https://ljd0620.github.io/2025/03/22/%E5%9F%BA%E4%BA%8ELangChain%E6%9E%84%E5%BB%BAAI%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://ljd0620.github.io/2025/03/22/%E5%9F%BA%E4%BA%8ELangChain%E6%9E%84%E5%BB%BAAI%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</id>
    <published>2025-03-22T06:56:20.000Z</published>
    <updated>2025-03-24T07:17:36.821Z</updated>
    
    <content type="html"><![CDATA[<p>LangChain 是围绕大型语言模型（LLMs）构建应用的强大框架，适合开发问答系统、聊天机器人、自动化工具等。本指南从 <strong>环境配置</strong> 到 <strong>完整项目示例</strong>，逐步覆盖核心功能与实战技巧。</p><hr>        <h3 id="一、LangChain-核心概念"   >          <a href="#一、LangChain-核心概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、LangChain-核心概念" class="headerlink" title="一、LangChain 核心概念"></a><strong>一、LangChain 核心概念</strong></h3>      <ol><li><strong>LLM（Large Language Model）</strong><br>如 OpenAI GPT、Llama 等，负责生成文本。</li><li><strong>链（Chains）</strong><br>将多个任务组合成流程（如「提问 → 调用工具 → 总结」）。</li><li><strong>记忆（Memory）</strong><br>维护上下文信息，支持多轮对话。</li><li><strong>代理（Agents）</strong><br>让 LLM 自主决定调用哪些工具（如搜索、计算）。</li><li><strong>向量数据库（Vector Stores）</strong><br>结合外部数据（文档、知识库）实现精准回答。</li></ol><hr>        <h3 id="二、环境搭建"   >          <a href="#二、环境搭建" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a><strong>二、环境搭建</strong></h3>      <ol><li><strong>安装依赖</strong><br>确保 Python≥3.8，安装 LangChain 和 LLM 提供方（如 OpenAI）：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install langchain openai python-dotenv</span><br><span class="line"><span class="comment"># 按需添加其他工具（如向量数据库、PDF解析库）</span></span><br><span class="line">pip install faiss-cpu pypdf chromadb tiktoken</span><br></pre></td></tr></table></div></figure></li><li><strong>配置密钥</strong><br>创建 <code>.env</code> 文件保存密钥（如 OpenAI）：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OPENAI_API_KEY=&quot;sk-xxx&quot;      # OpenAI</span><br><span class="line">SERPAPI_API_KEY=&quot;serpapi-key&quot; # SerpAPI（搜索引擎工具）</span><br></pre></td></tr></table></div></figure></li></ol><hr>        <h3 id="三、基础步骤：构建问答流程"   >          <a href="#三、基础步骤：构建问答流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、基础步骤：构建问答流程" class="headerlink" title="三、基础步骤：构建问答流程"></a><strong>三、基础步骤：构建问答流程</strong></h3>              <h4 id="1-初始化-LLM-并提问"   >          <a href="#1-初始化-LLM-并提问" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-初始化-LLM-并提问" class="headerlink" title="1. 初始化 LLM 并提问"></a>1. 初始化 LLM 并提问</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.llms <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line">load_dotenv()</span><br><span class="line">llm = OpenAI(model=<span class="string">&quot;gpt-3.5-turbo-instruct&quot;</span>, temperature=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">response = llm(<span class="string">&quot;用一句话解释量子纠缠。&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></div></figure>        <h4 id="2-定义-Prompt-模板"   >          <a href="#2-定义-Prompt-模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-定义-Prompt-模板" class="headerlink" title="2. 定义 Prompt 模板"></a>2. 定义 Prompt 模板</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;你是一个物理学教授，用通俗易懂的例子解释 &#123;concept&#125;。</span></span><br><span class="line"><span class="string">要求：① 不超过100字 ② 包含一个生活案例&quot;&quot;&quot;</span></span><br><span class="line">prompt = PromptTemplate(input_variables=[<span class="string">&quot;concept&quot;</span>], template=template)</span><br><span class="line"></span><br><span class="line">formatted_prompt = prompt.<span class="built_in">format</span>(concept=<span class="string">&quot;相对论&quot;</span>)</span><br><span class="line">response = llm(formatted_prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="四、进阶功能：链（Chains）"   >          <a href="#四、进阶功能：链（Chains）" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、进阶功能：链（Chains）" class="headerlink" title="四、进阶功能：链（Chains）"></a><strong>四、进阶功能：链（Chains）</strong></h3>              <h4 id="1-构建多步处理链"   >          <a href="#1-构建多步处理链" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-构建多步处理链" class="headerlink" title="1. 构建多步处理链"></a>1. 构建多步处理链</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMChain</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义 Prompt 链</span></span><br><span class="line">chain = LLMChain(llm=llm, prompt=prompt)</span><br><span class="line">result = chain.run(<span class="string">&quot;黑洞&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合多个链</span></span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> SimpleSequentialChain</span><br><span class="line"></span><br><span class="line">chain1 = LLMChain(llm=llm, prompt=PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;topic&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;总结 &#123;topic&#125; 的三大核心特点。&quot;</span></span><br><span class="line">))</span><br><span class="line">chain2 = LLMChain(llm=llm, prompt=PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;features&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;将这些特点转化为科普短视频脚本：&#123;features&#125;&quot;</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">combined_chain = SimpleSequentialChain(chains=[chain1, chain2], verbose=<span class="literal">True</span>)</span><br><span class="line">final_output = combined_chain.run(<span class="string">&quot;量子计算机&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(final_output)</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="五、记忆（Memory）与对话"   >          <a href="#五、记忆（Memory）与对话" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、记忆（Memory）与对话" class="headerlink" title="五、记忆（Memory）与对话"></a><strong>五、记忆（Memory）与对话</strong></h3>              <h4 id="1-保留对话上下文"   >          <a href="#1-保留对话上下文" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-保留对话上下文" class="headerlink" title="1. 保留对话上下文"></a>1. 保留对话上下文</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> ConversationBufferWindowMemory</span><br><span class="line"></span><br><span class="line">memory = ConversationBufferWindowMemory(k=<span class="number">3</span>)  <span class="comment"># 保留最近3轮对话</span></span><br><span class="line">conversation = ConversationChain(llm=llm, memory=memory)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(conversation.run(<span class="string">&quot;如何用Python实现快速排序？&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(conversation.run(<span class="string">&quot;能详细说明每一步的作用吗？&quot;</span>))  <span class="comment"># 依赖上文</span></span><br></pre></td></tr></table></div></figure><hr>        <h3 id="六、代理（Agents）与工具"   >          <a href="#六、代理（Agents）与工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、代理（Agents）与工具" class="headerlink" title="六、代理（Agents）与工具"></a><strong>六、代理（Agents）与工具</strong></h3>              <h4 id="1-让模型自主调用工具"   >          <a href="#1-让模型自主调用工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-让模型自主调用工具" class="headerlink" title="1. 让模型自主调用工具"></a>1. 让模型自主调用工具</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent, load_tools</span><br><span class="line"></span><br><span class="line">tools = load_tools([<span class="string">&quot;serpapi&quot;</span>, <span class="string">&quot;llm-math&quot;</span>], llm=llm)  <span class="comment"># 搜索 + 数学工具</span></span><br><span class="line">agent = initialize_agent(</span><br><span class="line">    tools, </span><br><span class="line">    llm, </span><br><span class="line">    agent=<span class="string">&quot;zero-shot-react-description&quot;</span>,</span><br><span class="line">    verbose=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">agent.run(<span class="string">&quot;阿里巴巴集团2023年的营收是多少人民币？换算成美元是多少？&quot;</span>)</span><br></pre></td></tr></table></div></figure><p><strong>输出示例</strong>：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Action: Search阿里巴巴集团2023年营收</span><br><span class="line">Observation: 阿里巴巴2023年营收8686亿人民币</span><br><span class="line">Action: Calculator将8686亿人民币换算成美元（汇率1:7.2）</span><br><span class="line">Final Answer: 阿里巴巴2023年营收约1206.39亿美元</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="七、结合外部数据（RAG）"   >          <a href="#七、结合外部数据（RAG）" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、结合外部数据（RAG）" class="headerlink" title="七、结合外部数据（RAG）"></a><strong>七、结合外部数据（RAG）</strong></h3>              <h4 id="1-构建私有知识库问答系统"   >          <a href="#1-构建私有知识库问答系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-构建私有知识库问答系统" class="headerlink" title="1. 构建私有知识库问答系统"></a>1. 构建私有知识库问答系统</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> WebBaseLoader</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> FAISS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从网页加载数据</span></span><br><span class="line">loader = WebBaseLoader(<span class="string">&quot;https://news.cn/tech/20240401/article123.html&quot;</span>)</span><br><span class="line">documents = loader.load()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割文本</span></span><br><span class="line">text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">    chunk_size=<span class="number">1000</span>, chunk_overlap=<span class="number">200</span></span><br><span class="line">)</span><br><span class="line">texts = text_splitter.split_documents(documents)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量数据库</span></span><br><span class="line">embeddings = OpenAIEmbeddings()</span><br><span class="line">db = FAISS.from_documents(texts, embeddings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合检索的问答链</span></span><br><span class="line">query = <span class="string">&quot;文章提到哪些AI技术突破？&quot;</span></span><br><span class="line">retrieved_docs = db.similarity_search(query)</span><br><span class="line"><span class="built_in">print</span>(retrieved_docs[<span class="number">0</span>].page_content[:<span class="number">300</span>] + <span class="string">&quot;...&quot;</span>)</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="八、实战项目：合同分析助手"   >          <a href="#八、实战项目：合同分析助手" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、实战项目：合同分析助手" class="headerlink" title="八、实战项目：合同分析助手"></a><strong>八、实战项目：合同分析助手</strong></h3>              <h4 id="目标：上传-PDF-合同，自动回答关键条款问题。"   >          <a href="#目标：上传-PDF-合同，自动回答关键条款问题。" class="heading-link"><i class="fas fa-link"></i></a><a href="#目标：上传-PDF-合同，自动回答关键条款问题。" class="headerlink" title="目标：上传 PDF 合同，自动回答关键条款问题。"></a><strong>目标</strong>：上传 PDF 合同，自动回答关键条款问题。</h4>              <h4 id="1-数据预处理"   >          <a href="#1-数据预处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据预处理" class="headerlink" title="1. 数据预处理"></a>1. 数据预处理</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.document_loaders <span class="keyword">import</span> PyPDFLoader</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载 PDF 合同</span></span><br><span class="line">loader = PyPDFLoader(<span class="string">&quot;contract.pdf&quot;</span>)</span><br><span class="line">pages = loader.load()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割文本</span></span><br><span class="line">text_splitter = CharacterTextSplitter(chunk_size=<span class="number">2000</span>)</span><br><span class="line">docs = text_splitter.split_documents(pages)</span><br></pre></td></tr></table></div></figure>        <h4 id="2-构建完整流程"   >          <a href="#2-构建完整流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-构建完整流程" class="headerlink" title="2. 构建完整流程"></a>2. 构建完整流程</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建检索式问答链</span></span><br><span class="line">qa = RetrievalQA.from_chain_type(</span><br><span class="line">    llm=llm, </span><br><span class="line">    chain_type=<span class="string">&quot;stuff&quot;</span>,</span><br><span class="line">    retriever=db.as_retriever(search_kwargs=&#123;<span class="string">&quot;k&quot;</span>: <span class="number">3</span>&#125;),</span><br><span class="line">    return_source_documents=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提问</span></span><br><span class="line">question = <span class="string">&quot;合同中约定的违约金比例是多少？&quot;</span></span><br><span class="line">result = qa(&#123;<span class="string">&quot;query&quot;</span>: question&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;答案：<span class="subst">&#123;result[<span class="string">&#x27;result&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;来源条款：&quot;</span>, result[<span class="string">&#x27;source_documents&#x27;</span>][<span class="number">0</span>].page_content)</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="九、部署与优化"   >          <a href="#九、部署与优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#九、部署与优化" class="headerlink" title="九、部署与优化"></a><strong>九、部署与优化</strong></h3>              <h4 id="1-使用-FastAPI-搭建-API-服务"   >          <a href="#1-使用-FastAPI-搭建-API-服务" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用-FastAPI-搭建-API-服务" class="headerlink" title="1. 使用 FastAPI 搭建 API 服务"></a>1. 使用 FastAPI 搭建 API 服务</h4>      <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Query</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    question: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.post(<span class="params"><span class="string">&quot;/ask&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">answer_question</span>(<span class="params">query: Query</span>):</span><br><span class="line">    result = qa(&#123;<span class="string">&quot;query&quot;</span>: query.question&#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;answer&quot;</span>: result[<span class="string">&quot;result&quot;</span>],</span><br><span class="line">        <span class="string">&quot;sources&quot;</span>: [doc.page_content[:<span class="number">200</span>] <span class="keyword">for</span> doc <span class="keyword">in</span> result[<span class="string">&quot;source_documents&quot;</span>]]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p>启动服务：</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uvicorn main:app --reload</span><br></pre></td></tr></table></div></figure>        <h4 id="2-性能优化技巧"   >          <a href="#2-性能优化技巧" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-性能优化技巧" class="headerlink" title="2. 性能优化技巧"></a>2. 性能优化技巧</h4>      <ul><li><strong>缓存嵌入向量</strong>：避免重复计算文档嵌入</li><li><strong>批量处理请求</strong>：利用 <code>batch_generate</code> 提升效率</li><li><strong>错误重试机制</strong>：处理 API 调用失败</li></ul><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tenacity <span class="keyword">import</span> retry, stop_after_attempt</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">stop=stop_after_attempt(<span class="params"><span class="number">3</span></span>)</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">safe_llm_call</span>(<span class="params">prompt</span>):</span><br><span class="line">    <span class="keyword">return</span> llm(prompt)</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="十、避坑指南"   >          <a href="#十、避坑指南" class="heading-link"><i class="fas fa-link"></i></a><a href="#十、避坑指南" class="headerlink" title="十、避坑指南"></a><strong>十、避坑指南</strong></h3>      <ol><li><strong>Token 超限</strong><ul><li>设置 <code>max_tokens</code> 参数限制输出长度</li></ul></li><li><strong>响应慢</strong><ul><li>使用 <code>model=&quot;gpt-3.5-turbo&quot;</code> 替换 <code>gpt-4</code></li><li>简化提示词（减少不必要修饰语）</li></ul></li><li><strong>数据泄露风险</strong><ul><li>避免向 OpenAI 传输敏感数据（使用本地模型如 Llama）</li></ul></li></ol><hr>        <h3 id="十一、扩展应用场景"   >          <a href="#十一、扩展应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#十一、扩展应用场景" class="headerlink" title="十一、扩展应用场景"></a><strong>十一、扩展应用场景</strong></h3>      <ol><li><strong>自动化报告生成</strong><ul><li>接入数据库，自动分析数据并生成结论</li></ul></li><li><strong>企业知识库引擎</strong><ul><li>整合 Confluence、Notion 等平台数据</li></ul></li><li><strong>智能客服系统</strong><ul><li>结合对话历史和用户画像定制回复</li></ul></li></ol><p>通过以上步骤，你可以逐步构建一个功能完善的 AI 应用（如简历解析器、行业研报生成器、智能客服），涵盖从模型调用到部署的完整流程。如果需要更详细的代码示例或高级功能（如代理工具集成），可以参考 <span class="exturl"><a class="exturl__link"   href="https://python.langchain.com/docs" >LangChain 官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 或相关教程。</p>]]></content>
    
    
    <summary type="html">本指南从环境配置到完整项目示例，逐步覆盖核心功能与实战技巧。</summary>
    
    
    
    <category term="LangChain" scheme="https://ljd0620.github.io/categories/LangChain/"/>
    
    
    <category term="AI" scheme="https://ljd0620.github.io/tags/AI/"/>
    
    <category term="LLM" scheme="https://ljd0620.github.io/tags/LLM/"/>
    
    <category term="LangChain" scheme="https://ljd0620.github.io/tags/LangChain/"/>
    
  </entry>
  
  <entry>
    <title>Java各个版本的更新特性（持续更新…）</title>
    <link href="https://ljd0620.github.io/2025/03/20/Java%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%9B%B4%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E2%80%A6%EF%BC%89/"/>
    <id>https://ljd0620.github.io/2025/03/20/Java%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%9B%B4%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E2%80%A6%EF%BC%89/</id>
    <published>2025-03-20T04:52:25.000Z</published>
    <updated>2025-03-31T03:04:58.989Z</updated>
    
    <content type="html"><![CDATA[<p> 以下是 <strong>Java</strong> 各个版本的主要更新特性及代码示例（按年份倒序排列）：</p><hr>        <h3 id="Java-24-2025-年-3-月发布"   >          <a href="#Java-24-2025-年-3-月发布" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-24-2025-年-3-月发布" class="headerlink" title="Java 24 (2025 年 3 月发布)"></a><strong>Java 24 (2025 年 3 月发布)</strong></h3>              <h4 id="1-抗量子加密支持"   >          <a href="#1-抗量子加密支持" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-抗量子加密支持" class="headerlink" title="1. 抗量子加密支持"></a>1. <strong>抗量子加密支持</strong></h4>      <p>• <strong>密钥派生函数 API (JEP 478)</strong>：标准化 HKDF、Argon2 等算法，支持抗量子密钥生成。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KDF</span> <span class="variable">hkdf</span> <span class="operator">=</span> KDF.getInstance(<span class="string">&quot;HKDF-SHA256&quot;</span>);</span><br><span class="line"><span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> hkdf.deriveKey(<span class="string">&quot;AES&quot;</span>, params); <span class="comment">// 派生 AES 密钥</span></span><br></pre></td></tr></table></div></figure><br>• <strong>抗量子模块格密钥封装 (JEP 496)</strong>：增强密钥安全性，符合未来量子计算威胁。</p>        <h4 id="2-模式匹配增强"   >          <a href="#2-模式匹配增强" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-模式匹配增强" class="headerlink" title="2. 模式匹配增强"></a>2. <strong>模式匹配增强</strong></h4>      <p>• <strong>原始类型模式匹配 (JEP 488)</strong>：支持 <code>instanceof</code> 和 <code>switch</code> 直接匹配 <code>int</code>、<code>long</code> 等原始类型。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="type">int</span> num) &#123; System.out.println(num * <span class="number">2</span>); &#125; <span class="comment">// 直接使用 num</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="3-结构化并发-JEP-499"   >          <a href="#3-结构化并发-JEP-499" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-结构化并发-JEP-499" class="headerlink" title="3. 结构化并发 (JEP 499)"></a>3. <strong>结构化并发 (JEP 499)</strong></h4>      <p>• 自动管理线程生命周期，简化多线程编程。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">    scope.fork(() -&gt; fetchData());</span><br><span class="line">    scope.join(); <span class="comment">// 自动关闭子线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p>        <h4 id="4-紧凑对象头-JEP-450"   >          <a href="#4-紧凑对象头-JEP-450" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-紧凑对象头-JEP-450" class="headerlink" title="4. 紧凑对象头 (JEP 450)"></a>4. <strong>紧凑对象头 (JEP 450)</strong></h4>      <p>• 对象头从 128 位压缩至 64 位，降低内存占用。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用参数：-XX:+UseCompactObjectHeaders</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="5-流收集器-JEP-485"   >          <a href="#5-流收集器-JEP-485" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-流收集器-JEP-485" class="headerlink" title="5. 流收集器 (JEP 485)"></a>5. <strong>流收集器 (JEP 485)</strong></h4>      <p>• 支持自定义中间操作，优化数据处理管道。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; sums = numbers.stream()</span><br><span class="line">    .gather(Gatherers.windowSliding(<span class="number">2</span>)) <span class="comment">// 滑动窗口统计</span></span><br><span class="line">    .map(window -&gt; window.sum())</span><br><span class="line">    .toList();</span><br></pre></td></tr></table></div></figure></p><hr>        <h3 id="Java-21-2023-年-9-月-LTS"   >          <a href="#Java-21-2023-年-9-月-LTS" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-21-2023-年-9-月-LTS" class="headerlink" title="Java 21 (2023 年 9 月 LTS)"></a><strong>Java 21 (2023 年 9 月 LTS)</strong></h3>              <h4 id="1-虚拟线程-Virtual-Threads"   >          <a href="#1-虚拟线程-Virtual-Threads" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-虚拟线程-Virtual-Threads" class="headerlink" title="1. 虚拟线程 (Virtual Threads)"></a>1. <strong>虚拟线程 (Virtual Threads)</strong></h4>      <p>• 轻量级线程支持百万级并发，简化 I&#x2F;O 密集型任务。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10_000</span>; i++) &#123;</span><br><span class="line">        executor.submit(() -&gt; processRequest()); <span class="comment">// 每个任务独占线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p>        <h4 id="2-记录模式-Record-Patterns"   >          <a href="#2-记录模式-Record-Patterns" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-记录模式-Record-Patterns" class="headerlink" title="2. 记录模式 (Record Patterns)"></a>2. <strong>记录模式 (Record Patterns)</strong></h4>      <p>• 支持在 <code>switch</code> 和 <code>if</code> 中解构 <code>record</code> 类型。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title function_">Person</span><span class="params">(name, age)</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;, Age: &quot;</span> + age); <span class="comment">// 直接解构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p>        <h4 id="3-字符串模板-String-Templates"   >          <a href="#3-字符串模板-String-Templates" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-字符串模板-String-Templates" class="headerlink" title="3. 字符串模板 (String Templates)"></a>3. <strong>字符串模板 (String Templates)</strong></h4>      <p>• 支持插值表达式，提升代码可读性。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> STR.<span class="string">&quot;Hello, &#123;user.toUpperCase()&#125;!&quot;</span>; <span class="comment">// 编译期检查语法</span></span><br></pre></td></tr></table></div></figure></p><hr>        <h3 id="Java-17-2021-年-9-月-LTS"   >          <a href="#Java-17-2021-年-9-月-LTS" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-17-2021-年-9-月-LTS" class="headerlink" title="Java 17 (2021 年 9 月 LTS)"></a><strong>Java 17 (2021 年 9 月 LTS)</strong></h3>              <h4 id="1-密封类-Sealed-Classes"   >          <a href="#1-密封类-Sealed-Classes" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-密封类-Sealed-Classes" class="headerlink" title="1. 密封类 (Sealed Classes)"></a>1. <strong>密封类 (Sealed Classes)</strong></h4>      <p>• 限制类继承，增强代码安全性。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle, Square &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;&#125; <span class="comment">// 只允许 Circle 和 Square 继承</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="2-模式匹配增强-1"   >          <a href="#2-模式匹配增强-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-模式匹配增强-1" class="headerlink" title="2. 模式匹配增强"></a>2. <strong>模式匹配增强</strong></h4>      <p>• <code>instanceof</code> 支持直接类型转换。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123; System.out.println(s.length()); &#125; <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="3-Records-类型"   >          <a href="#3-Records-类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Records-类型" class="headerlink" title="3. Records 类型"></a>3. <strong>Records 类型</strong></h4>      <p>• 简化数据类定义，自动生成 <code>toString()</code>、<code>equals()</code> 等方法。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125; <span class="comment">// 自动生成构造函数和方法</span></span><br></pre></td></tr></table></div></figure></p><hr>        <h3 id="Java-11-2018-年-9-月-LTS"   >          <a href="#Java-11-2018-年-9-月-LTS" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-11-2018-年-9-月-LTS" class="headerlink" title="Java 11 (2018 年 9 月 LTS)"></a><strong>Java 11 (2018 年 9 月 LTS)</strong></h3>              <h4 id="1-HTTP-Client-API"   >          <a href="#1-HTTP-Client-API" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-HTTP-Client-API" class="headerlink" title="1. HTTP Client API"></a>1. <strong>HTTP Client API</strong></h4>      <p>• 支持 HTTP&#x2F;2 协议，替代 <code>HttpURLConnection</code>。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClient.newHttpClient();</span><br><span class="line"><span class="type">HttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> HttpRequest.newBuilder().uri(URI.create(<span class="string">&quot;https://example.com&quot;</span>)).build();</span><br><span class="line">client.send(request, HttpResponse.BodyHandlers.ofString()); <span class="comment">// 现代化 API</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="2-新的日期时间-API-java-time"   >          <a href="#2-新的日期时间-API-java-time" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-新的日期时间-API-java-time" class="headerlink" title="2. 新的日期时间 API (java.time)"></a>2. <strong>新的日期时间 API (java.time)</strong></h4>      <p>• 解决 <code>Date</code> 和 <code>Calendar</code> 的线程安全问题。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nextWeek</span> <span class="operator">=</span> today.plusWeeks(<span class="number">1</span>); <span class="comment">// 链式操作</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="3-Lambda-表达式-Stream-API"   >          <a href="#3-Lambda-表达式-Stream-API" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Lambda-表达式-Stream-API" class="headerlink" title="3. Lambda 表达式 &amp; Stream API"></a>3. <strong>Lambda 表达式 &amp; Stream API</strong></h4>      <p>• 函数式编程支持，简化集合操作。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; evenNumbers = numbers.stream()</span><br><span class="line">    .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .map(Integer::toString)</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// 声明式处理</span></span><br></pre></td></tr></table></div></figure></p><hr>        <h3 id="Java-8-2014-年-3-月-LTS"   >          <a href="#Java-8-2014-年-3-月-LTS" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java-8-2014-年-3-月-LTS" class="headerlink" title="Java 8 (2014 年 3 月 LTS)"></a><strong>Java 8 (2014 年 3 月 LTS)</strong></h3>              <h4 id="1-Lambda-表达式"   >          <a href="#1-Lambda-表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Lambda-表达式" class="headerlink" title="1. Lambda 表达式"></a>1. <strong>Lambda 表达式</strong></h4>      <p>• 引入函数式编程范式。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">names.forEach(name -&gt; System.out.println(name)); <span class="comment">// 简洁的循环</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="2-Stream-API"   >          <a href="#2-Stream-API" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Stream-API" class="headerlink" title="2. Stream API"></a>2. <strong>Stream API</strong></h4>      <p>• 声明式数据处理。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// 简化聚合操作</span></span><br></pre></td></tr></table></div></figure></p>        <h4 id="3-Optional-类"   >          <a href="#3-Optional-类" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Optional-类" class="headerlink" title="3. Optional 类"></a>3. <strong>Optional 类</strong></h4>      <p>• 避免空指针异常。<br>  <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.ofNullable(getString());</span><br><span class="line">optional.ifPresent(System.out::println); <span class="comment">// 安全的空值处理</span></span><br></pre></td></tr></table></div></figure></p><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>• <strong>Java 24</strong>：聚焦抗量子安全、性能优化和语言简洁性。<br>• <strong>Java 21</strong>：虚拟线程和记录模式推动高并发编程。<br>• <strong>Java 17</strong>：密封类和模式匹配增强代码结构。<br>• <strong>Java 11</strong>：现代化 HTTP 和日期时间 API。<br>• <strong>Java 8</strong>：函数式编程和集合处理的基础。</p>]]></content>
    
    
    <summary type="html">本文介绍了Java各个版本的更新特性，包括Java 8到Java 24的主要更新特性及代码示例（按年份倒序排列）。</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ljd0620.github.io/tags/Java/"/>
    
    <category term="版本特性" scheme="https://ljd0620.github.io/tags/%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Go语言编程最佳实践</title>
    <link href="https://ljd0620.github.io/2025/03/19/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://ljd0620.github.io/2025/03/19/Go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-03-19T08:10:17.000Z</published>
    <updated>2025-03-25T08:57:42.045Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Go 语言进行开发时，遵循最佳实践可以帮助你编写高效、可维护和可靠的代码。以下是 Go 语言编程的一些最佳实践，涵盖了代码设计、性能优化、测试、并发等多个方面。</p><hr>        <h3 id="1-代码设计"   >          <a href="#1-代码设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-代码设计" class="headerlink" title="1. 代码设计"></a><strong>1. 代码设计</strong></h3>              <h4 id="1-1-单一职责原则"   >          <a href="#1-1-单一职责原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-1-单一职责原则" class="headerlink" title="1.1 单一职责原则"></a><strong>1.1 单一职责原则</strong></h4>      <p>• 每个包、函数或类型应该只负责一个功能。<br>• 避免让一个包承担过多的职责，保持功能的单一性。</p>        <h5 id="示例："   >          <a href="#示例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：一个包同时处理文件读写和网络请求</span></span><br><span class="line"><span class="keyword">package</span> fileutils</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendRequest</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：将功能拆分为多个包</span></span><br><span class="line"><span class="keyword">package</span> fileutils</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> httpclient</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SendRequest</span><span class="params">(url <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123; ... &#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="1-2-封装与抽象"   >          <a href="#1-2-封装与抽象" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-2-封装与抽象" class="headerlink" title="1.2 封装与抽象"></a><strong>1.2 封装与抽象</strong></h4>      <p>• 使用接口来定义行为，而不是直接依赖具体实现。<br>• 隐藏内部实现细节，提供清晰的公共接口。</p>        <h5 id="示例：-1"   >          <a href="#示例：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read() ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">type</span> FileReader <span class="keyword">struct</span> &#123;</span><br><span class="line">    Filename <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *FileReader)</span></span> Read() ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> os.ReadFile(r.Filename)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="1-3-使用有意义的命名"   >          <a href="#1-3-使用有意义的命名" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-3-使用有意义的命名" class="headerlink" title="1.3 使用有意义的命名"></a><strong>1.3 使用有意义的命名</strong></h4>      <p>• 包名、函数名、变量名应该清晰、简短且有意义。<br>• 导出名称（包外可见）以大写字母开头，未导出名称以小写字母开头。</p>        <h5 id="示例：-2"   >          <a href="#示例：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddNumbers</span><span class="params">(x, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; ... &#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="1-4-避免过度设计"   >          <a href="#1-4-避免过度设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-4-避免过度设计" class="headerlink" title="1.4 避免过度设计"></a><strong>1.4 避免过度设计</strong></h4>      <p>• 不要在项目初期过度设计，保持代码简单。<br>• 随着需求的变化逐步优化和扩展代码。</p><hr>        <h3 id="2-错误处理"   >          <a href="#2-错误处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a><strong>2. 错误处理</strong></h3>              <h4 id="2-1-显式处理错误"   >          <a href="#2-1-显式处理错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-显式处理错误" class="headerlink" title="2.1 显式处理错误"></a><strong>2.1 显式处理错误</strong></h4>      <p>• Go 语言中，错误是值，应该显式返回和处理。<br>• 不要忽略错误，始终检查并处理可能的错误。</p>        <h5 id="示例：-3"   >          <a href="#示例：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">data, _ := os.ReadFile(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">data, err := os.ReadFile(<span class="string">&quot;file.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalf(<span class="string">&quot;Failed to read file: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-2-自定义错误类型"   >          <a href="#2-2-自定义错误类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-自定义错误类型" class="headerlink" title="2.2 自定义错误类型"></a><strong>2.2 自定义错误类型</strong></h4>      <p>• 如果需要更详细的错误信息，可以定义自定义错误类型。<br>• 使用 <code>errors</code> 包或 <code>fmt.Errorf</code> 创建错误。</p>        <h5 id="示例：-4"   >          <a href="#示例：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Msg <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.Msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyError&#123;Msg: <span class="string">&quot;Something went wrong&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-3-使用-errors-Is-和-errors-As"   >          <a href="#2-3-使用-errors-Is-和-errors-As" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-使用-errors-Is-和-errors-As" class="headerlink" title="2.3 使用 errors.Is 和 errors.As"></a><strong>2.3 使用 <code>errors.Is</code> 和 <code>errors.As</code></strong></h4>      <p>• Go 1.13 引入了 <code>errors.Is</code> 和 <code>errors.As</code>，用于更优雅地处理错误链。</p>        <h5 id="示例：-5"   >          <a href="#示例：-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> errors.Is(err, os.ErrNotExist) &#123;</span><br><span class="line">    log.Println(<span class="string">&quot;File does not exist&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="3-并发编程"   >          <a href="#3-并发编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-并发编程" class="headerlink" title="3. 并发编程"></a><strong>3. 并发编程</strong></h3>              <h4 id="3-1-使用-Goroutine-和-Channel"   >          <a href="#3-1-使用-Goroutine-和-Channel" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-使用-Goroutine-和-Channel" class="headerlink" title="3.1 使用 Goroutine 和 Channel"></a><strong>3.1 使用 Goroutine 和 Channel</strong></h4>      <p>• Goroutine 是 Go 的轻量级线程，适合处理并发任务。<br>• 使用 Channel 在 Goroutine 之间传递数据，避免共享内存。</p>        <h5 id="示例：-6"   >          <a href="#示例：-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        results &lt;- job * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++ &#123;</span><br><span class="line">        &lt;-results</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="3-2-避免竞态条件"   >          <a href="#3-2-避免竞态条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-避免竞态条件" class="headerlink" title="3.2 避免竞态条件"></a><strong>3.2 避免竞态条件</strong></h4>      <p>• 使用 <code>sync.Mutex</code> 或 <code>sync.RWMutex</code> 来保护共享资源。<br>• 使用 <code>go run -race</code> 检测竞态条件。</p>        <h5 id="示例：-7"   >          <a href="#示例：-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"><span class="keyword">var</span> counter <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    counter++</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="3-3-使用-sync-WaitGroup"   >          <a href="#3-3-使用-sync-WaitGroup" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-使用-sync-WaitGroup" class="headerlink" title="3.3 使用 sync.WaitGroup"></a><strong>3.3 使用 <code>sync.WaitGroup</code></strong></h4>      <p>• 使用 <code>sync.WaitGroup</code> 等待一组 Goroutine 完成。</p>        <h5 id="示例：-8"   >          <a href="#示例：-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Worker %d is working\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="4-性能优化"   >          <a href="#4-性能优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a><strong>4. 性能优化</strong></h3>              <h4 id="4-1-避免不必要的内存分配"   >          <a href="#4-1-避免不必要的内存分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-避免不必要的内存分配" class="headerlink" title="4.1 避免不必要的内存分配"></a><strong>4.1 避免不必要的内存分配</strong></h4>      <p>• 使用值类型（如结构体）代替指针类型，减少堆内存分配。<br>• 预分配切片容量，避免动态扩容。</p>        <h5 id="示例：-9"   >          <a href="#示例：-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    slice = <span class="built_in">append</span>(slice, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    slice = <span class="built_in">append</span>(slice, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="4-2-使用-strings-Builder"   >          <a href="#4-2-使用-strings-Builder" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-使用-strings-Builder" class="headerlink" title="4.2 使用 strings.Builder"></a><strong>4.2 使用 <code>strings.Builder</code></strong></h4>      <p>• 在需要频繁拼接字符串时，使用 <code>strings.Builder</code> 替代 <code>+</code> 或 <code>fmt.Sprintf</code>。</p>        <h5 id="示例：-10"   >          <a href="#示例：-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> builder strings.Builder</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    builder.WriteString(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">result := builder.String()</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="4-3-避免过度优化"   >          <a href="#4-3-避免过度优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-3-避免过度优化" class="headerlink" title="4.3 避免过度优化"></a><strong>4.3 避免过度优化</strong></h4>      <p>• 在大多数情况下，代码的可读性和维护性比性能更重要。<br>• 只有在性能瓶颈明确时，才进行优化。</p><hr>        <h3 id="5-测试"   >          <a href="#5-测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-测试" class="headerlink" title="5. 测试"></a><strong>5. 测试</strong></h3>              <h4 id="5-1-编写单元测试"   >          <a href="#5-1-编写单元测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-1-编写单元测试" class="headerlink" title="5.1 编写单元测试"></a><strong>5.1 编写单元测试</strong></h4>      <p>• 使用 Go 的内置测试框架 <code>testing</code> 编写单元测试。<br>• 测试文件以 <code>_test.go</code> 结尾。</p>        <h5 id="示例：-11"   >          <a href="#示例：-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-11" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    result := Add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> result != <span class="number">5</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Expected 5, but got %d&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="5-2-基准测试"   >          <a href="#5-2-基准测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-2-基准测试" class="headerlink" title="5.2 基准测试"></a><strong>5.2 基准测试</strong></h4>      <p>• 使用 <code>Benchmark</code> 函数进行性能测试。</p>        <h5 id="示例：-12"   >          <a href="#示例：-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-12" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">        Add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="5-3-使用-Mock-和-Stub"   >          <a href="#5-3-使用-Mock-和-Stub" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-3-使用-Mock-和-Stub" class="headerlink" title="5.3 使用 Mock 和 Stub"></a><strong>5.3 使用 Mock 和 Stub</strong></h4>      <p>• 使用 Mock 或 Stub 模拟外部依赖，方便测试。</p>        <h5 id="示例：-13"   >          <a href="#示例：-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-13" class="headerlink" title="示例："></a>示例：</h5>      <p>可以使用第三方库（如 <code>gomock</code> 或 <code>testify</code>）来简化 Mock 的实现。</p><hr>        <h3 id="6-依赖管理"   >          <a href="#6-依赖管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-依赖管理" class="headerlink" title="6. 依赖管理"></a><strong>6. 依赖管理</strong></h3>              <h4 id="6-1-使用-Go-Modules"   >          <a href="#6-1-使用-Go-Modules" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-1-使用-Go-Modules" class="headerlink" title="6.1 使用 Go Modules"></a><strong>6.1 使用 Go Modules</strong></h4>      <p>• 从 Go 1.11 开始，Go 官方推荐使用 Go Modules 管理依赖。<br>• 在项目根目录运行 <code>go mod init</code> 初始化模块。</p>        <h5 id="示例：-14"   >          <a href="#示例：-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-14" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init github.com/yourname/yourproject</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="6-2-避免过度依赖"   >          <a href="#6-2-避免过度依赖" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-2-避免过度依赖" class="headerlink" title="6.2 避免过度依赖"></a><strong>6.2 避免过度依赖</strong></h4>      <p>• 尽量减少第三方依赖的使用，避免引入不必要的复杂性。<br>• 定期更新依赖，确保安全性。</p><hr>        <h3 id="7-代码风格"   >          <a href="#7-代码风格" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-代码风格" class="headerlink" title="7. 代码风格"></a><strong>7. 代码风格</strong></h3>              <h4 id="7-1-使用-gofmt-格式化代码"   >          <a href="#7-1-使用-gofmt-格式化代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-1-使用-gofmt-格式化代码" class="headerlink" title="7.1 使用 gofmt 格式化代码"></a><strong>7.1 使用 <code>gofmt</code> 格式化代码</strong></h4>      <p>• Go 语言有严格的代码格式规范，推荐使用 <code>gofmt</code> 工具自动格式化代码。</p>        <h5 id="示例：-15"   >          <a href="#示例：-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-15" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gofmt -w your_file.go</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="7-2-使用-golint-检查代码风格"   >          <a href="#7-2-使用-golint-检查代码风格" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-2-使用-golint-检查代码风格" class="headerlink" title="7.2 使用 golint 检查代码风格"></a><strong>7.2 使用 <code>golint</code> 检查代码风格</strong></h4>      <p>• 使用 <code>golint</code> 检查代码是否符合 Go 的编码规范。</p>        <h5 id="示例：-16"   >          <a href="#示例：-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-16" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golint your_file.go</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="7-3-使用-go-vet-检查潜在问题"   >          <a href="#7-3-使用-go-vet-检查潜在问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-3-使用-go-vet-检查潜在问题" class="headerlink" title="7.3 使用 go vet 检查潜在问题"></a><strong>7.3 使用 <code>go vet</code> 检查潜在问题</strong></h4>      <p>• 使用 <code>go vet</code> 检查代码中的潜在问题。</p>        <h5 id="示例：-17"   >          <a href="#示例：-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-17" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go vet ./...</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="8-文档与注释"   >          <a href="#8-文档与注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-文档与注释" class="headerlink" title="8. 文档与注释"></a><strong>8. 文档与注释</strong></h3>              <h4 id="8-1-包注释"   >          <a href="#8-1-包注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-1-包注释" class="headerlink" title="8.1 包注释"></a><strong>8.1 包注释</strong></h4>      <p>• 每个包都应该有一个包注释，通常是一个多行注释，描述包的功能。</p>        <h5 id="示例：-18"   >          <a href="#示例：-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-18" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package math provides basic mathematical functions.</span></span><br><span class="line"><span class="keyword">package</span> math</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="8-2-函数注释"   >          <a href="#8-2-函数注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-2-函数注释" class="headerlink" title="8.2 函数注释"></a><strong>8.2 函数注释</strong></h4>      <p>• 导出函数（包外可见）应该有注释，描述函数的功能、参数和返回值。</p>        <h5 id="示例：-19"   >          <a href="#示例：-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-19" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AddIntegers 返回两个整数的和。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddIntegers</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="8-3-行内注释"   >          <a href="#8-3-行内注释" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-3-行内注释" class="headerlink" title="8.3 行内注释"></a><strong>8.3 行内注释</strong></h4>      <p>• 行内注释用于解释复杂的代码逻辑，通常以 <code>//</code> 开头。<br>• 避免过度注释，代码本身应该尽量自解释。</p><hr>        <h3 id="9-工具链"   >          <a href="#9-工具链" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-工具链" class="headerlink" title="9. 工具链"></a><strong>9. 工具链</strong></h3>              <h4 id="9-1-使用-go-mod-管理依赖"   >          <a href="#9-1-使用-go-mod-管理依赖" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-1-使用-go-mod-管理依赖" class="headerlink" title="9.1 使用 go mod 管理依赖"></a><strong>9.1 使用 <code>go mod</code> 管理依赖</strong></h4>      <p>• 使用 <code>go mod tidy</code> 清理未使用的依赖。</p><hr>        <h4 id="9-2-使用静态分析工具"   >          <a href="#9-2-使用静态分析工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-2-使用静态分析工具" class="headerlink" title="9.2 使用静态分析工具"></a><strong>9.2 使用静态分析工具</strong></h4>      <p>• 使用 <code>golangci-lint</code> 等工具进行静态代码分析。</p>        <h5 id="示例：-20"   >          <a href="#示例：-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-20" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">golangci-lint run</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="9-3-使用-CI-CD-工具"   >          <a href="#9-3-使用-CI-CD-工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-3-使用-CI-CD-工具" class="headerlink" title="9.3 使用 CI&#x2F;CD 工具"></a><strong>9.3 使用 CI&#x2F;CD 工具</strong></h4>      <p>• 配置 CI&#x2F;CD 流水线，自动运行测试、格式化和静态分析。</p><hr>        <h3 id="10-其他最佳实践"   >          <a href="#10-其他最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-其他最佳实践" class="headerlink" title="10. 其他最佳实践"></a><strong>10. 其他最佳实践</strong></h3>              <h4 id="10-1-避免全局变量"   >          <a href="#10-1-避免全局变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-1-避免全局变量" class="headerlink" title="10.1 避免全局变量"></a><strong>10.1 避免全局变量</strong></h4>      <p>• 尽量减少全局变量的使用，避免引入不可控的状态。</p><hr>        <h4 id="10-2-使用切片代替数组"   >          <a href="#10-2-使用切片代替数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-2-使用切片代替数组" class="headerlink" title="10.2 使用切片代替数组"></a><strong>10.2 使用切片代替数组</strong></h4>      <p>• 切片比数组更灵活，适合大多数场景。</p>        <h5 id="示例：-21"   >          <a href="#示例：-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-21" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="10-3-使用-context-管理请求生命周期"   >          <a href="#10-3-使用-context-管理请求生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#10-3-使用-context-管理请求生命周期" class="headerlink" title="10.3 使用 context 管理请求生命周期"></a><strong>10.3 使用 <code>context</code> 管理请求生命周期</strong></h4>      <p>• 在处理 HTTP 请求或其他需要超时控制的场景中，使用 <code>context</code>。</p>        <h5 id="示例：-22"   >          <a href="#示例：-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-22" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">&quot;Request canceled&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;Request completed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Go 语言的最佳实践涵盖了代码设计、错误处理、并发、性能优化、测试、依赖管理等多个方面。以下是关键点：</p><ol><li><strong>简单性</strong>：保持代码简单，避免过度设计。</li><li><strong>可读性</strong>：遵循命名规范，添加必要的注释。</li><li><strong>并发安全</strong>：使用 Goroutine 和 Channel，避免竞态条件。</li><li><strong>性能优化</strong>：在必要时优化性能，但不要过早优化。</li><li><strong>测试覆盖</strong>：编写单元测试和基准测试，确保代码质量。</li><li><strong>工具支持</strong>：使用 Go 的工具链（如 <code>gofmt</code>、<code>go vet</code>、<code>golangci-lint</code>）提高开发效率。</li></ol><p>通过遵循这些最佳实践，你的 Go 代码将更加高效、可靠和易于维护！ 🚀</p>]]></content>
    
    
    <summary type="html">Go语言编程最佳实践</summary>
    
    
    
    <category term="Go" scheme="https://ljd0620.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://ljd0620.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言panic函数用法</title>
    <link href="https://ljd0620.github.io/2025/03/03/Go%E8%AF%AD%E8%A8%80panic%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/"/>
    <id>https://ljd0620.github.io/2025/03/03/Go%E8%AF%AD%E8%A8%80panic%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</id>
    <published>2025-03-03T08:09:09.000Z</published>
    <updated>2025-03-25T08:09:26.669Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中的<code>panic</code>用于表示程序遇到了无法继续执行的严重错误。以下是<code>panic</code>的使用方式、最佳实践以及与<code>recover</code>的结合用法：</p><hr>        <h3 id="一、Panic-基础用法"   >          <a href="#一、Panic-基础用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、Panic-基础用法" class="headerlink" title="一、Panic 基础用法"></a><strong>一、Panic 基础用法</strong></h3>              <h4 id="1-触发-Panic"   >          <a href="#1-触发-Panic" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-触发-Panic" class="headerlink" title="1. 触发 Panic"></a><strong>1. 触发 Panic</strong></h4>      <p>使用<code>panic</code>函数触发一个运行时错误：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">panic: something went wron</span><br><span class="line">    goroutine 1 [running]:</span><br><span class="line">    main.main()</span><br><span class="line">            /path/to/file.go:4 +0x27</span><br></pre></td></tr></table></div></figure>        <h4 id="2-Panic-的传播"   >          <a href="#2-Panic-的传播" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Panic-的传播" class="headerlink" title="2. Panic 的传播"></a><strong>2. Panic 的传播</strong></h4>      <p><code>panic</code>会沿着调用栈向上传播，直到被<code>recover</code>捕获或程序崩溃：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;error in foo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">panic: error in foo</span><br><span class="line">    goroutine 1 [running]:</span><br><span class="line">    main.foo()</span><br><span class="line">            /path/to/file.go:4 +0x27</span><br><span class="line">    main.bar()</span><br><span class="line">            /path/to/file.go:8 +0x14</span><br><span class="line">    main.main()</span><br><span class="line">            /path/to/file.go:12 +0x14</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="二、Recover-捕获-Panic"   >          <a href="#二、Recover-捕获-Panic" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、Recover-捕获-Panic" class="headerlink" title="二、Recover 捕获 Panic"></a><strong>二、Recover 捕获 Panic</strong></h3>              <h4 id="1-使用-Recover"   >          <a href="#1-使用-Recover" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用-Recover" class="headerlink" title="1. 使用 Recover"></a><strong>1. 使用 Recover</strong></h4>      <p><code>recover</code>用于捕获<code>panic</code>，防止程序崩溃。必须在<code>defer</code>函数中调用：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from panic:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Recovered from panic: something went wrong</span><br></pre></td></tr></table></div></figure>        <h4 id="2-Recover-的限制"   >          <a href="#2-Recover-的限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Recover-的限制" class="headerlink" title="2. Recover 的限制"></a><strong>2. Recover 的限制</strong></h4>      <ul><li><strong>仅在<code>defer</code>中有效</strong>：<code>recover</code>只能在<code>defer</code>函数中捕获<code>panic</code>。</li><li><strong>无法跨<code>goroutine</code></strong>：每个<code>goroutine</code>需要独立的<code>recover</code>。</li></ul><hr>        <h3 id="三、Panic-与-Recover-的最佳实践"   >          <a href="#三、Panic-与-Recover-的最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、Panic-与-Recover-的最佳实践" class="headerlink" title="三、Panic 与 Recover 的最佳实践"></a><strong>三、Panic 与 Recover 的最佳实践</strong></h3>              <h4 id="1-错误恢复"   >          <a href="#1-错误恢复" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-错误恢复" class="headerlink" title="1. 错误恢复"></a><strong>1. 错误恢复</strong></h4>      <p>在关键代码段中使用<code>recover</code>，确保程序在遇到错误时能够优雅恢复：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 可能触发panic的操作</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;unexpected error&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    safeCall()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Program continues&quot;</span>) <span class="comment">// 输出恢复后的日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-资源清理"   >          <a href="#2-资源清理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-资源清理" class="headerlink" title="2. 资源清理"></a><strong>2. 资源清理</strong></h4>      <p>在<code>defer</code>中结合<code>recover</code>确保资源释放：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">processFile</span><span class="params">(filename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from panic:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">        file.Close() <span class="comment">// 确保文件关闭</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理文件内容...</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;file processing error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-日志记录"   >          <a href="#3-日志记录" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-日志记录" class="headerlink" title="3. 日志记录"></a><strong>3. 日志记录</strong></h4>      <p>在<code>recover</code>中记录<code>panic</code>信息，便于排查问题：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Panic occurred: %v\nStack trace: %s&quot;</span>, r, debug.Stack())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;critical error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="四、Panic-的使用场景"   >          <a href="#四、Panic-的使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、Panic-的使用场景" class="headerlink" title="四、Panic 的使用场景"></a><strong>四、Panic 的使用场景</strong></h3>              <h4 id="1-不可恢复的错误"   >          <a href="#1-不可恢复的错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-不可恢复的错误" class="headerlink" title="1. 不可恢复的错误"></a><strong>1. 不可恢复的错误</strong></h4>      <ul><li><strong>示例</strong>：数据库连接失败、配置文件缺失。</li><li><strong>代码</strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := os.Stat(<span class="string">&quot;config.json&quot;</span>); os.IsNotExist(err) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;config file not found&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-断言失败"   >          <a href="#2-断言失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-断言失败" class="headerlink" title="2. 断言失败"></a><strong>2. 断言失败</strong></h4>      <ul><li><strong>示例</strong>：检查函数参数是否合法。</li><li><strong>代码</strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="3-程序初始化失败"   >          <a href="#3-程序初始化失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-程序初始化失败" class="headerlink" title="3. 程序初始化失败"></a><strong>3. 程序初始化失败</strong></h4>      <ul><li><strong>示例</strong>：初始化日志系统失败。</li><li><strong>代码</strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initLogger</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := log.Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;failed to initialize logger&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="五、Panic-的替代方案"   >          <a href="#五、Panic-的替代方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、Panic-的替代方案" class="headerlink" title="五、Panic 的替代方案"></a><strong>五、Panic 的替代方案</strong></h3>              <h4 id="1-返回错误"   >          <a href="#1-返回错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-返回错误" class="headerlink" title="1. 返回错误"></a><strong>1. 返回错误</strong></h4>      <p>在大多数情况下，优先使用返回错误的方式处理异常：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-自定义错误类型"   >          <a href="#2-自定义错误类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-自定义错误类型" class="headerlink" title="2. 自定义错误类型"></a><strong>2. 自定义错误类型</strong></h4>      <p>通过定义错误类型提供更多上下文信息：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConfigError <span class="keyword">struct</span> &#123;</span><br><span class="line">    File <span class="type">string</span></span><br><span class="line">    Err  <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *ConfigError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;config file %s: %v&quot;</span>, e.File, e.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := os.Stat(<span class="string">&quot;config.json&quot;</span>); os.IsNotExist(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;ConfigError&#123;File: <span class="string">&quot;config.json&quot;</span>, Err: err&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="六、Panic-的性能影响"   >          <a href="#六、Panic-的性能影响" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、Panic-的性能影响" class="headerlink" title="六、Panic 的性能影响"></a><strong>六、Panic 的性能影响</strong></h3>              <h4 id="1-性能开销"   >          <a href="#1-性能开销" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-性能开销" class="headerlink" title="1. 性能开销"></a><strong>1. 性能开销</strong></h4>      <ul><li><strong><code>panic</code></strong>：涉及栈展开和<code>defer</code>调用，性能开销较高。</li><li><strong><code>recover</code></strong>：捕获<code>panic</code>后恢复执行，开销较小。</li></ul>        <h4 id="2-性能优化建议"   >          <a href="#2-性能优化建议" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-性能优化建议" class="headerlink" title="2. 性能优化建议"></a><strong>2. 性能优化建议</strong></h4>      <ul><li><strong>避免滥用<code>panic</code></strong>：仅在无法恢复的错误中使用。</li><li><strong>减少<code>defer</code>调用</strong>：在性能敏感代码中避免不必要的<code>defer</code>。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <ul><li><strong>核心用途</strong>：处理不可恢复的错误，确保程序健壮性。</li><li><strong>最佳实践</strong>：<ul><li>在<code>defer</code>中使用<code>recover</code>捕获<code>panic</code>。</li><li>结合日志记录和资源清理。</li><li>优先使用返回错误的方式处理异常。</li></ul></li><li><strong>注意事项</strong>：<ul><li><code>panic</code>和<code>recover</code>不能跨<code>goroutine</code>。</li><li>避免在高频代码中使用<code>panic</code>。</li></ul></li></ul><p>通过合理使用<code>panic</code>和<code>recover</code>，可以构建更加健壮和可靠的Go程序。</p>]]></content>
    
    
    <summary type="html">Go语言panic函数用法</summary>
    
    
    
    <category term="Go" scheme="https://ljd0620.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://ljd0620.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言指针的作用详解</title>
    <link href="https://ljd0620.github.io/2025/02/27/Go%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ljd0620.github.io/2025/02/27/Go%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-02-27T08:08:16.000Z</published>
    <updated>2025-03-25T08:12:17.436Z</updated>
    
    <content type="html"><![CDATA[<p>在 Go 语言中，指针是一种非常重要的概念，它允许我们直接操作变量的内存地址。指针的使用可以带来许多好处，比如提高性能、实现数据共享、支持复杂的数据结构等。以下是指针的主要用途和优点。</p><hr>        <h3 id="1-指针的基本概念"   >          <a href="#1-指针的基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-指针的基本概念" class="headerlink" title="1. 指针的基本概念"></a><strong>1. 指针的基本概念</strong></h3>      <p>• <strong>指针</strong>是一个变量，它存储的是另一个变量的内存地址。<br>• 使用 <code>&amp;</code> 操作符可以获取变量的地址。<br>• 使用 <code>*</code> 操作符可以访问指针指向的值。</p>        <h4 id="示例："   >          <a href="#示例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">42</span>          <span class="comment">// 定义一个变量 x</span></span><br><span class="line">    p := &amp;x          <span class="comment">// p 是一个指针，存储 x 的地址</span></span><br><span class="line">    fmt.Println(*p)  <span class="comment">// 输出指针指向的值，即 x 的值：42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="2-指针的用处"   >          <a href="#2-指针的用处" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-指针的用处" class="headerlink" title="2. 指针的用处"></a><strong>2. 指针的用处</strong></h3>              <h4 id="2-1-修改函数外部的变量"   >          <a href="#2-1-修改函数外部的变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-1-修改函数外部的变量" class="headerlink" title="2.1 修改函数外部的变量"></a><strong>2.1 修改函数外部的变量</strong></h4>      <p>在 Go 中，函数参数是按值传递的，这意味着函数接收的是变量的副本。如果需要在函数中修改外部变量的值，可以使用指针。</p>        <h5 id="示例：-1"   >          <a href="#示例：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(x *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *x++ <span class="comment">// 通过指针修改外部变量的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    increment(&amp;a) <span class="comment">// 传递 a 的地址</span></span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-2-提高性能（避免大对象的拷贝）"   >          <a href="#2-2-提高性能（避免大对象的拷贝）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-2-提高性能（避免大对象的拷贝）" class="headerlink" title="2.2 提高性能（避免大对象的拷贝）"></a><strong>2.2 提高性能（避免大对象的拷贝）</strong></h4>      <p>当传递大对象（如结构体、数组等）时，按值传递会导致整个对象的拷贝，可能会影响性能。通过传递指针，可以避免这种拷贝。</p>        <h5 id="示例：-2"   >          <a href="#示例：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BigStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    data [<span class="number">1000000</span>]<span class="type">int</span> <span class="comment">// 假设这是一个非常大的结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(data *BigStruct)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 直接操作指针，避免拷贝</span></span><br><span class="line">    data.data[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    big := BigStruct&#123;&#125;</span><br><span class="line">    process(&amp;big) <span class="comment">// 传递指针</span></span><br><span class="line">    fmt.Println(big.data[<span class="number">0</span>]) <span class="comment">// 输出 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-3-实现数据共享"   >          <a href="#2-3-实现数据共享" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-3-实现数据共享" class="headerlink" title="2.3 实现数据共享"></a><strong>2.3 实现数据共享</strong></h4>      <p>指针可以用来在多个函数或变量之间共享数据。通过指针，多个地方可以访问和修改同一个变量。</p>        <h5 id="示例：-3"   >          <a href="#示例：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateValue</span><span class="params">(p *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *p = <span class="number">100</span> <span class="comment">// 修改指针指向的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    p := &amp;x</span><br><span class="line">    updateValue(p) <span class="comment">// 通过指针修改 x 的值</span></span><br><span class="line">    fmt.Println(x) <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-4-实现复杂的数据结构"   >          <a href="#2-4-实现复杂的数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-4-实现复杂的数据结构" class="headerlink" title="2.4 实现复杂的数据结构"></a><strong>2.4 实现复杂的数据结构</strong></h4>      <p>指针是实现链表、树、图等复杂数据结构的基础。通过指针，可以将多个节点连接起来。</p>        <h5 id="示例：链表"   >          <a href="#示例：链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：链表" class="headerlink" title="示例：链表"></a>示例：链表</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    next  *Node <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建链表节点</span></span><br><span class="line">    head := &amp;Node&#123;value: <span class="number">1</span>&#125;</span><br><span class="line">    second := &amp;Node&#123;value: <span class="number">2</span>&#125;</span><br><span class="line">    third := &amp;Node&#123;value: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接节点</span></span><br><span class="line">    head.next = second</span><br><span class="line">    second.next = third</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    current := head</span><br><span class="line">    <span class="keyword">for</span> current != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(current.value)</span><br><span class="line">        current = current.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-5-实现接口方法"   >          <a href="#2-5-实现接口方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-5-实现接口方法" class="headerlink" title="2.5 实现接口方法"></a><strong>2.5 实现接口方法</strong></h4>      <p>在 Go 中，如果一个方法需要修改接收者（receiver）的值，可以将接收者定义为指针类型。</p>        <h5 id="示例：-4"   >          <a href="#示例：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Counter <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针接收者，允许修改 Counter 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Counter)</span></span> Increment() &#123;</span><br><span class="line">    c.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := Counter&#123;value: <span class="number">0</span>&#125;</span><br><span class="line">    c.Increment()</span><br><span class="line">    fmt.Println(c.value) <span class="comment">// 输出 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-6-实现空值（nil）"   >          <a href="#2-6-实现空值（nil）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-6-实现空值（nil）" class="headerlink" title="2.6 实现空值（nil）"></a><strong>2.6 实现空值（nil）</strong></h4>      <p>指针可以为 <code>nil</code>，表示它没有指向任何值。这在某些场景下非常有用，比如初始化一个指针变量，或者在需要时表示“无”或“未设置”。</p>        <h5 id="示例：-5"   >          <a href="#示例：-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span> <span class="comment">// p 是一个指针，默认值为 nil</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Pointer is nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x := <span class="number">42</span></span><br><span class="line">    p = &amp;x <span class="comment">// 指向 x</span></span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Pointer is not nil, value:&quot;</span>, *p)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出：</p><figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pointer is nil</span><br><span class="line">Pointer is not nil, value: 42</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-7-实现函数返回多个值"   >          <a href="#2-7-实现函数返回多个值" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-7-实现函数返回多个值" class="headerlink" title="2.7 实现函数返回多个值"></a><strong>2.7 实现函数返回多个值</strong></h4>      <p>虽然 Go 不支持直接返回多个值，但可以通过指针间接实现类似的效果。</p>        <h5 id="示例：-6"   >          <a href="#示例：-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-6" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="type">int</span>, result *<span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;division by zero&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    *result = <span class="type">float64</span>(a) / <span class="type">float64</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> res <span class="type">float64</span></span><br><span class="line">    divide(<span class="number">10</span>, <span class="number">2</span>, &amp;res) <span class="comment">// 传递指针</span></span><br><span class="line">    fmt.Println(res)    <span class="comment">// 输出 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="3-指针的注意事项"   >          <a href="#3-指针的注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-指针的注意事项" class="headerlink" title="3. 指针的注意事项"></a><strong>3. 指针的注意事项</strong></h3>              <h4 id="3-1-避免空指针解引用"   >          <a href="#3-1-避免空指针解引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-避免空指针解引用" class="headerlink" title="3.1 避免空指针解引用"></a><strong>3.1 避免空指针解引用</strong></h4>      <p>如果指针为 <code>nil</code>，直接解引用会导致运行时错误（panic）。</p>        <h5 id="示例：-7"   >          <a href="#示例：-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-7" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">    fmt.Println(*p) <span class="comment">// 运行时错误：panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-2-避免循环引用"   >          <a href="#3-2-避免循环引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-避免循环引用" class="headerlink" title="3.2 避免循环引用"></a><strong>3.2 避免循环引用</strong></h4>      <p>在使用指针时，尤其是结构体中嵌套指针，可能会导致循环引用，进而引发内存泄漏。</p>        <h5 id="示例：-8"   >          <a href="#示例：-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-8" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := &amp;Node&#123;&#125;</span><br><span class="line">    b := &amp;Node&#123;next: a&#125;</span><br><span class="line">    a.next = b <span class="comment">// 循环引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><blockquote><p><strong>解决方法</strong>：使用 <code>weak references</code> 或手动断开引用（Go 没有直接的弱引用机制，但可以通过设计避免循环引用）。</p></blockquote>        <h4 id="3-3-指针的传递效率"   >          <a href="#3-3-指针的传递效率" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-指针的传递效率" class="headerlink" title="3.3 指针的传递效率"></a><strong>3.3 指针的传递效率</strong></h4>      <p>虽然指针可以避免大对象的拷贝，但频繁使用指针可能会增加内存访问的开销，尤其是在性能敏感的场景中。</p><hr>        <h3 id="4-指针的常见误区"   >          <a href="#4-指针的常见误区" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-指针的常见误区" class="headerlink" title="4. 指针的常见误区"></a><strong>4. 指针的常见误区</strong></h3>              <h4 id="4-1-指针和值传递的区别"   >          <a href="#4-1-指针和值传递的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-1-指针和值传递的区别" class="headerlink" title="4.1 指针和值传递的区别"></a><strong>4.1 指针和值传递的区别</strong></h4>      <p>• 值传递：传递的是变量的副本，函数内部对参数的修改不会影响外部变量。<br>• 指针传递：传递的是变量的地址，函数内部对参数的修改会影响外部变量。</p>        <h5 id="示例：-9"   >          <a href="#示例：-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-9" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyValue</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyPointer</span><span class="params">(p *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    *p = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">10</span></span><br><span class="line">    modifyValue(a) <span class="comment">// 修改副本，不影响外部变量</span></span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    modifyPointer(&amp;a) <span class="comment">// 修改指针指向的值</span></span><br><span class="line">    fmt.Println(a) <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="4-2-指针的解引用"   >          <a href="#4-2-指针的解引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-2-指针的解引用" class="headerlink" title="4.2 指针的解引用"></a><strong>4.2 指针的解引用</strong></h4>      <p>解引用操作（<code>*p</code>）是访问指针指向的值，而不是修改指针本身。</p>        <h5 id="示例：-10"   >          <a href="#示例：-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-10" class="headerlink" title="示例："></a>示例：</h5>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">42</span></span><br><span class="line">    p := &amp;x</span><br><span class="line">    *p = <span class="number">100</span> <span class="comment">// 修改 x 的值</span></span><br><span class="line">    fmt.Println(x) <span class="comment">// 输出 100</span></span><br><span class="line">    fmt.Println(*p) <span class="comment">// 输出 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="5-总结"   >          <a href="#5-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3>      <p>指针在 Go 中是一个非常强大的工具，合理使用指针可以带来以下好处：</p><ol><li><strong>修改外部变量</strong>：通过指针可以在函数中修改外部变量的值。</li><li><strong>提高性能</strong>：避免大对象的拷贝，节省内存和时间。</li><li><strong>实现数据共享</strong>：多个地方可以共享同一个变量。</li><li><strong>支持复杂数据结构</strong>：如链表、树、图等。</li><li><strong>实现接口方法</strong>：通过指针接收者可以修改接收者的值。</li><li><strong>支持空值</strong>：指针可以为 <code>nil</code>，表示“无”或“未设置”。</li></ol><p>但需要注意：<br>• 避免滥用指针，尤其是在性能敏感的场景中。<br>• 避免空指针解引用和循环引用。<br>• 指针的使用需要谨慎，确保代码的可读性和安全性。</p><p>通过合理使用指针，可以让 Go 程序更加高效和灵活！ 🚀</p>]]></content>
    
    
    <summary type="html">Go语言指针的作用详解</summary>
    
    
    
    <category term="Go" scheme="https://ljd0620.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://ljd0620.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言channel原理及用法</title>
    <link href="https://ljd0620.github.io/2025/02/19/Go%E8%AF%AD%E8%A8%80channel%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <id>https://ljd0620.github.io/2025/02/19/Go%E8%AF%AD%E8%A8%80channel%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E6%B3%95/</id>
    <published>2025-02-19T08:06:56.000Z</published>
    <updated>2025-03-19T08:07:52.375Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言的<code>channel</code>是其并发编程的核心组件之一，用于在<code>goroutine</code>之间安全地传递数据。以下是<code>channel</code>的原理、用法及最佳实践：</p><hr>        <h3 id="一、Channel-原理"   >          <a href="#一、Channel-原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、Channel-原理" class="headerlink" title="一、Channel 原理"></a><strong>一、Channel 原理</strong></h3>              <h4 id="1-数据结构"   >          <a href="#1-数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a><strong>1. 数据结构</strong></h4>      <ul><li><strong>底层实现</strong>：<code>channel</code>是一个环形队列（circular buffer），包含以下字段：<ul><li><code>buf</code>：存储数据的缓冲区（有缓冲<code>channel</code>）。</li><li><code>sendx</code>、<code>recvx</code>：发送和接收的索引。</li><li><code>lock</code>：互斥锁，保护<code>channel</code>的并发访问。</li><li><code>sendq</code>、<code>recvq</code>：等待发送和接收的<code>goroutine</code>队列。</li></ul></li></ul>        <h4 id="2-同步机制"   >          <a href="#2-同步机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-同步机制" class="headerlink" title="2. 同步机制"></a><strong>2. 同步机制</strong></h4>      <ul><li><strong>无缓冲<code>channel</code></strong>：发送和接收操作必须同时准备好，否则会阻塞。</li><li><strong>有缓冲<code>channel</code></strong>：缓冲区未满时发送不阻塞，缓冲区非空时接收不阻塞。</li></ul>        <h4 id="3-调度行为"   >          <a href="#3-调度行为" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-调度行为" class="headerlink" title="3. 调度行为"></a><strong>3. 调度行为</strong></h4>      <ul><li><strong>阻塞与唤醒</strong>：<ul><li>当<code>channel</code>操作阻塞时，<code>goroutine</code>会被放入等待队列。</li><li>当条件满足时（如缓冲区有空位或数据到达），<code>goroutine</code>会被唤醒。</li></ul></li></ul><hr>        <h3 id="二、Channel-基础用法"   >          <a href="#二、Channel-基础用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、Channel-基础用法" class="headerlink" title="二、Channel 基础用法"></a><strong>二、Channel 基础用法</strong></h3>              <h4 id="1-创建-Channel"   >          <a href="#1-创建-Channel" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-创建-Channel" class="headerlink" title="1. 创建 Channel"></a><strong>1. 创建 Channel</strong></h4>      <ul><li><strong>无缓冲<code>channel</code></strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></div></figure></li><li><strong>有缓冲<code>channel</code></strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 缓冲区大小为3</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-发送与接收"   >          <a href="#2-发送与接收" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-发送与接收" class="headerlink" title="2. 发送与接收"></a><strong>2. 发送与接收</strong></h4>      <ul><li><strong>发送数据</strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">42</span> <span class="comment">// 发送数据</span></span><br></pre></td></tr></table></div></figure></li><li><strong>接收数据</strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := &lt;-ch <span class="comment">// 接收数据</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="3-关闭-Channel"   >          <a href="#3-关闭-Channel" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-关闭-Channel" class="headerlink" title="3. 关闭 Channel"></a><strong>3. 关闭 Channel</strong></h4>      <ul><li><strong>关闭<code>channel</code></strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></div></figure></li><li><strong>检测关闭</strong>：<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Channel closed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="4-示例：生产者-消费者模型"   >          <a href="#4-示例：生产者-消费者模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-示例：生产者-消费者模型" class="headerlink" title="4. 示例：生产者-消费者模型"></a><strong>4. 示例：生产者-消费者模型</strong></h4>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> value := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received:&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> producer(ch)</span><br><span class="line">    consumer(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="三、Channel-高级用法"   >          <a href="#三、Channel-高级用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、Channel-高级用法" class="headerlink" title="三、Channel 高级用法"></a><strong>三、Channel 高级用法</strong></h3>              <h4 id="1-Select-多路复用"   >          <a href="#1-Select-多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Select-多路复用" class="headerlink" title="1. Select 多路复用"></a><strong>1. Select 多路复用</strong></h4>      <p>监听多个<code>channel</code>操作：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch1 &lt;- <span class="string">&quot;from ch1&quot;</span> &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch2 &lt;- <span class="string">&quot;from ch2&quot;</span> &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg := &lt;-ch1:</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    <span class="keyword">case</span> msg := &lt;-ch2:</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 超时控制</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-单向-Channel"   >          <a href="#2-单向-Channel" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-单向-Channel" class="headerlink" title="2. 单向 Channel"></a><strong>2. 单向 Channel</strong></h4>      <p>限制<code>channel</code>的发送或接收方向：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        ch &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> value := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received:&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-带缓冲-Channel-的容量与长度"   >          <a href="#3-带缓冲-Channel-的容量与长度" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-带缓冲-Channel-的容量与长度" class="headerlink" title="3. 带缓冲 Channel 的容量与长度"></a><strong>3. 带缓冲 Channel 的容量与长度</strong></h4>      <ul><li><strong>容量</strong>：<code>cap(ch)</code>返回<code>channel</code>的缓冲区大小。</li><li><strong>长度</strong>：<code>len(ch)</code>返回当前缓冲区中的数据量。</li></ul><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Capacity:&quot;</span>, <span class="built_in">cap</span>(ch)) <span class="comment">// 输出 3</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Length:&quot;</span>, <span class="built_in">len</span>(ch))   <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="四、Channel-最佳实践"   >          <a href="#四、Channel-最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、Channel-最佳实践" class="headerlink" title="四、Channel 最佳实践"></a><strong>四、Channel 最佳实践</strong></h3>              <h4 id="1-避免死锁"   >          <a href="#1-避免死锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-避免死锁" class="headerlink" title="1. 避免死锁"></a><strong>1. 避免死锁</strong></h4>      <ul><li><strong>无缓冲<code>channel</code></strong>：确保发送和接收操作成对出现。</li><li><strong>有缓冲<code>channel</code></strong>：避免缓冲区满时发送或空时接收。</li></ul>        <h4 id="2-使用select实现超时控制"   >          <a href="#2-使用select实现超时控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用select实现超时控制" class="headerlink" title="2. 使用select实现超时控制"></a><strong>2. 使用<code>select</code>实现超时控制</strong></h4>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        ch &lt;- <span class="string">&quot;result&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-ch:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 超时控制</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-使用close通知结束"   >          <a href="#3-使用close通知结束" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-使用close通知结束" class="headerlink" title="3. 使用close通知结束"></a><strong>3. 使用<code>close</code>通知结束</strong></h4>      <p>通过关闭<code>channel</code>通知接收方任务完成：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> worker(done)</span><br><span class="line">    &lt;-done <span class="comment">// 等待任务完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="4-限制并发数量"   >          <a href="#4-限制并发数量" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-限制并发数量" class="headerlink" title="4. 限制并发数量"></a><strong>4. 限制并发数量</strong></h4>      <p>使用带缓冲的<code>channel</code>实现信号量：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> maxGoroutines = <span class="number">3</span></span><br><span class="line">    sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, maxGoroutines)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 占用信号量</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem &#125;() <span class="comment">// 释放信号量</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Goroutine %d running\n&quot;</span>, id)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxGoroutines; i++ &#123;</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 等待所有goroutine完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="五、Channel-性能优化"   >          <a href="#五、Channel-性能优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、Channel-性能优化" class="headerlink" title="五、Channel 性能优化"></a><strong>五、Channel 性能优化</strong></h3>              <h4 id="1-减少锁竞争"   >          <a href="#1-减少锁竞争" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-减少锁竞争" class="headerlink" title="1. 减少锁竞争"></a><strong>1. 减少锁竞争</strong></h4>      <ul><li>使用多个小<code>channel</code>代替单个大<code>channel</code>。</li><li>避免在高频操作中使用无缓冲<code>channel</code>。</li></ul>        <h4 id="2-批量处理"   >          <a href="#2-批量处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-批量处理" class="headerlink" title="2. 批量处理"></a><strong>2. 批量处理</strong></h4>      <p>合并小任务，减少<code>channel</code>操作次数：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        batch := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">            batch = <span class="built_in">append</span>(batch, i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(batch) == <span class="number">10</span> &#123;</span><br><span class="line">                ch &lt;- batch</span><br><span class="line">                batch = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Received batch:&quot;</span>, batch)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-使用sync-Pool复用对象"   >          <a href="#3-使用sync-Pool复用对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-使用sync-Pool复用对象" class="headerlink" title="3. 使用sync.Pool复用对象"></a><strong>3. 使用<code>sync.Pool</code>复用对象</strong></h4>      <p>减少内存分配开销：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="type">byte</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        buf := pool.Get().([]<span class="type">byte</span>)</span><br><span class="line">        <span class="keyword">defer</span> pool.Put(buf)</span><br><span class="line">        <span class="comment">// 使用buf处理数据...</span></span><br><span class="line">        ch &lt;- buf</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="六、Channel-调试与监控"   >          <a href="#六、Channel-调试与监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、Channel-调试与监控" class="headerlink" title="六、Channel 调试与监控"></a><strong>六、Channel 调试与监控</strong></h3>              <h4 id="1-调试工具"   >          <a href="#1-调试工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-调试工具" class="headerlink" title="1. 调试工具"></a><strong>1. 调试工具</strong></h4>      <ul><li><strong>pprof</strong>：分析<code>channel</code>的阻塞情况。<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></div></figure>访问<code>http://localhost:6060/debug/pprof/goroutine?debug=1</code>查看<code>goroutine</code>状态。</li></ul>        <h4 id="2-监控指标"   >          <a href="#2-监控指标" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-监控指标" class="headerlink" title="2. 监控指标"></a><strong>2. 监控指标</strong></h4>      <ul><li><strong>runtime.NumGoroutine()</strong>：获取当前<code>goroutine</code>数量。</li><li><strong>runtime.ReadMemStats()</strong>：监控内存使用。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <ul><li><strong>核心用途</strong>：<code>goroutine</code>间通信与同步。</li><li><strong>关键特性</strong>：<ul><li>无缓冲<code>channel</code>用于强同步。</li><li>有缓冲<code>channel</code>用于解耦生产者和消费者。</li></ul></li><li><strong>最佳实践</strong>：<ul><li>使用<code>select</code>实现超时和多路复用。</li><li>通过<code>close</code>通知任务完成。</li><li>合理控制并发数量，避免资源泄漏。</li></ul></li></ul><p>通过合理使用<code>channel</code>，可以构建高效、安全的并发程序。</p>]]></content>
    
    
    <summary type="html">Go语言channel原理及用法</summary>
    
    
    
    <category term="Go" scheme="https://ljd0620.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://ljd0620.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言goroutine原理及用法</title>
    <link href="https://ljd0620.github.io/2025/02/10/Go%E8%AF%AD%E8%A8%80goroutine%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <id>https://ljd0620.github.io/2025/02/10/Go%E8%AF%AD%E8%A8%80goroutine%E5%8E%9F%E7%90%86%E5%8F%8A%E7%94%A8%E6%B3%95/</id>
    <published>2025-02-10T04:06:14.000Z</published>
    <updated>2025-03-19T08:07:07.067Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言的<code>goroutine</code>是其并发编程的核心特性，它是一种轻量级的线程，由Go运行时（runtime）管理。以下是<code>goroutine</code>的原理、用法及最佳实践：</p><hr>        <h3 id="一、Goroutine-原理"   >          <a href="#一、Goroutine-原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、Goroutine-原理" class="headerlink" title="一、Goroutine 原理"></a><strong>一、Goroutine 原理</strong></h3>              <h4 id="1-轻量级线程"   >          <a href="#1-轻量级线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-轻量级线程" class="headerlink" title="1. 轻量级线程"></a><strong>1. 轻量级线程</strong></h4>      <ul><li><strong>资源占用</strong>：每个<code>goroutine</code>初始栈大小仅2KB（可动态扩展），远小于线程的MB级栈。</li><li><strong>调度机制</strong>：由Go运行时调度器（Scheduler）管理，基于M:N模型（M个<code>goroutine</code>映射到N个OS线程）。</li><li><strong>协作式调度</strong>：通过<code>GOMAXPROCS</code>控制并行度，默认值为CPU核心数。</li></ul>        <h4 id="2-调度模型"   >          <a href="#2-调度模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-调度模型" class="headerlink" title="2. 调度模型"></a><strong>2. 调度模型</strong></h4>      <ul><li><strong>G-M-P 模型</strong>：<ul><li><strong>G（Goroutine）</strong>：执行单元。</li><li><strong>M（Machine）</strong>：OS线程。</li><li><strong>P（Processor）</strong>：逻辑处理器，绑定M和G。</li></ul></li><li><strong>工作窃取（Work Stealing）</strong>：空闲P从其他P的队列中偷取G执行。</li></ul>        <h4 id="3-上下文切换"   >          <a href="#3-上下文切换" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-上下文切换" class="headerlink" title="3. 上下文切换"></a><strong>3. 上下文切换</strong></h4>      <ul><li><strong>用户态切换</strong>：<code>goroutine</code>切换由Go运行时管理，无需进入内核态，开销极低（约100ns）。</li><li><strong>触发时机</strong>：<ul><li>系统调用（如文件I&#x2F;O）</li><li>通道操作（<code>channel</code>）</li><li>显式调用<code>runtime.Gosched()</code></li></ul></li></ul><hr>        <h3 id="二、Goroutine-基础用法"   >          <a href="#二、Goroutine-基础用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、Goroutine-基础用法" class="headerlink" title="二、Goroutine 基础用法"></a><strong>二、Goroutine 基础用法</strong></h3>              <h4 id="1-启动-Goroutine"   >          <a href="#1-启动-Goroutine" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-启动-Goroutine" class="headerlink" title="1. 启动 Goroutine"></a><strong>1. 启动 Goroutine</strong></h4>      <p>使用<code>go</code>关键字启动一个<code>goroutine</code>：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello from goroutine!&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Millisecond) <span class="comment">// 等待goroutine执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-传递参数"   >          <a href="#2-传递参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-传递参数" class="headerlink" title="2. 传递参数"></a><strong>2. 传递参数</strong></h4>      <p>通过闭包或函数参数传递数据：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMessage</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    msg := <span class="string">&quot;Hello, Go!&quot;</span></span><br><span class="line">    <span class="keyword">go</span> printMessage(msg) <span class="comment">// 通过参数传递</span></span><br><span class="line">    time.Sleep(time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-等待-Goroutine-完成"   >          <a href="#3-等待-Goroutine-完成" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-等待-Goroutine-完成" class="headerlink" title="3. 等待 Goroutine 完成"></a><strong>3. 等待 Goroutine 完成</strong></h4>      <p>使用<code>sync.WaitGroup</code>同步多个<code>goroutine</code>：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Printf(<span class="string">&quot;Goroutine %d done\n&quot;</span>, id)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有goroutine完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;All goroutines finished&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="三、Goroutine-高级用法"   >          <a href="#三、Goroutine-高级用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、Goroutine-高级用法" class="headerlink" title="三、Goroutine 高级用法"></a><strong>三、Goroutine 高级用法</strong></h3>              <h4 id="1-通道（Channel）通信"   >          <a href="#1-通道（Channel）通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-通道（Channel）通信" class="headerlink" title="1. 通道（Channel）通信"></a><strong>1. 通道（Channel）通信</strong></h4>      <ul><li><strong>无缓冲通道</strong>：同步通信，发送和接收必须同时准备好。<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        ch &lt;- <span class="number">42</span> <span class="comment">// 发送数据</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&lt;-ch) <span class="comment">// 接收数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><strong>缓冲通道</strong>：异步通信，缓冲区满时发送阻塞。<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    ch &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-ch, &lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-Select-多路复用"   >          <a href="#2-Select-多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Select-多路复用" class="headerlink" title="2. Select 多路复用"></a><strong>2. Select 多路复用</strong></h4>      <p>监听多个通道操作：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch1 &lt;- <span class="string">&quot;from ch1&quot;</span> &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch2 &lt;- <span class="string">&quot;from ch2&quot;</span> &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> msg := &lt;-ch1:</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    <span class="keyword">case</span> msg := &lt;-ch2:</span><br><span class="line">        fmt.Println(msg)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second): <span class="comment">// 超时控制</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-上下文（Context）控制"   >          <a href="#3-上下文（Context）控制" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-上下文（Context）控制" class="headerlink" title="3. 上下文（Context）控制"></a><strong>3. 上下文（Context）控制</strong></h4>      <p>用于取消<code>goroutine</code>或传递超时：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">&quot;cancelled&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">        fmt.Println(<span class="string">&quot;work done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">500</span>*time.Millisecond)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    <span class="keyword">go</span> worker(ctx)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="四、Goroutine-最佳实践"   >          <a href="#四、Goroutine-最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、Goroutine-最佳实践" class="headerlink" title="四、Goroutine 最佳实践"></a><strong>四、Goroutine 最佳实践</strong></h3>              <h4 id="1-控制并发数量"   >          <a href="#1-控制并发数量" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-控制并发数量" class="headerlink" title="1. 控制并发数量"></a><strong>1. 控制并发数量</strong></h4>      <p>使用带缓冲的通道或<code>semaphore</code>限制并发：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> maxGoroutines = <span class="number">3</span></span><br><span class="line">    sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, maxGoroutines)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 占用信号量</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem &#125;() <span class="comment">// 释放信号量</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Goroutine %d running\n&quot;</span>, id)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxGoroutines; i++ &#123;</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 等待所有goroutine完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-避免-Goroutine-泄漏"   >          <a href="#2-避免-Goroutine-泄漏" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-避免-Goroutine-泄漏" class="headerlink" title="2. 避免 Goroutine 泄漏"></a><strong>2. 避免 Goroutine 泄漏</strong></h4>      <p>确保<code>goroutine</code>在不再需要时退出：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 执行任务...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    <span class="built_in">close</span>(done) <span class="comment">// 通知goroutine退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-性能优化"   >          <a href="#3-性能优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a><strong>3. 性能优化</strong></h4>      <ul><li><strong>减少锁竞争</strong>：使用<code>sync.Pool</code>复用对象。</li><li><strong>批量处理</strong>：合并小任务，减少<code>goroutine</code>切换开销。</li><li><strong>避免阻塞</strong>：使用非阻塞I&#x2F;O或异步操作。</li></ul><hr>        <h3 id="五、Goroutine-调试与监控"   >          <a href="#五、Goroutine-调试与监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、Goroutine-调试与监控" class="headerlink" title="五、Goroutine 调试与监控"></a><strong>五、Goroutine 调试与监控</strong></h3>              <h4 id="1-调试工具"   >          <a href="#1-调试工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-调试工具" class="headerlink" title="1. 调试工具"></a><strong>1. 调试工具</strong></h4>      <ul><li><strong>pprof</strong>：分析<code>goroutine</code>堆栈和CPU使用。<figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    log.Println(http.ListenAndServe(<span class="string">&quot;localhost:6060&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></div></figure>访问<code>http://localhost:6060/debug/pprof/goroutine?debug=1</code>查看<code>goroutine</code>状态。</li></ul>        <h4 id="2-监控指标"   >          <a href="#2-监控指标" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-监控指标" class="headerlink" title="2. 监控指标"></a><strong>2. 监控指标</strong></h4>      <ul><li><strong>runtime.NumGoroutine()</strong>：获取当前<code>goroutine</code>数量。</li><li><strong>runtime.ReadMemStats()</strong>：监控内存使用。</li></ul><hr>        <h3 id="六、Goroutine-与线程对比"   >          <a href="#六、Goroutine-与线程对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、Goroutine-与线程对比" class="headerlink" title="六、Goroutine 与线程对比"></a><strong>六、Goroutine 与线程对比</strong></h3>      <div class="table-container"><table><thead><tr><th>特性</th><th>Goroutine</th><th>OS 线程</th></tr></thead><tbody><tr><td><strong>创建开销</strong></td><td>2KB栈，约0.3μs</td><td>MB级栈，约10μs</td></tr><tr><td><strong>上下文切换</strong></td><td>用户态，约100ns</td><td>内核态，约1μs</td></tr><tr><td><strong>调度方式</strong></td><td>协作式（Go运行时）</td><td>抢占式（OS内核）</td></tr><tr><td><strong>并行度</strong></td><td>受<code>GOMAXPROCS</code>限制</td><td>受CPU核心数限制</td></tr></tbody></table></div><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <ul><li><strong>核心优势</strong>：轻量、高效、易用。</li><li><strong>适用场景</strong>：高并发服务、异步任务处理、并行计算。</li><li><strong>注意事项</strong>：<ul><li>避免<code>goroutine</code>泄漏。</li><li>合理控制并发数量。</li><li>使用通道和<code>context</code>实现同步与取消。</li></ul></li></ul><p>通过合理使用<code>goroutine</code>，可以轻松构建高性能、高并发的Go程序。</p>]]></content>
    
    
    <summary type="html">Go语言goroutine原理及用法</summary>
    
    
    
    <category term="Go" scheme="https://ljd0620.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://ljd0620.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言defer关键字用法</title>
    <link href="https://ljd0620.github.io/2025/02/01/Go%E8%AF%AD%E8%A8%80defer%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/"/>
    <id>https://ljd0620.github.io/2025/02/01/Go%E8%AF%AD%E8%A8%80defer%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95/</id>
    <published>2025-02-01T08:04:31.000Z</published>
    <updated>2025-03-19T08:07:25.170Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言中的<code>defer</code>关键字用于延迟执行函数调用，通常用于资源管理（如关闭文件、解锁互斥锁）或确保某些操作在函数返回前执行。以下是<code>defer</code>的详细用法及注意事项：</p><hr>        <h3 id="1-基础用法"   >          <a href="#1-基础用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a><strong>1. 基础用法</strong></h3>      <p><strong>语法</strong>：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> functionCall()</span><br></pre></td></tr></table></div></figure><p><strong>特点</strong>：</p><ul><li><code>defer</code>后的函数会在外层函数返回前执行。</li><li>多个<code>defer</code>按**后进先出（LIFO）**顺序执行。</li></ul><p><strong>示例</strong>：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;First defer&quot;</span>)  <span class="comment">// 第三个执行</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Second defer&quot;</span>) <span class="comment">// 第二个执行</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Third defer&quot;</span>)  <span class="comment">// 第一个执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Third defer</span></span><br><span class="line"><span class="comment">// Second defer</span></span><br><span class="line"><span class="comment">// First defer</span></span><br></pre></td></tr></table></div></figure><hr>        <h3 id="2-参数求值时机"   >          <a href="#2-参数求值时机" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-参数求值时机" class="headerlink" title="2. 参数求值时机"></a><strong>2. 参数求值时机</strong></h3>      <p><code>defer</code>的参数在声明时立即求值，而非执行时：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;Defer x:&quot;</span>, x) <span class="comment">// x=10 被立即捕获</span></span><br><span class="line">    x = <span class="number">20</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Current x:&quot;</span>, x)     <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Current x: 20</span></span><br><span class="line"><span class="comment">// Defer x: 10</span></span><br></pre></td></tr></table></div></figure><hr>        <h3 id="3-修改返回值"   >          <a href="#3-修改返回值" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-修改返回值" class="headerlink" title="3. 修改返回值"></a><strong>3. 修改返回值</strong></h3>      <p>若函数使用<strong>命名返回值</strong>，<code>defer</code>可以修改返回值：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedReturn</span><span class="params">()</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result++ &#125;() <span class="comment">// 修改命名返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>                    <span class="comment">// 实际返回 5+1=6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unnamedReturn</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    result := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result++ &#125;() <span class="comment">// 不影响非命名返回值</span></span><br><span class="line">    <span class="keyword">return</span> result               <span class="comment">// 返回 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(namedReturn())   <span class="comment">// 输出 6</span></span><br><span class="line">    fmt.Println(unnamedReturn()) <span class="comment">// 输出 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="4-错误处理与资源释放"   >          <a href="#4-错误处理与资源释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-错误处理与资源释放" class="headerlink" title="4. 错误处理与资源释放"></a><strong>4. 错误处理与资源释放</strong></h3>              <h4 id="（1）文件操作"   >          <a href="#（1）文件操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#（1）文件操作" class="headerlink" title="（1）文件操作"></a><strong>（1）文件操作</strong></h4>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close() <span class="comment">// 确保文件关闭</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理文件内容...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="（2）互斥锁"   >          <a href="#（2）互斥锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#（2）互斥锁" class="headerlink" title="（2）互斥锁"></a><strong>（2）互斥锁</strong></h4>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock() <span class="comment">// 确保锁释放</span></span><br><span class="line">    <span class="comment">// 操作共享数据...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="（3）错误传递"   >          <a href="#（3）错误传递" class="heading-link"><i class="fas fa-link"></i></a><a href="#（3）错误传递" class="headerlink" title="（3）错误传递"></a><strong>（3）错误传递</strong></h4>      <figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">&quot;data.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> closeErr := file.Close(); closeErr != <span class="literal">nil</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">            err = closeErr <span class="comment">// 捕获关闭错误</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理文件...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="5-结合闭包与匿名函数"   >          <a href="#5-结合闭包与匿名函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-结合闭包与匿名函数" class="headerlink" title="5. 结合闭包与匿名函数"></a><strong>5. 结合闭包与匿名函数</strong></h3>      <p>在循环中使用<code>defer</code>时，需注意资源释放的时机：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：defer在循环结束后统一执行</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    file, _ := os.Open(fmt.Sprintf(<span class="string">&quot;file%d.txt&quot;</span>, i))</span><br><span class="line">    <span class="keyword">defer</span> file.Close() <span class="comment">// 所有文件在循环结束后关闭！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例：使用匿名函数立即释放资源</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        file, _ := os.Open(fmt.Sprintf(<span class="string">&quot;file%d.txt&quot;</span>, i))</span><br><span class="line">        <span class="keyword">defer</span> file.Close() <span class="comment">// 每次循环结束时关闭文件</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="6-与recover-结合处理-panic"   >          <a href="#6-与recover-结合处理-panic" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-与recover-结合处理-panic" class="headerlink" title="6. 与recover()结合处理 panic"></a><strong>6. 与<code>recover()</code>结合处理 panic</strong></h3>      <p><code>defer</code>常用于恢复<code>panic</code>，防止程序崩溃：</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeCall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from panic:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 可能触发panic的操作</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;something went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    safeCall()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Program continues&quot;</span>) <span class="comment">// 输出恢复后的日志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="7-性能注意事项"   >          <a href="#7-性能注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-性能注意事项" class="headerlink" title="7. 性能注意事项"></a><strong>7. 性能注意事项</strong></h3>      <ul><li><strong>延迟开销</strong>：<code>defer</code>会引入少量性能开销（约纳秒级），在性能敏感代码中（如高频循环）需谨慎使用。</li><li><strong>替代方案</strong>：在极端性能场景中，可手动管理资源释放（如直接调用<code>file.Close()</code>）。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <ul><li><strong>核心用途</strong>：资源清理、错误恢复、代码逻辑简化。</li><li><strong>关键规则</strong>：<ul><li>参数立即求值，执行顺序为LIFO。</li><li>可修改命名返回值，但非命名返回值不受影响。</li></ul></li><li><strong>最佳实践</strong>：<ul><li>在打开资源后立即使用<code>defer</code>关闭。</li><li>结合闭包处理循环中的资源释放。</li><li>使用<code>defer + recover()</code>增强程序健壮性。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">Go语言defer关键字用法</summary>
    
    
    
    <category term="Go" scheme="https://ljd0620.github.io/categories/Go/"/>
    
    
    <category term="Go" scheme="https://ljd0620.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Kafka工作原理详解</title>
    <link href="https://ljd0620.github.io/2024/07/18/Kafka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ljd0620.github.io/2024/07/18/Kafka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-07-18T04:23:44.000Z</published>
    <updated>2025-03-19T01:59:27.540Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Kafka 是一个分布式流处理平台，专为高吞吐、低延迟的实时数据传输设计。以下是其核心工作原理的分层解析：</p><hr>        <h3 id="一、核心架构组件"   >          <a href="#一、核心架构组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、核心架构组件" class="headerlink" title="一、核心架构组件"></a>一、核心架构组件</h3>              <h4 id="1-Broker（代理节点）"   >          <a href="#1-Broker（代理节点）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Broker（代理节点）" class="headerlink" title="1. Broker（代理节点）"></a>1. <strong>Broker（代理节点）</strong></h4>      <p>• <strong>角色</strong>：Kafka 集群中的单台服务器，负责数据存储和消息传递。<br>• <strong>集群模式</strong>：多个 Broker 组成集群，每个 Broker 通过唯一 ID 标识，支持动态扩容。<br>• <strong>数据存储</strong>：每个 Broker 存储多个 <strong>Topic（主题）</strong> 的分区（Partition）副本。</p>        <h4 id="2-Topic（主题）"   >          <a href="#2-Topic（主题）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Topic（主题）" class="headerlink" title="2. Topic（主题）"></a>2. <strong>Topic（主题）</strong></h4>      <p>• <strong>逻辑分类</strong>：消息的类别标识（如 <code>user_click</code>、<code>payment_log</code>）。<br>• <strong>物理分片</strong>：每个 Topic 划分为多个 <strong>Partition（分区）</strong>，数据按分区存储，实现并行处理。<br>◦ <strong>分区特性</strong>：<br>◦ 每个分区是一个 <strong>有序、不可变</strong> 的消息序列。<br>◦ 消息通过 <strong>Offset（偏移量）</strong> 唯一标识，类似数组下标。</p>        <h4 id="3-Producer（生产者）"   >          <a href="#3-Producer（生产者）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Producer（生产者）" class="headerlink" title="3. Producer（生产者）"></a>3. <strong>Producer（生产者）</strong></h4>      <p>• <strong>功能</strong>：向 Topic 发送消息。<br>• <strong>路由策略</strong>：<br>◦ <strong>Key 哈希</strong>：若消息指定 Key，按 Key 哈希值分配到特定分区，保证相同 Key 的消息进入同一分区。<br>◦ <strong>轮询分配</strong>：无 Key 时轮询选择分区，实现负载均衡。</p>        <h4 id="4-Consumer（消费者）"   >          <a href="#4-Consumer（消费者）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Consumer（消费者）" class="headerlink" title="4. Consumer（消费者）"></a>4. <strong>Consumer（消费者）</strong></h4>      <p>• <strong>功能</strong>：从 Topic 拉取消息进行处理。<br>• <strong>消费者组（Consumer Group）</strong>：<br>◦ 组内消费者共享消费任务，每个分区只能由组内一个消费者消费。<br>◦ 横向扩展：增加消费者数量可提升消费并行度。</p>        <h4 id="5-Zookeeper-KRaft（集群管理）"   >          <a href="#5-Zookeeper-KRaft（集群管理）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Zookeeper-KRaft（集群管理）" class="headerlink" title="5. Zookeeper&#x2F;KRaft（集群管理）"></a>5. <strong>Zookeeper&#x2F;KRaft（集群管理）</strong></h4>      <p>• <strong>传统模式</strong>：依赖 Zookeeper 管理 Broker 元数据、Leader 选举、消费者 Offset。<br>• <strong>KRaft 模式</strong>（Kafka 2.8+）：去 Zookeeper 依赖，通过 Raft 协议实现集群元数据自管理。</p><hr>        <h3 id="二、数据写入流程（生产者视角）"   >          <a href="#二、数据写入流程（生产者视角）" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、数据写入流程（生产者视角）" class="headerlink" title="二、数据写入流程（生产者视角）"></a>二、数据写入流程（生产者视角）</h3>              <h4 id="1-消息发送"   >          <a href="#1-消息发送" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-消息发送" class="headerlink" title="1. 消息发送"></a>1. <strong>消息发送</strong></h4>      <p>• <strong>序列化</strong>：生产者将消息序列化为字节数组（支持 Avro、JSON 等格式）。<br>• <strong>分区选择</strong>：根据 Key 或轮询策略选择目标分区。<br>• <strong>批次压缩</strong>：消息按批次（Batch）压缩后发送（支持 LZ4、Snappy、GZIP）。</p>        <h4 id="2-Broker-处理"   >          <a href="#2-Broker-处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Broker-处理" class="headerlink" title="2. Broker 处理"></a>2. <strong>Broker 处理</strong></h4>      <p>• <strong>写入 Leader 分区</strong>：消息首先写入分区的 Leader Broker。<br>• <strong>副本同步</strong>：Follower 副本异步&#x2F;同步（<code>acks=all</code>）从 Leader 拉取数据。<br>• <strong>持久化存储</strong>：<br>◦ <strong>顺序写入磁盘</strong>：利用磁盘顺序 I&#x2F;O 的高性能特性。<br>◦ <strong>页缓存优化</strong>：通过 OS 页缓存加速读写，而非直接写磁盘。</p>        <h4 id="3-ACK-确认机制"   >          <a href="#3-ACK-确认机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-ACK-确认机制" class="headerlink" title="3. ACK 确认机制"></a>3. <strong>ACK 确认机制</strong></h4>      <p>• <strong>可靠性级别</strong>：<br>◦ <code>acks=0</code>：不等待确认，可能丢失数据。<br>◦ <code>acks=1</code>：Leader 写入成功即确认。<br>◦ <code>acks=all</code>：所有 ISR（In-Sync Replicas）副本写入成功才确认。</p><hr>        <h3 id="三、数据存储机制"   >          <a href="#三、数据存储机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、数据存储机制" class="headerlink" title="三、数据存储机制"></a>三、数据存储机制</h3>              <h4 id="1-分区结构"   >          <a href="#1-分区结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-分区结构" class="headerlink" title="1. 分区结构"></a>1. <strong>分区结构</strong></h4>      <p>• <strong>Segment 分段存储</strong>：<br>◦ 每个分区由多个 <strong>Segment 文件</strong> 组成（默认 1GB&#x2F;个）。<br>◦ 文件名以起始 Offset 命名（如 <code>00000000000000000000.log</code>）。<br>• <strong>索引文件</strong>：<code>.index</code> 和 <code>.timeindex</code> 文件加速 Offset 和时间范围查询。</p>        <h4 id="2-日志清理策略"   >          <a href="#2-日志清理策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-日志清理策略" class="headerlink" title="2. 日志清理策略"></a>2. <strong>日志清理策略</strong></h4>      <p>• <strong>删除策略</strong>：按时间（<code>retention.ms</code>）或大小（<code>retention.bytes</code>）删除旧数据。<br>• <strong>压缩策略</strong>：按 Key 合并重复消息，保留最新值（适用于状态更新场景）。</p><hr>        <h3 id="四、数据消费流程（消费者视角）"   >          <a href="#四、数据消费流程（消费者视角）" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、数据消费流程（消费者视角）" class="headerlink" title="四、数据消费流程（消费者视角）"></a>四、数据消费流程（消费者视角）</h3>              <h4 id="1-拉取模式（Pull）"   >          <a href="#1-拉取模式（Pull）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-拉取模式（Pull）" class="headerlink" title="1. 拉取模式（Pull）"></a>1. <strong>拉取模式（Pull）</strong></h4>      <p>• <strong>主动拉取</strong>：消费者通过 <code>poll()</code> 方法从 Broker 拉取消息，按需控制消费速率。<br>• <strong>批量消费</strong>：一次拉取多条消息，减少网络开销。</p>        <h4 id="2-Offset-管理"   >          <a href="#2-Offset-管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Offset-管理" class="headerlink" title="2. Offset 管理"></a>2. <strong>Offset 管理</strong></h4>      <p>• <strong>提交方式</strong>：<br>◦ <strong>自动提交</strong>：定期提交 Offset，可能重复消费。<br>◦ <strong>手动提交</strong>：处理完消息后显式提交（<code>commitSync()</code>&#x2F;<code>commitAsync()</code>）。<br>• <strong>存储位置</strong>：Offset 存储在内部 Topic <code>__consumer_offsets</code> 中。</p>        <h4 id="3-消费者组-Rebalance"   >          <a href="#3-消费者组-Rebalance" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-消费者组-Rebalance" class="headerlink" title="3. 消费者组 Rebalance"></a>3. <strong>消费者组 Rebalance</strong></h4>      <p>• <strong>触发条件</strong>：消费者加入&#x2F;退出、Topic 分区数变化。<br>• <strong>协调者（Coordinator）</strong>：由 Broker 担任，负责分配分区给消费者。</p><hr>        <h3 id="五、高可用性与容错"   >          <a href="#五、高可用性与容错" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、高可用性与容错" class="headerlink" title="五、高可用性与容错"></a>五、高可用性与容错</h3>              <h4 id="1-副本机制（Replication）"   >          <a href="#1-副本机制（Replication）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-副本机制（Replication）" class="headerlink" title="1. 副本机制（Replication）"></a>1. <strong>副本机制（Replication）</strong></h4>      <p>• <strong>Leader-Follower 模型</strong>：<br>◦ 每个分区有多个副本，Leader 处理读写请求，Follower 同步数据。<br>◦ <strong>ISR（In-Sync Replicas）</strong>：与 Leader 数据同步的副本集合，用于故障切换。<br>• <strong>选举策略</strong>：Leader 宕机时，从 ISR 中选举新 Leader。</p>        <h4 id="2-数据一致性"   >          <a href="#2-数据一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据一致性" class="headerlink" title="2. 数据一致性"></a>2. <strong>数据一致性</strong></h4>      <p>• <strong>HW（High Watermark）</strong>：已成功复制到所有 ISR 副本的最高 Offset。<br>• <strong>消费者可见性</strong>：消费者只能读取到 HW 之前的消息，避免脏读。</p><hr>        <h3 id="六、性能优化关键技术"   >          <a href="#六、性能优化关键技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、性能优化关键技术" class="headerlink" title="六、性能优化关键技术"></a>六、性能优化关键技术</h3>              <h4 id="1-零拷贝（Zero-Copy）"   >          <a href="#1-零拷贝（Zero-Copy）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-零拷贝（Zero-Copy）" class="headerlink" title="1. 零拷贝（Zero-Copy）"></a>1. <strong>零拷贝（Zero-Copy）</strong></h4>      <p>• <strong>原理</strong>：通过 <code>sendfile()</code> 系统调用，数据直接从磁盘文件发送到网络，绕过用户态内存复制。<br>• <strong>效果</strong>：降低 CPU 和内存开销，提升吞吐量。</p>        <h4 id="2-批量处理"   >          <a href="#2-批量处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-批量处理" class="headerlink" title="2. 批量处理"></a>2. <strong>批量处理</strong></h4>      <p>• <strong>生产者批量发送</strong>：累积消息成批次后发送，减少网络请求次数。<br>• <strong>消费者批量拉取</strong>：单次拉取多条消息，提升消费效率。</p><hr>        <h3 id="七、典型应用场景"   >          <a href="#七、典型应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、典型应用场景" class="headerlink" title="七、典型应用场景"></a>七、典型应用场景</h3>              <h4 id="1-实时日志聚合"   >          <a href="#1-实时日志聚合" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-实时日志聚合" class="headerlink" title="1. 实时日志聚合"></a>1. <strong>实时日志聚合</strong></h4>      <p>• <strong>场景</strong>：收集分布式系统日志，写入 Kafka 后供 Elasticsearch 或 Flink 处理。<br>• <strong>优势</strong>：高吞吐量支持海量日志写入。</p>        <h4 id="2-事件驱动架构"   >          <a href="#2-事件驱动架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-事件驱动架构" class="headerlink" title="2. 事件驱动架构"></a>2. <strong>事件驱动架构</strong></h4>      <p>• <strong>场景</strong>：微服务间通过 Topic 传递事件（如订单创建触发库存扣减）。<br>• <strong>优势</strong>：解耦服务，提升系统扩展性。</p>        <h4 id="3-流式数据处理"   >          <a href="#3-流式数据处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-流式数据处理" class="headerlink" title="3. 流式数据处理"></a>3. <strong>流式数据处理</strong></h4>      <p>• <strong>工具链</strong>：Kafka Streams 或 Flink 实时处理数据流（如用户行为分析）。<br>• <strong>优势</strong>：低延迟处理复杂计算（窗口聚合、Join 操作）。</p><hr>        <h3 id="八、核心优势与局限性"   >          <a href="#八、核心优势与局限性" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、核心优势与局限性" class="headerlink" title="八、核心优势与局限性"></a>八、核心优势与局限性</h3>      <div class="table-container"><table><thead><tr><th><strong>优势</strong></th><th><strong>局限性</strong></th></tr></thead><tbody><tr><td>高吞吐量（百万级 QPS）</td><td>运维复杂度高（集群管理、调优）</td></tr><tr><td>低延迟（毫秒级响应）</td><td>小数据场景资源浪费</td></tr><tr><td>持久化与高可靠性</td><td>全局消息顺序无法保证</td></tr><tr><td>弹性扩展（水平扩容）</td><td>依赖外部组件（早期版本需 Zookeeper）</td></tr></tbody></table></div><hr>        <h3 id="九、总结"   >          <a href="#九、总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3>      <p>Kafka 通过 <strong>分布式分区存储</strong>、<strong>顺序磁盘 I&#x2F;O</strong> 和 <strong>副本容错机制</strong>，实现了高吞吐、高可靠的实时数据流处理。其核心设计理念是 <strong>将数据视为不可变事件流</strong>，适用于日志处理、事件驱动架构和大规模流式计算场景。但需注意其运维成本和资源消耗，合理权衡业务需求与技术选型。</p>]]></content>
    
    
    <summary type="html">Kafka工作原理详解</summary>
    
    
    
    <category term="消息队列" scheme="https://ljd0620.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="https://ljd0620.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>如何保证数据一致性</title>
    <link href="https://ljd0620.github.io/2024/05/28/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://ljd0620.github.io/2024/05/28/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2024-05-28T04:34:17.000Z</published>
    <updated>2025-03-19T02:00:43.603Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，同时保证 MySQL、Redis 和 Elasticsearch 的数据一致性是一个复杂的挑战，因为每个组件有不同的特性和数据更新机制。以下是实现数据一致性的常见策略和最佳实践：</p><hr>        <h3 id="1-数据一致性问题分析"   >          <a href="#1-数据一致性问题分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据一致性问题分析" class="headerlink" title="1. 数据一致性问题分析"></a><strong>1. 数据一致性问题分析</strong></h3>      <p>在 MySQL、Redis 和 Elasticsearch 之间，数据一致性问题通常源于以下原因：</p><ol><li><strong>数据更新顺序</strong>：<ul><li>数据更新可能在不同组件之间出现延迟或顺序不一致。</li></ul></li><li><strong>数据更新失败</strong>：<ul><li>在更新多个组件时，部分组件可能更新失败，导致数据不一致。</li></ul></li><li><strong>缓存失效</strong>：<ul><li>Redis 缓存可能未及时更新或失效，导致读取到旧数据。</li></ul></li><li><strong>索引延迟</strong>：<ul><li>Elasticsearch 的索引可能存在延迟，导致查询结果不一致。</li></ul></li></ol><hr>        <h3 id="2-数据一致性策略"   >          <a href="#2-数据一致性策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据一致性策略" class="headerlink" title="2. 数据一致性策略"></a><strong>2. 数据一致性策略</strong></h3>      <p>以下是保证 MySQL、Redis 和 Elasticsearch 数据一致性的常见策略：</p>        <h4 id="1-写时同步更新"   >          <a href="#1-写时同步更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-写时同步更新" class="headerlink" title="(1) 写时同步更新"></a><strong>(1) 写时同步更新</strong></h4>      <p>在数据写入时，同步更新 MySQL、Redis 和 Elasticsearch。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li></ol></li><li><strong>优点</strong>：<ul><li>数据实时一致。</li></ul></li><li><strong>缺点</strong>：<ul><li>写入性能较低，因为需要同步更新多个组件。</li><li>如果某个组件更新失败，可能导致数据不一致。</li></ul></li></ul>        <h4 id="2-写时异步更新"   >          <a href="#2-写时异步更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-写时异步更新" class="headerlink" title="(2) 写时异步更新"></a><strong>(2) 写时异步更新</strong></h4>      <p>在数据写入时，异步更新 Redis 和 Elasticsearch。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>异步更新 Redis 缓存（如通过消息队列）。</li><li>异步更新 Elasticsearch 索引（如通过消息队列）。</li></ol></li><li><strong>优点</strong>：<ul><li>写入性能较高。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据可能存在短暂的不一致。</li></ul></li></ul>        <h4 id="3-基于消息队列的最终一致性"   >          <a href="#3-基于消息队列的最终一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-基于消息队列的最终一致性" class="headerlink" title="(3) 基于消息队列的最终一致性"></a><strong>(3) 基于消息队列的最终一致性</strong></h4>      <p>使用消息队列（如 Kafka、RabbitMQ）实现最终一致性。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>发送消息到消息队列，通知 Redis 和 Elasticsearch 更新。</li><li>消费者从消息队列中读取消息，更新 Redis 和 Elasticsearch。</li></ol></li><li><strong>优点</strong>：<ul><li>解耦数据更新逻辑，提高系统可扩展性。</li><li>保证最终一致性。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据可能存在短暂的不一致。</li><li>需要引入消息队列，增加系统复杂性。</li></ul></li></ul>        <h4 id="4-双写-补偿机制"   >          <a href="#4-双写-补偿机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-双写-补偿机制" class="headerlink" title="(4) 双写 + 补偿机制"></a><strong>(4) 双写 + 补偿机制</strong></h4>      <p>在数据写入时，同时写入 MySQL、Redis 和 Elasticsearch，并通过补偿机制处理失败情况。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>写入 Redis。</li><li>写入 Elasticsearch。</li><li>如果某个组件写入失败，记录日志并触发补偿机制（如重试或回滚）。</li></ol></li><li><strong>优点</strong>：<ul><li>数据实时一致。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，需要处理各种失败场景。</li></ul></li></ul>        <h4 id="5-基于-CDC（Change-Data-Capture）的同步"   >          <a href="#5-基于-CDC（Change-Data-Capture）的同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-基于-CDC（Change-Data-Capture）的同步" class="headerlink" title="(5) 基于 CDC（Change Data Capture）的同步"></a><strong>(5) 基于 CDC（Change Data Capture）的同步</strong></h4>      <p>使用 CDC 工具（如 Debezium、Canal）捕获 MySQL 的变更，并同步到 Redis 和 Elasticsearch。</p><ul><li><strong>流程</strong>：<ol><li>MySQL 数据变更时，CDC 工具捕获变更事件。</li><li>CDC 工具将变更事件发送到消息队列。</li><li>消费者从消息队列中读取变更事件，更新 Redis 和 Elasticsearch。</li></ol></li><li><strong>优点</strong>：<ul><li>解耦数据更新逻辑，提高系统可扩展性。</li><li>保证最终一致性。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据可能存在短暂的不一致。</li><li>需要引入 CDC 工具和消息队列，增加系统复杂性。</li></ul></li></ul><hr>        <h3 id="3-具体实现方案"   >          <a href="#3-具体实现方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-具体实现方案" class="headerlink" title="3. 具体实现方案"></a><strong>3. 具体实现方案</strong></h3>      <p>以下是结合上述策略的具体实现方案：</p>        <h4 id="1-写时同步更新-补偿机制"   >          <a href="#1-写时同步更新-补偿机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-写时同步更新-补偿机制" class="headerlink" title="(1) 写时同步更新 + 补偿机制"></a><strong>(1) 写时同步更新 + 补偿机制</strong></h4>      <ul><li><strong>写入流程</strong>：<ol><li>开启事务，写入 MySQL。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li><li>提交事务。</li></ol></li><li><strong>补偿机制</strong>：<ul><li>如果某个组件更新失败，记录日志并触发补偿机制（如重试或回滚）。</li></ul></li></ul>        <h4 id="2-基于消息队列的最终一致性"   >          <a href="#2-基于消息队列的最终一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-基于消息队列的最终一致性" class="headerlink" title="(2) 基于消息队列的最终一致性"></a><strong>(2) 基于消息队列的最终一致性</strong></h4>      <ul><li><strong>写入流程</strong>：<ol><li>写入 MySQL。</li><li>发送消息到消息队列，通知 Redis 和 Elasticsearch 更新。</li></ol></li><li><strong>消费者流程</strong>：<ol><li>从消息队列中读取消息。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li></ol></li></ul>        <h4 id="3-基于-CDC-的同步"   >          <a href="#3-基于-CDC-的同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-基于-CDC-的同步" class="headerlink" title="(3) 基于 CDC 的同步"></a><strong>(3) 基于 CDC 的同步</strong></h4>      <ul><li><strong>CDC 工具配置</strong>：<ol><li>配置 Debezium 或 Canal，捕获 MySQL 的变更事件。</li><li>将变更事件发送到消息队列（如 Kafka）。</li></ol></li><li><strong>消费者流程</strong>：<ol><li>从消息队列中读取变更事件。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li></ol></li></ul><hr>        <h3 id="4-最佳实践"   >          <a href="#4-最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a><strong>4. 最佳实践</strong></h3>      <ul><li><strong>合理选择一致性策略</strong>：<ul><li>根据业务需求选择强一致性或最终一致性。</li></ul></li><li><strong>引入消息队列</strong>：<ul><li>使用消息队列解耦数据更新逻辑，提高系统可扩展性。</li></ul></li><li><strong>监控与告警</strong>：<ul><li>监控 MySQL、Redis 和 Elasticsearch 的数据一致性，及时发现和处理问题。</li></ul></li><li><strong>补偿机制</strong>：<ul><li>设计完善的补偿机制，处理数据更新失败的情况。</li></ul></li><li><strong>测试与验证</strong>：<ul><li>在开发和测试环境中验证数据一致性策略，确保其正确性和可靠性。</li></ul></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>保证 MySQL、Redis 和 Elasticsearch 数据一致性的常见策略包括：</p><ol><li><strong>写时同步更新</strong>：适合强一致性场景，但性能较低。</li><li><strong>写时异步更新</strong>：适合最终一致性场景，性能较高。</li><li><strong>基于消息队列的最终一致性</strong>：解耦数据更新逻辑，适合高扩展性场景。</li><li><strong>双写 + 补偿机制</strong>：适合强一致性场景，但实现复杂。</li><li><strong>基于 CDC 的同步</strong>：适合最终一致性场景，解耦数据更新逻辑。</li></ol><p>根据具体的业务场景和性能需求，选择合适的策略，可以有效地保证 MySQL、Redis 和 Elasticsearch 的数据一致性。</p>]]></content>
    
    
    <summary type="html">如何保证数据一致性</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Elasticsearch" scheme="https://ljd0620.github.io/tags/Elasticsearch/"/>
    
    <category term="分布式" scheme="https://ljd0620.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="MySQL" scheme="https://ljd0620.github.io/tags/MySQL/"/>
    
    <category term="Redis" scheme="https://ljd0620.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式微服务架构</title>
    <link href="https://ljd0620.github.io/2024/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://ljd0620.github.io/2024/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</id>
    <published>2024-05-18T04:36:46.000Z</published>
    <updated>2025-03-19T02:01:23.679Z</updated>
    
    <content type="html"><![CDATA[<p>分布式微服务架构是一种将应用程序拆分为多个小型、独立服务的开发模式，每个服务可以独立开发、部署和扩展。虽然微服务架构提供了灵活性和可扩展性，但也带来了许多挑战。以下是分布式微服务开发中需要注意的关键点：</p><hr>        <h3 id="1-服务拆分与设计"   >          <a href="#1-服务拆分与设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-服务拆分与设计" class="headerlink" title="1. 服务拆分与设计"></a><strong>1. 服务拆分与设计</strong></h3>              <h4 id="1-服务边界"   >          <a href="#1-服务边界" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-服务边界" class="headerlink" title="(1) 服务边界"></a><strong>(1) 服务边界</strong></h4>      <ul><li><strong>单一职责原则</strong>：<ul><li>每个服务应该只负责一个明确的业务功能。例如，用户服务只处理用户相关的逻辑，订单服务只处理订单相关的逻辑。</li><li>避免将多个不相关的功能耦合在一个服务中，否则会导致服务臃肿，难以维护。</li></ul></li><li><strong>领域驱动设计（DDD）</strong>：<ul><li>使用 DDD 的限界上下文（Bounded Context）来划分服务边界。例如，电商系统中可以将“订单”、“库存”、“支付”划分为不同的限界上下文，每个上下文对应一个服务。</li><li>限界上下文之间的交互通过明确的接口进行，避免直接依赖内部实现。</li></ul></li></ul>        <h4 id="2-服务粒度"   >          <a href="#2-服务粒度" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-服务粒度" class="headerlink" title="(2) 服务粒度"></a><strong>(2) 服务粒度</strong></h4>      <ul><li><strong>适度拆分</strong>：<ul><li>服务粒度过细会增加系统复杂性（如服务间通信成本增加），过粗则无法体现微服务的优势。</li><li>例如，初期可以将“用户服务”和“权限服务”合并为一个“用户权限服务”，随着业务发展再拆分为两个独立服务。</li></ul></li><li><strong>演进式设计</strong>：<ul><li>初期可以设计较粗粒度的服务，随着业务复杂性的增加逐步拆分。</li><li>例如，电商系统初期可以将“订单服务”和“库存服务”合并为一个“交易服务”，后期再拆分为独立的服务。</li></ul></li></ul><hr>        <h3 id="2-通信机制"   >          <a href="#2-通信机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-通信机制" class="headerlink" title="2. 通信机制"></a><strong>2. 通信机制</strong></h3>              <h4 id="1-通信协议"   >          <a href="#1-通信协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-通信协议" class="headerlink" title="(1) 通信协议"></a><strong>(1) 通信协议</strong></h4>      <ul><li><strong>同步通信</strong>：<ul><li>使用 RESTful API 或 gRPC 进行同步调用。RESTful API 适合简单的 HTTP 通信，gRPC 适合高性能、强类型的场景。</li><li>例如，订单服务调用支付服务时，可以使用 RESTful API 发送支付请求。</li></ul></li><li><strong>异步通信</strong>：<ul><li>使用消息队列（如 Kafka、RabbitMQ）进行异步通信。适合解耦服务间的依赖，提高系统的可扩展性。</li><li>例如，订单服务创建订单后，通过消息队列通知库存服务扣减库存。</li></ul></li></ul>        <h4 id="2-数据一致性"   >          <a href="#2-数据一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据一致性" class="headerlink" title="(2) 数据一致性"></a><strong>(2) 数据一致性</strong></h4>      <ul><li><strong>分布式事务</strong>：<ul><li>使用两阶段提交（2PC）或 Saga 模式保证跨服务的事务一致性。</li><li>例如，订单服务和库存服务通过 Saga 模式实现分布式事务：订单服务创建订单后，库存服务扣减库存；如果库存扣减失败，订单服务回滚订单。</li></ul></li><li><strong>最终一致性</strong>：<ul><li>通过消息队列实现最终一致性。例如，订单服务创建订单后，发送消息到消息队列，库存服务消费消息后扣减库存。</li></ul></li></ul>        <h4 id="3-服务发现与负载均衡"   >          <a href="#3-服务发现与负载均衡" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-服务发现与负载均衡" class="headerlink" title="(3) 服务发现与负载均衡"></a><strong>(3) 服务发现与负载均衡</strong></h4>      <ul><li><strong>服务发现</strong>：<ul><li>使用服务注册中心（如 Consul、Eureka）动态发现服务实例。例如，订单服务通过 Eureka 发现库存服务的实例。</li></ul></li><li><strong>负载均衡</strong>：<ul><li>使用客户端负载均衡（如 Ribbon）或服务端负载均衡（如 Nginx）。例如，订单服务通过 Ribbon 负载均衡调用库存服务的多个实例。</li></ul></li></ul><hr>        <h3 id="3-数据管理"   >          <a href="#3-数据管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-数据管理" class="headerlink" title="3. 数据管理"></a><strong>3. 数据管理</strong></h3>              <h4 id="1-数据库设计"   >          <a href="#1-数据库设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据库设计" class="headerlink" title="(1) 数据库设计"></a><strong>(1) 数据库设计</strong></h4>      <ul><li><strong>数据库拆分</strong>：<ul><li>每个服务使用独立的数据库，避免数据耦合。例如，订单服务使用 MySQL 存储订单数据，库存服务使用 PostgreSQL 存储库存数据。</li></ul></li><li><strong>数据同步</strong>：<ul><li>使用 CDC（Change Data Capture）工具（如 Debezium）同步数据。例如，订单服务的数据变更通过 Debezium 同步到数据仓库。</li></ul></li></ul>        <h4 id="2-缓存设计"   >          <a href="#2-缓存设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缓存设计" class="headerlink" title="(2) 缓存设计"></a><strong>(2) 缓存设计</strong></h4>      <ul><li><strong>分布式缓存</strong>：<ul><li>使用 Redis 或 Memcached 作为分布式缓存。例如，用户服务将用户信息缓存到 Redis 中，减少数据库查询压力。</li></ul></li><li><strong>缓存一致性</strong>：<ul><li>使用缓存失效策略（如写时失效）保证数据一致性。例如，用户信息更新时，同时失效 Redis 中的缓存。</li></ul></li></ul><hr>        <h3 id="4-容错与弹性"   >          <a href="#4-容错与弹性" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-容错与弹性" class="headerlink" title="4. 容错与弹性"></a><strong>4. 容错与弹性</strong></h3>              <h4 id="1-熔断与降级"   >          <a href="#1-熔断与降级" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-熔断与降级" class="headerlink" title="(1) 熔断与降级"></a><strong>(1) 熔断与降级</strong></h4>      <ul><li><strong>熔断器</strong>：<ul><li>使用熔断器（如 Hystrix、Resilience4j）防止服务雪崩。例如，当库存服务不可用时，订单服务触发熔断，直接返回错误提示。</li></ul></li><li><strong>降级策略</strong>：<ul><li>在服务不可用时返回默认值或缓存数据。例如，当推荐服务不可用时，返回默认的推荐列表。</li></ul></li></ul>        <h4 id="2-重试与超时"   >          <a href="#2-重试与超时" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-重试与超时" class="headerlink" title="(2) 重试与超时"></a><strong>(2) 重试与超时</strong></h4>      <ul><li><strong>重试机制</strong>：<ul><li>配置合理的重试次数和间隔（如指数退避）。例如，订单服务调用支付服务失败时，重试 3 次，每次间隔 1 秒。</li></ul></li><li><strong>超时设置</strong>：<ul><li>设置合理的超时时间，避免请求长时间阻塞。例如，订单服务调用库存服务的超时时间为 2 秒。</li></ul></li></ul>        <h4 id="3-限流与降级"   >          <a href="#3-限流与降级" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-限流与降级" class="headerlink" title="(3) 限流与降级"></a><strong>(3) 限流与降级</strong></h4>      <ul><li><strong>限流</strong>：<ul><li>使用限流算法（如令牌桶、漏桶）保护服务。例如，库存服务每秒最多处理 100 个请求，超过的请求直接拒绝。</li></ul></li><li><strong>降级</strong>：<ul><li>在系统压力过大时，关闭非核心功能。例如，促销活动期间关闭推荐服务，优先保证订单服务的可用性。</li></ul></li></ul><hr>        <h3 id="5-监控与日志"   >          <a href="#5-监控与日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-监控与日志" class="headerlink" title="5. 监控与日志"></a><strong>5. 监控与日志</strong></h3>              <h4 id="1-监控"   >          <a href="#1-监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-监控" class="headerlink" title="(1) 监控"></a><strong>(1) 监控</strong></h4>      <ul><li><strong>指标收集</strong>：<ul><li>使用 Prometheus 收集服务的性能指标。例如，监控订单服务的 QPS、响应时间等。</li></ul></li><li><strong>链路追踪</strong>：<ul><li>使用 Jaeger 或 Zipkin 追踪请求链路。例如，追踪订单服务调用支付服务的链路。</li></ul></li></ul>        <h4 id="2-日志"   >          <a href="#2-日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-日志" class="headerlink" title="(2) 日志"></a><strong>(2) 日志</strong></h4>      <ul><li><strong>集中日志</strong>：<ul><li>使用 ELK（Elasticsearch、Logstash、Kibana）或 Loki 集中管理日志。例如，将所有服务的日志收集到 Elasticsearch 中，通过 Kibana 查询。</li></ul></li><li><strong>结构化日志</strong>：<ul><li>使用 JSON 格式记录日志，便于分析和查询。例如，日志格式为 <code>&#123;&quot;level&quot;:&quot;info&quot;,&quot;message&quot;:&quot;Order created&quot;,&quot;orderId&quot;:123&#125;</code>。</li></ul></li></ul><hr>        <h3 id="6-安全性"   >          <a href="#6-安全性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-安全性" class="headerlink" title="6. 安全性"></a><strong>6. 安全性</strong></h3>              <h4 id="1-认证与授权"   >          <a href="#1-认证与授权" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-认证与授权" class="headerlink" title="(1) 认证与授权"></a><strong>(1) 认证与授权</strong></h4>      <ul><li><strong>认证</strong>：<ul><li>使用 OAuth2 或 JWT 进行用户认证。例如，用户登录后获取 JWT，后续请求携带 JWT 进行认证。</li></ul></li><li><strong>授权</strong>：<ul><li>使用 RBAC（基于角色的访问控制）或 ABAC（基于属性的访问控制）进行权限管理。例如，管理员角色可以访问所有订单数据，普通用户只能访问自己的订单数据。</li></ul></li></ul>        <h4 id="2-数据安全"   >          <a href="#2-数据安全" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据安全" class="headerlink" title="(2) 数据安全"></a><strong>(2) 数据安全</strong></h4>      <ul><li><strong>加密传输</strong>：<ul><li>使用 HTTPS 加密通信数据。例如，订单服务与支付服务之间的通信使用 HTTPS。</li></ul></li><li><strong>数据脱敏</strong>：<ul><li>对敏感数据进行脱敏处理。例如，用户手机号显示为 <code>138****1234</code>。</li></ul></li></ul><hr>        <h3 id="7-部署与运维"   >          <a href="#7-部署与运维" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-部署与运维" class="headerlink" title="7. 部署与运维"></a><strong>7. 部署与运维</strong></h3>              <h4 id="1-容器化"   >          <a href="#1-容器化" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-容器化" class="headerlink" title="(1) 容器化"></a><strong>(1) 容器化</strong></h4>      <ul><li><strong>Docker</strong>：<ul><li>使用 Docker 容器化服务。例如，将订单服务打包为 Docker 镜像。</li></ul></li><li><strong>Kubernetes</strong>：<ul><li>使用 Kubernetes 管理容器化服务的部署和扩展。例如，通过 Kubernetes 自动扩展订单服务的实例数量。</li></ul></li></ul>        <h4 id="2-CI-CD"   >          <a href="#2-CI-CD" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-CI-CD" class="headerlink" title="(2) CI&#x2F;CD"></a><strong>(2) CI&#x2F;CD</strong></h4>      <ul><li><strong>持续集成</strong>：<ul><li>使用 Jenkins 或 GitLab CI 实现持续集成。例如，每次代码提交后自动运行单元测试。</li></ul></li><li><strong>持续交付</strong>：<ul><li>使用 ArgoCD 或 Spinnaker 实现持续交付。例如，通过 ArgoCD 自动将新版本部署到测试环境。</li></ul></li></ul>        <h4 id="3-配置管理"   >          <a href="#3-配置管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-配置管理" class="headerlink" title="(3) 配置管理"></a><strong>(3) 配置管理</strong></h4>      <ul><li><strong>集中配置</strong>：<ul><li>使用 Spring Cloud Config 或 Apollo 管理配置。例如，将所有服务的配置集中存储在 Apollo 中。</li></ul></li><li><strong>动态更新</strong>：<ul><li>支持配置的动态更新，避免重启服务。例如，通过 Apollo 动态修改订单服务的超时时间。</li></ul></li></ul><hr>        <h3 id="8-测试与验证"   >          <a href="#8-测试与验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-测试与验证" class="headerlink" title="8. 测试与验证"></a><strong>8. 测试与验证</strong></h3>              <h4 id="1-单元测试"   >          <a href="#1-单元测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-单元测试" class="headerlink" title="(1) 单元测试"></a><strong>(1) 单元测试</strong></h4>      <ul><li><strong>覆盖率</strong>：<ul><li>确保单元测试覆盖核心逻辑。例如，订单服务的单元测试覆盖创建订单、取消订单等核心功能。</li></ul></li><li><strong>Mock 测试</strong>：<ul><li>使用 Mockito 或 WireMock 模拟依赖服务。例如，模拟支付服务的响应，测试订单服务的逻辑。</li></ul></li></ul>        <h4 id="2-集成测试"   >          <a href="#2-集成测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-集成测试" class="headerlink" title="(2) 集成测试"></a><strong>(2) 集成测试</strong></h4>      <ul><li><strong>服务间测试</strong>：<ul><li>测试服务之间的通信和数据一致性。例如，测试订单服务调用库存服务的接口。</li></ul></li><li><strong>端到端测试</strong>：<ul><li>模拟真实用户场景，验证系统整体功能。例如，模拟用户从下单到支付的完整流程。</li></ul></li></ul>        <h4 id="3-性能测试"   >          <a href="#3-性能测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-性能测试" class="headerlink" title="(3) 性能测试"></a><strong>(3) 性能测试</strong></h4>      <ul><li><strong>压力测试</strong>：<ul><li>使用 JMeter 或 Gatling 进行压力测试。例如，模拟 1000 个用户同时下单，测试系统的性能。</li></ul></li><li><strong>容量规划</strong>：<ul><li>根据测试结果规划系统容量。例如，根据压力测试结果决定需要部署多少台服务器。</li></ul></li></ul><hr>        <h3 id="9-文档与协作"   >          <a href="#9-文档与协作" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-文档与协作" class="headerlink" title="9. 文档与协作"></a><strong>9. 文档与协作</strong></h3>              <h4 id="1-API-文档"   >          <a href="#1-API-文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-API-文档" class="headerlink" title="(1) API 文档"></a><strong>(1) API 文档</strong></h4>      <ul><li><strong>Swagger</strong>：<ul><li>使用 Swagger 生成 API 文档。例如，订单服务的 API 文档通过 Swagger 自动生成。</li></ul></li><li><strong>版本管理</strong>：<ul><li>对 API 进行版本管理，避免兼容性问题。例如，订单服务的 API 版本为 <code>v1</code> 和 <code>v2</code>，旧版本逐步淘汰。</li></ul></li></ul>        <h4 id="2-团队协作"   >          <a href="#2-团队协作" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-团队协作" class="headerlink" title="(2) 团队协作"></a><strong>(2) 团队协作</strong></h4>      <ul><li><strong>代码规范</strong>：<ul><li>制定统一的代码规范，便于团队协作。例如，使用 Google Java Style Guide 规范代码格式。</li></ul></li><li><strong>知识共享</strong>：<ul><li>定期进行技术分享，提升团队整体水平。例如，每周组织一次技术分享会。</li></ul></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>分布式微服务开发需要注意以下关键点：</p><ol><li><strong>服务拆分与设计</strong>：合理定义服务边界和粒度。</li><li><strong>通信机制</strong>：选择合适的通信协议和数据一致性方案。</li><li><strong>数据管理</strong>：设计独立的数据库和缓存策略。</li><li><strong>容错与弹性</strong>：实现熔断、降级、限流等机制。</li><li><strong>监控与日志</strong>：集中管理监控指标和日志。</li><li><strong>安全性</strong>：确保认证、授权和数据安全。</li><li><strong>部署与运维</strong>：使用容器化和 CI&#x2F;CD 工具。</li><li><strong>测试与验证</strong>：进行全面的单元测试、集成测试和性能测试。</li><li><strong>文档与协作</strong>：维护 API 文档和团队协作规范。</li></ol><p>通过关注这些关键点，可以构建高效、可靠的分布式微服务系统。</p>]]></content>
    
    
    <summary type="html">分布式微服务架构</summary>
    
    
    
    <category term="分布式" scheme="https://ljd0620.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://ljd0620.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Resilience4j的工作原理</title>
    <link href="https://ljd0620.github.io/2024/04/13/Resilience4j%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://ljd0620.github.io/2024/04/13/Resilience4j%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2024-04-13T04:20:48.000Z</published>
    <updated>2025-03-19T02:03:26.173Z</updated>
    
    <content type="html"><![CDATA[<p>Resilience4j 是一个轻量级的容错库，专为 Java 8 和函数式编程设计。它提供了熔断器、限流器、重试机制、隔舱模式等功能，帮助开发者构建健壮的分布式系统。Resilience4j 的设计目标是<strong>简单、轻量、模块化</strong>，并且与 Spring Boot 和 Spring Cloud 集成良好。以下是 Resilience4j 的工作原理及其核心机制的详细解析：</p><hr>        <h3 id="1-Resilience4j-的核心功能"   >          <a href="#1-Resilience4j-的核心功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Resilience4j-的核心功能" class="headerlink" title="1. Resilience4j 的核心功能"></a><strong>1. Resilience4j 的核心功能</strong></h3>      <p>Resilience4j 提供了以下核心功能：</p><ol><li><strong>熔断器（Circuit Breaker）</strong>：<ul><li>防止系统因某个服务的故障而崩溃。</li></ul></li><li><strong>限流器（Rate Limiter）</strong>：<ul><li>控制请求的速率，防止系统过载。</li></ul></li><li><strong>重试机制（Retry）</strong>：<ul><li>在请求失败时自动重试。</li></ul></li><li><strong>隔舱模式（Bulkhead）</strong>：<ul><li>隔离资源，避免某个服务的故障影响其他服务。</li></ul></li><li><strong>缓存（Cache）</strong>：<ul><li>对请求结果进行缓存，减少重复请求的开销。</li></ul></li><li><strong>时间限制器（Time Limiter）</strong>：<ul><li>限制方法的执行时间，避免长时间阻塞。</li></ul></li></ol><hr>        <h3 id="2-Resilience4j-的工作原理"   >          <a href="#2-Resilience4j-的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Resilience4j-的工作原理" class="headerlink" title="2. Resilience4j 的工作原理"></a><strong>2. Resilience4j 的工作原理</strong></h3>      <p>Resilience4j 的工作原理基于<strong>装饰器模式</strong>，通过装饰器对方法调用进行增强，从而实现容错功能。以下是 Resilience4j 的工作流程：</p>        <h4 id="1-定义核心逻辑"   >          <a href="#1-定义核心逻辑" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义核心逻辑" class="headerlink" title="(1) 定义核心逻辑"></a><strong>(1) 定义核心逻辑</strong></h4>      <p>开发者定义需要保护的核心逻辑（如调用外部服务）。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">callExternalService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用外部服务</span></span><br><span class="line">    <span class="keyword">return</span> externalService.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-创建装饰器"   >          <a href="#2-创建装饰器" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-创建装饰器" class="headerlink" title="(2) 创建装饰器"></a><strong>(2) 创建装饰器</strong></h4>      <p>使用 Resilience4j 提供的装饰器对核心逻辑进行增强。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CircuitBreaker</span> <span class="variable">circuitBreaker</span> <span class="operator">=</span> CircuitBreaker.ofDefaults(<span class="string">&quot;externalService&quot;</span>);</span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.ofDefaults(<span class="string">&quot;externalService&quot;</span>);</span><br><span class="line"><span class="type">Retry</span> <span class="variable">retry</span> <span class="operator">=</span> Retry.ofDefaults(<span class="string">&quot;externalService&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> CircuitBreaker.decorateSupplier(circuitBreaker, () -&gt;</span><br><span class="line">    RateLimiter.decorateSupplier(rateLimiter, () -&gt;</span><br><span class="line">        Retry.decorateSupplier(retry, () -&gt;</span><br><span class="line">            callExternalService()</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">).get();</span><br></pre></td></tr></table></div></figure>        <h4 id="3-执行装饰后的逻辑"   >          <a href="#3-执行装饰后的逻辑" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-执行装饰后的逻辑" class="headerlink" title="(3) 执行装饰后的逻辑"></a><strong>(3) 执行装饰后的逻辑</strong></h4>      <p>调用装饰后的逻辑，Resilience4j 会根据配置的规则（如熔断、限流、重试等）执行核心逻辑。</p><hr>        <h3 id="3-Resilience4j-的核心机制"   >          <a href="#3-Resilience4j-的核心机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Resilience4j-的核心机制" class="headerlink" title="3. Resilience4j 的核心机制"></a><strong>3. Resilience4j 的核心机制</strong></h3>      <p>以下是 Resilience4j 的核心机制及其实现原理：</p>        <h4 id="1-熔断器（Circuit-Breaker）"   >          <a href="#1-熔断器（Circuit-Breaker）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-熔断器（Circuit-Breaker）" class="headerlink" title="(1) 熔断器（Circuit Breaker）"></a><strong>(1) 熔断器（Circuit Breaker）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>监控请求的成功与失败情况。</li><li>当失败率达到阈值时，熔断器打开，所有请求快速失败。</li><li>经过一段时间后，熔断器进入半开状态，允许部分请求通过以检测服务是否恢复。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>failureRateThreshold</code>：失败率阈值（默认 50%）。</li><li><code>waitDurationInOpenState</code>：熔断器打开后进入半开状态的时间（默认 60 秒）。</li><li><code>ringBufferSizeInHalfOpenState</code>：半开状态下的请求数（默认 10）。</li><li><code>ringBufferSizeInClosedState</code>：关闭状态下的请求数（默认 100）。</li></ul></li></ul>        <h4 id="2-限流器（Rate-Limiter）"   >          <a href="#2-限流器（Rate-Limiter）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-限流器（Rate-Limiter）" class="headerlink" title="(2) 限流器（Rate Limiter）"></a><strong>(2) 限流器（Rate Limiter）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>控制请求的速率，防止系统过载。</li><li>使用令牌桶算法实现限流。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>limitRefreshPeriod</code>：令牌刷新周期（默认 500 纳秒）。</li><li><code>limitForPeriod</code>：每个周期的请求限制（默认 50）。</li></ul></li></ul>        <h4 id="3-重试机制（Retry）"   >          <a href="#3-重试机制（Retry）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-重试机制（Retry）" class="headerlink" title="(3) 重试机制（Retry）"></a><strong>(3) 重试机制（Retry）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>在请求失败时自动重试。</li><li>支持配置重试次数、重试间隔等。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>maxAttempts</code>：最大重试次数（默认 3）。</li><li><code>waitDuration</code>：重试间隔（默认 500 毫秒）。</li></ul></li></ul>        <h4 id="4-隔舱模式（Bulkhead）"   >          <a href="#4-隔舱模式（Bulkhead）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-隔舱模式（Bulkhead）" class="headerlink" title="(4) 隔舱模式（Bulkhead）"></a><strong>(4) 隔舱模式（Bulkhead）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>隔离资源，避免某个服务的故障影响其他服务。</li><li>支持线程池隔离和信号量隔离。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>maxConcurrentCalls</code>：最大并发调用数（默认 25）。</li><li><code>maxWaitDuration</code>：最大等待时间（默认 0 毫秒）。</li></ul></li></ul>        <h4 id="5-时间限制器（Time-Limiter）"   >          <a href="#5-时间限制器（Time-Limiter）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-时间限制器（Time-Limiter）" class="headerlink" title="(5) 时间限制器（Time Limiter）"></a><strong>(5) 时间限制器（Time Limiter）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>限制方法的执行时间，避免长时间阻塞。</li><li>如果方法执行超时，抛出 <code>TimeoutException</code>。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>timeoutDuration</code>：超时时间（默认 1 秒）。</li></ul></li></ul><hr>        <h3 id="4-Resilience4j-的示例代码"   >          <a href="#4-Resilience4j-的示例代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Resilience4j-的示例代码" class="headerlink" title="4. Resilience4j 的示例代码"></a><strong>4. Resilience4j 的示例代码</strong></h3>      <p>以下是一个完整的 Resilience4j 示例：</p>        <h4 id="1-添加依赖"   >          <a href="#1-添加依赖" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-添加依赖" class="headerlink" title="(1) 添加依赖"></a><strong>(1) 添加依赖</strong></h4>      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="2-配置-Resilience4j"   >          <a href="#2-配置-Resilience4j" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-配置-Resilience4j" class="headerlink" title="(2) 配置 Resilience4j"></a><strong>(2) 配置 Resilience4j</strong></h4>      <figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">externalService:</span></span><br><span class="line">        <span class="attr">failureRateThreshold:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">waitDurationInOpenState:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">ringBufferSizeInHalfOpenState:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">ringBufferSizeInClosedState:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">ratelimiter:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">externalService:</span></span><br><span class="line">        <span class="attr">limitForPeriod:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">limitRefreshPeriod:</span> <span class="string">1s</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">externalService:</span></span><br><span class="line">        <span class="attr">maxAttempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">waitDuration:</span> <span class="string">500ms</span></span><br></pre></td></tr></table></div></figure>        <h4 id="3-使用-Resilience4j"   >          <a href="#3-使用-Resilience4j" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-使用-Resilience4j" class="headerlink" title="(3) 使用 Resilience4j"></a><strong>(3) 使用 Resilience4j</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalService</span> &#123;</span><br><span class="line">    <span class="meta">@CircuitBreaker(name = &quot;externalService&quot;, fallbackMethod = &quot;fallback&quot;)</span></span><br><span class="line">    <span class="meta">@RateLimiter(name = &quot;externalService&quot;)</span></span><br><span class="line">    <span class="meta">@Retry(name = &quot;externalService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">callExternalService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用外部服务</span></span><br><span class="line">        <span class="keyword">return</span> externalService.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fallback</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fallback response&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="5-Resilience4j-的优缺点"   >          <a href="#5-Resilience4j-的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Resilience4j-的优缺点" class="headerlink" title="5. Resilience4j 的优缺点"></a><strong>5. Resilience4j 的优缺点</strong></h3>              <h4 id="1-优点"   >          <a href="#1-优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-优点" class="headerlink" title="(1) 优点"></a><strong>(1) 优点</strong></h4>      <ul><li><strong>轻量级</strong>：模块化设计，按需引入功能。</li><li><strong>易于集成</strong>：与 Spring Boot 和 Spring Cloud 集成良好。</li><li><strong>丰富的功能</strong>：支持熔断、限流、重试、隔舱等多种容错机制。</li><li><strong>灵活的配置</strong>：支持通过配置文件或代码进行配置。</li></ul>        <h4 id="2-缺点"   >          <a href="#2-缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a><strong>(2) 缺点</strong></h4>      <ul><li><strong>学习成本</strong>：需要熟悉 Resilience4j 的 API 和配置。</li><li><strong>性能开销</strong>：装饰器模式会带来一定的性能开销。</li></ul><hr>        <h3 id="6-Resilience4j-的替代方案"   >          <a href="#6-Resilience4j-的替代方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Resilience4j-的替代方案" class="headerlink" title="6. Resilience4j 的替代方案"></a><strong>6. Resilience4j 的替代方案</strong></h3>      <ol><li><strong>Hystrix</strong>：<ul><li>Netflix 开源的容错库，已停止维护。</li></ul></li><li><strong>Sentinel</strong>：<ul><li>阿里巴巴开源的流量控制和熔断降级框架。</li></ul></li><li><strong>Spring Cloud Circuit Breaker</strong>：<ul><li>Spring Cloud 提供的统一熔断器抽象，支持多种实现（如 Resilience4j、Sentinel 等）。</li></ul></li></ol><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Resilience4j 通过装饰器模式提供了熔断、限流、重试、隔舱等容错机制，帮助开发者构建健壮的分布式系统。其轻量级、模块化的设计使其易于集成和扩展。尽管 Resilience4j 有一定的学习成本和性能开销，但其丰富的功能和灵活的配置使其成为现代分布式系统中的理想选择。</p>]]></content>
    
    
    <summary type="html">Resilience4j的工作原理</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Resilience4j" scheme="https://ljd0620.github.io/tags/Resilience4j/"/>
    
  </entry>
  
  <entry>
    <title>Feign定制化开发指南</title>
    <link href="https://ljd0620.github.io/2024/03/26/Feign%E5%AE%9A%E5%88%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>https://ljd0620.github.io/2024/03/26/Feign%E5%AE%9A%E5%88%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</id>
    <published>2024-03-26T04:33:52.000Z</published>
    <updated>2025-03-19T02:01:58.712Z</updated>
    
    <content type="html"><![CDATA[<p>Feign 是一个声明式的 Web 服务客户端，主要用于简化 HTTP 请求的调用。然而，在非 HTTP 请求的场景下，例如区块链应用中常见的 gRPC、WebSocket 或者直接的 TCP&#x2F;IP 协议通信，Feign 并不是直接适用的。但是，通过一些定制化开发，你可以扩展 Feign 来适应这些不同的协议。</p><p>要在非 HTTP 请求的场景下，例如区块链智能合约调用中使用 Feign 框架进行定制化开发，你需要对 Feign 进行扩展或替换其核心组件以适应新的协议。以下是一个详细的步骤指南，帮助你在这种情况下使用 Feign：</p>        <h3 id="1-理解需求"   >          <a href="#1-理解需求" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-理解需求" class="headerlink" title="1. 理解需求"></a>1. 理解需求</h3>      <p>首先明确你希望实现的目标。对于区块链智能合约调用，通常需要通过某种方式与区块链节点通信（如通过 JSON-RPC、gRPC 或者 WebSocket），而不是直接的 HTTP 请求。</p>        <h3 id="2-设计接口"   >          <a href="#2-设计接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-设计接口" class="headerlink" title="2. 设计接口"></a>2. 设计接口</h3>      <p>设计一个接口来表示你想要执行的操作。这个接口将作为 Feign 的客户端接口，并且应该包含所有必要的方法定义。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;blockchain-client&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockchainClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /eth_call&quot;)</span></span><br><span class="line">    String <span class="title function_">callSmartContract</span><span class="params">(<span class="meta">@Param(&quot;data&quot;)</span> String data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>请注意，这里的 <code>@RequestLine</code> 注解是用于指定请求的方法和路径，而在实际的区块链交互中，这可能并不适用。因此，你可能需要自定义注解或者完全不使用这些注解。</p>        <h3 id="3-创建自定义-Client-实现"   >          <a href="#3-创建自定义-Client-实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-创建自定义-Client-实现" class="headerlink" title="3. 创建自定义 Client 实现"></a>3. 创建自定义 Client 实现</h3>      <p>由于 Feign 默认是为 HTTP 设计的，所以你需要创建一个新的 <code>feign.Client</code> 实现类来处理特定于区块链的通信逻辑。例如，如果你正在使用 Web3j 库与 Ethereum 区块链交互，你可以这样做：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Client;</span><br><span class="line"><span class="keyword">import</span> feign.Request;</span><br><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> org.web3j.protocol.Web3j;</span><br><span class="line"><span class="keyword">import</span> org.web3j.protocol.core.methods.response.EthCall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Web3jClient</span> <span class="keyword">implements</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Web3j web3j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Web3jClient</span><span class="params">(Web3j web3j)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.web3j = web3j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 解析请求中的参数并构造相应的 Web3j 调用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request.body());</span><br><span class="line">        <span class="type">EthCall</span> <span class="variable">response</span> <span class="operator">=</span> web3j.ethCall(</span><br><span class="line">                <span class="comment">// 根据你的需求解析 requestBody 并构造正确的参数</span></span><br><span class="line">                <span class="comment">// 这里只是一个示例</span></span><br><span class="line">                Transaction.createEthCallTransaction(</span><br><span class="line">                        <span class="string">&quot;fromAddress&quot;</span>, </span><br><span class="line">                        <span class="string">&quot;toAddress&quot;</span>, </span><br><span class="line">                        <span class="string">&quot;data&quot;</span></span><br><span class="line">                ),</span><br><span class="line">                DefaultBlockParameterName.LATEST</span><br><span class="line">        ).send();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 Feign 的 Response 对象</span></span><br><span class="line">        <span class="keyword">return</span> Response.builder()</span><br><span class="line">                .status(<span class="number">200</span>)</span><br><span class="line">                .reason(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">                .body(response.getResult(), StandardCharsets.UTF_8)</span><br><span class="line">                .headers(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="4-配置-Feign-使用自定义-Client"   >          <a href="#4-配置-Feign-使用自定义-Client" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-配置-Feign-使用自定义-Client" class="headerlink" title="4. 配置 Feign 使用自定义 Client"></a>4. 配置 Feign 使用自定义 Client</h3>      <p>在 Spring Boot 中，你可以通过配置文件或编程方式指定自定义的 <code>Client</code> 实现。</p><ul><li><p><strong>编程方式</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Client <span class="title function_">feignClient</span><span class="params">(Web3j web3j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Web3jClient</span>(web3j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>配置文件方式</strong>：</p><p>如果你有多个不同的客户端配置，可以在 <code>application.yml</code> 中进行配置。</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">blockchain-client:</span></span><br><span class="line">        <span class="attr">client:</span> <span class="string">com.example.Web3jClient</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h3 id="5-处理复杂场景"   >          <a href="#5-处理复杂场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-处理复杂场景" class="headerlink" title="5. 处理复杂场景"></a>5. 处理复杂场景</h3>      <p>对于更复杂的场景，比如区块链中的 P2P 通信或者智能合约调用，你可能需要进一步定制化 Feign 的行为。这包括但不限于：</p><ul><li><p><strong>编码器与解码器</strong>：根据具体协议的要求，编写自定义的 <code>Encoder</code> 和 <code>Decoder</code> 来序列化和反序列化请求和响应数据。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Encoder <span class="title function_">feignEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomBlockchainEncoder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Decoder <span class="title function_">feignDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomBlockchainDecoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>拦截器</strong>：使用 <code>RequestInterceptor</code> 来添加必要的头信息或者其他预处理逻辑。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">customRequestInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> template -&gt; &#123;</span><br><span class="line">        <span class="comment">// 添加必要的预处理逻辑</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>错误处理器</strong>：实现自定义的 <code>ErrorDecoder</code> 来处理不同类型的错误响应。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ErrorDecoder <span class="title function_">errorDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomBlockchainErrorDecoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h3 id="6-测试与调试"   >          <a href="#6-测试与调试" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-测试与调试" class="headerlink" title="6. 测试与调试"></a>6. 测试与调试</h3>      <p>完成上述步骤后，确保对你的 Feign 客户端进行全面的测试，以验证它是否能够正确地与区块链节点进行交互，并处理各种异常情况。</p>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>      <p>虽然 Feign 主要是为了简化 HTTP 请求而设计的，但通过创建自定义的 <code>Client</code> 实现，你可以使其适应其他协议的需求。关键在于理解 Feign 的插件化架构，并利用其提供的扩展点来插入适合特定协议的实现。这样，即使在非 HTTP 请求的场景下，如区块链智能合约调用，你也能享受到 Feign 带来的便捷性和一致性。</p>]]></content>
    
    
    <summary type="html">Feign定制化开发指南</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Feign" scheme="https://ljd0620.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix的熔断机制</title>
    <link href="https://ljd0620.github.io/2024/03/01/Hystrix%E7%9A%84%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
    <id>https://ljd0620.github.io/2024/03/01/Hystrix%E7%9A%84%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2024-03-01T04:21:36.000Z</published>
    <updated>2025-03-19T02:02:10.228Z</updated>
    
    <content type="html"><![CDATA[<p>Hystrix通过监控请求的成功与失败情况，动态调整熔断器的状态。以下是Hystrix熔断器关闭的具体条件和机制：</p><hr>        <h3 id="1-熔断器的三种状态"   >          <a href="#1-熔断器的三种状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-熔断器的三种状态" class="headerlink" title="1. 熔断器的三种状态"></a><strong>1. 熔断器的三种状态</strong></h3>      <p>Hystrix熔断器有三种状态：</p><ol><li><p><strong>Closed（关闭状态）</strong>：</p><ul><li>默认状态，允许请求通过。</li><li>Hystrix会统计请求的成功与失败情况。</li></ul></li><li><p><strong>Open（打开状态）</strong>：</p><ul><li>当失败率达到阈值时，熔断器会进入打开状态。</li><li>在打开状态下，所有请求都会被快速失败（直接调用降级逻辑），不会尝试执行实际逻辑。</li></ul></li><li><p><strong>Half-Open（半开状态）</strong>：</p><ul><li>熔断器在打开状态一段时间后，会尝试进入半开状态。</li><li>在半开状态下，允许部分请求通过，用于检测后端服务是否恢复。</li></ul></li></ol><hr>        <h3 id="2-熔断器关闭的条件"   >          <a href="#2-熔断器关闭的条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-熔断器关闭的条件" class="headerlink" title="2. 熔断器关闭的条件"></a><strong>2. 熔断器关闭的条件</strong></h3>      <p>熔断器从<strong>Open状态</strong>切换到<strong>Closed状态</strong>的条件如下：</p><ol><li><p><strong>时间窗口到期</strong>：</p><ul><li>熔断器在打开状态后会保持一段时间（默认5秒），这段时间内所有请求都会被快速失败。</li><li>当时间窗口到期后，熔断器会进入半开状态。</li></ul></li><li><p><strong>半开状态下的请求成功</strong>：</p><ul><li>在半开状态下，Hystrix会允许部分请求通过（默认是1个请求）。</li><li>如果这些请求成功，熔断器会认为后端服务已恢复，从而关闭熔断器，进入Closed状态。</li><li>如果这些请求失败，熔断器会重新进入Open状态，并继续等待下一个时间窗口。</li></ul></li></ol><hr>        <h3 id="3-相关配置参数"   >          <a href="#3-相关配置参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-相关配置参数" class="headerlink" title="3. 相关配置参数"></a><strong>3. 相关配置参数</strong></h3>      <p>Hystrix熔断器的行为可以通过以下参数进行配置：</p><ul><li><strong><code>circuitBreaker.enabled</code></strong>：是否启用熔断器（默认<code>true</code>）。</li><li><strong><code>circuitBreaker.requestVolumeThreshold</code></strong>：在时间窗口内触发熔断的最小请求数（默认20）。</li><li><strong><code>circuitBreaker.errorThresholdPercentage</code></strong>：触发熔断的失败率阈值（默认50%，即50%的请求失败会触发熔断）。</li><li><strong><code>circuitBreaker.sleepWindowInMilliseconds</code></strong>：熔断器打开后进入半开状态的时间窗口（默认5000毫秒）。</li><li><strong><code>circuitBreaker.forceClosed</code></strong>：强制关闭熔断器（默认<code>false</code>）。</li><li><strong><code>circuitBreaker.forceOpen</code></strong>：强制打开熔断器（默认<code>false</code>）。</li></ul><hr>        <h3 id="4-熔断器关闭的流程"   >          <a href="#4-熔断器关闭的流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-熔断器关闭的流程" class="headerlink" title="4. 熔断器关闭的流程"></a><strong>4. 熔断器关闭的流程</strong></h3>      <p>以下是熔断器关闭的具体流程：</p><ol><li><p><strong>熔断器打开</strong>：</p><ul><li>当失败率达到阈值时，熔断器进入Open状态，所有请求快速失败。</li></ul></li><li><p><strong>时间窗口到期</strong>：</p><ul><li>经过<code>sleepWindowInMilliseconds</code>时间后，熔断器进入Half-Open状态。</li></ul></li><li><p><strong>尝试请求</strong>：</p><ul><li>在半开状态下，允许部分请求通过，执行实际逻辑。</li></ul></li><li><p><strong>判断请求结果</strong>：</p><ul><li>如果请求成功，熔断器关闭，进入Closed状态。</li><li>如果请求失败，熔断器重新进入Open状态。</li></ul></li></ol><hr>        <h3 id="5-示例"   >          <a href="#5-示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-示例" class="headerlink" title="5. 示例"></a><strong>5. 示例</strong></h3>      <p>假设配置如下：</p><ul><li><code>circuitBreaker.requestVolumeThreshold = 20</code></li><li><code>circuitBreaker.errorThresholdPercentage = 50</code></li><li><code>circuitBreaker.sleepWindowInMilliseconds = 5000</code></li></ul><p><strong>流程</strong>：</p><ol><li>在时间窗口内，如果请求数达到20，且失败率超过50%，熔断器打开。</li><li>熔断器保持打开状态5秒，期间所有请求快速失败。</li><li>5秒后，熔断器进入半开状态，允许1个请求通过。</li><li>如果该请求成功，熔断器关闭；如果失败，熔断器重新打开。</li></ol><hr>        <h3 id="6-注意事项"   >          <a href="#6-注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a><strong>6. 注意事项</strong></h3>      <ul><li><strong>熔断器的目的是保护系统</strong>：避免因后端服务不可用导致系统雪崩。</li><li><strong>合理配置参数</strong>：根据实际业务场景调整熔断器的参数，避免过于敏感或迟钝。</li><li><strong>结合降级逻辑</strong>：在熔断器打开时，提供合理的降级逻辑，确保用户体验。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Hystrix熔断器在以下情况下会关闭：</p><ol><li>熔断器进入半开状态后，允许的请求成功执行。</li><li>熔断器的时间窗口到期，且后端服务恢复正常。</li></ol><p>通过合理配置熔断器参数，可以确保系统在高并发或后端服务不稳定的情况下仍能保持稳定运行。</p>]]></content>
    
    
    <summary type="html">Hystrix的熔断机制</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Hystrix" scheme="https://ljd0620.github.io/tags/Hystrix/"/>
    
    <category term="熔断降级" scheme="https://ljd0620.github.io/tags/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Feign的工作原理</title>
    <link href="https://ljd0620.github.io/2024/01/18/Feign%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://ljd0620.github.io/2024/01/18/Feign%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2024-01-18T04:19:02.000Z</published>
    <updated>2025-03-19T02:02:03.473Z</updated>
    
    <content type="html"><![CDATA[<p>Feign 是 Netflix 开源的一个声明式的 HTTP 客户端，旨在简化 HTTP API 的调用。它通过注解和接口定义的方式，让开发者可以像调用本地方法一样调用远程服务。Feign 的核心思想是<strong>将 HTTP 请求抽象为 Java 接口</strong>，从而隐藏了底层的 HTTP 通信细节。以下是 Feign 的工作原理及其核心机制的详细解析：</p><hr>        <h3 id="1-Feign-的核心特点"   >          <a href="#1-Feign-的核心特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Feign-的核心特点" class="headerlink" title="1. Feign 的核心特点"></a><strong>1. Feign 的核心特点</strong></h3>      <ul><li><strong>声明式 API</strong>：通过 Java 接口和注解定义 HTTP 请求。</li><li><strong>集成 Ribbon</strong>：支持客户端负载均衡。</li><li><strong>集成 Hystrix</strong>：支持熔断和降级。</li><li><strong>易于扩展</strong>：支持自定义编码器、解码器、拦截器等。</li></ul><hr>        <h3 id="2-Feign-的工作原理"   >          <a href="#2-Feign-的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Feign-的工作原理" class="headerlink" title="2. Feign 的工作原理"></a><strong>2. Feign 的工作原理</strong></h3>      <p>Feign 的工作原理可以分为以下几个步骤：</p>        <h4 id="1-定义接口"   >          <a href="#1-定义接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义接口" class="headerlink" title="(1) 定义接口"></a><strong>(1) 定义接口</strong></h4>      <p>开发者通过 Java 接口定义 HTTP 请求，使用注解描述请求的细节（如 URL、HTTP 方法、参数等）。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;user-service&quot;, url = &quot;http://localhost:8080&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-动态代理"   >          <a href="#2-动态代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-动态代理" class="headerlink" title="(2) 动态代理"></a><strong>(2) 动态代理</strong></h4>      <p>Feign 在运行时通过 <strong>JDK 动态代理</strong> 或 <strong>CGLIB</strong> 为接口生成代理对象。当调用接口方法时，代理对象会拦截方法调用，并根据注解生成 HTTP 请求。</p>        <h4 id="3-解析注解"   >          <a href="#3-解析注解" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-解析注解" class="headerlink" title="(3) 解析注解"></a><strong>(3) 解析注解</strong></h4>      <p>Feign 解析接口方法上的注解（如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PathVariable</code> 等），生成 HTTP 请求的 URL、方法、参数等信息。</p>        <h4 id="4-编码请求"   >          <a href="#4-编码请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-编码请求" class="headerlink" title="(4) 编码请求"></a><strong>(4) 编码请求</strong></h4>      <p>Feign 使用 <strong>编码器（Encoder）</strong> 将 Java 对象转换为 HTTP 请求体（如 JSON、XML 等）。</p>        <h4 id="5-发送请求"   >          <a href="#5-发送请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-发送请求" class="headerlink" title="(5) 发送请求"></a><strong>(5) 发送请求</strong></h4>      <p>Feign 使用底层的 HTTP 客户端（如 <code>java.net.HttpURLConnection</code>、<code>OkHttp</code>、<code>Apache HttpClient</code> 等）发送 HTTP 请求。</p>        <h4 id="6-解码响应"   >          <a href="#6-解码响应" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-解码响应" class="headerlink" title="(6) 解码响应"></a><strong>(6) 解码响应</strong></h4>      <p>Feign 使用 <strong>解码器（Decoder）</strong> 将 HTTP 响应体（如 JSON、XML 等）转换为 Java 对象。</p>        <h4 id="7-返回结果"   >          <a href="#7-返回结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-返回结果" class="headerlink" title="(7) 返回结果"></a><strong>(7) 返回结果</strong></h4>      <p>将解码后的结果返回给调用方。</p><hr>        <h3 id="3-Feign-的核心组件"   >          <a href="#3-Feign-的核心组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Feign-的核心组件" class="headerlink" title="3. Feign 的核心组件"></a><strong>3. Feign 的核心组件</strong></h3>      <p>Feign 的核心组件包括：</p>        <h4 id="1-注解处理器"   >          <a href="#1-注解处理器" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-注解处理器" class="headerlink" title="(1) 注解处理器"></a><strong>(1) 注解处理器</strong></h4>      <ul><li>负责解析接口方法上的注解（如 <code>@RequestLine</code>、<code>@Param</code>、<code>@Headers</code> 等）。</li><li>生成 HTTP 请求的元数据（如 URL、方法、参数等）。</li></ul>        <h4 id="2-动态代理-1"   >          <a href="#2-动态代理-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-动态代理-1" class="headerlink" title="(2) 动态代理"></a><strong>(2) 动态代理</strong></h4>      <ul><li>通过 JDK 动态代理或 CGLIB 生成接口的代理对象。</li><li>拦截方法调用并触发 HTTP 请求。</li></ul>        <h4 id="3-编码器（Encoder）"   >          <a href="#3-编码器（Encoder）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-编码器（Encoder）" class="headerlink" title="(3) 编码器（Encoder）"></a><strong>(3) 编码器（Encoder）</strong></h4>      <ul><li>将 Java 对象转换为 HTTP 请求体。</li><li>默认使用 <code>Jackson</code> 或 <code>Gson</code> 将对象编码为 JSON。</li></ul>        <h4 id="4-解码器（Decoder）"   >          <a href="#4-解码器（Decoder）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-解码器（Decoder）" class="headerlink" title="(4) 解码器（Decoder）"></a><strong>(4) 解码器（Decoder）</strong></h4>      <ul><li>将 HTTP 响应体转换为 Java 对象。</li><li>默认使用 <code>Jackson</code> 或 <code>Gson</code> 将 JSON 解码为对象。</li></ul>        <h4 id="5-HTTP-客户端"   >          <a href="#5-HTTP-客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-HTTP-客户端" class="headerlink" title="(5) HTTP 客户端"></a><strong>(5) HTTP 客户端</strong></h4>      <ul><li>负责发送 HTTP 请求。</li><li>支持多种底层实现（如 <code>java.net.HttpURLConnection</code>、<code>OkHttp</code>、<code>Apache HttpClient</code> 等）。</li></ul>        <h4 id="6-拦截器（Interceptor）"   >          <a href="#6-拦截器（Interceptor）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-拦截器（Interceptor）" class="headerlink" title="(6) 拦截器（Interceptor）"></a><strong>(6) 拦截器（Interceptor）</strong></h4>      <ul><li>在请求发送前或响应返回后执行自定义逻辑。</li><li>可以用于添加请求头、记录日志等。</li></ul>        <h4 id="7-负载均衡（Ribbon）"   >          <a href="#7-负载均衡（Ribbon）" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-负载均衡（Ribbon）" class="headerlink" title="(7) 负载均衡（Ribbon）"></a><strong>(7) 负载均衡（Ribbon）</strong></h4>      <ul><li>Feign 默认集成 Ribbon，支持客户端负载均衡。</li><li>根据服务名从注册中心获取可用实例列表，并选择其中一个实例发送请求。</li></ul>        <h4 id="8-熔断器（Hystrix）"   >          <a href="#8-熔断器（Hystrix）" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-熔断器（Hystrix）" class="headerlink" title="(8) 熔断器（Hystrix）"></a><strong>(8) 熔断器（Hystrix）</strong></h4>      <ul><li>Feign 支持集成 Hystrix，提供熔断和降级功能。</li><li>当服务调用失败时，执行降级逻辑。</li></ul><hr>        <h3 id="4-Feign-的工作流程"   >          <a href="#4-Feign-的工作流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Feign-的工作流程" class="headerlink" title="4. Feign 的工作流程"></a><strong>4. Feign 的工作流程</strong></h3>      <p>以下是 Feign 的工作流程：</p><ol><li><strong>定义接口</strong>：开发者通过 Java 接口定义 HTTP 请求。</li><li><strong>生成代理</strong>：Feign 在运行时为接口生成代理对象。</li><li><strong>解析注解</strong>：代理对象解析方法上的注解，生成 HTTP 请求元数据。</li><li><strong>编码请求</strong>：使用编码器将 Java 对象转换为 HTTP 请求体。</li><li><strong>发送请求</strong>：通过 HTTP 客户端发送请求。</li><li><strong>解码响应</strong>：使用解码器将 HTTP 响应体转换为 Java 对象。</li><li><strong>返回结果</strong>：将结果返回给调用方。</li></ol><hr>        <h3 id="5-Feign-的集成与扩展"   >          <a href="#5-Feign-的集成与扩展" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Feign-的集成与扩展" class="headerlink" title="5. Feign 的集成与扩展"></a><strong>5. Feign 的集成与扩展</strong></h3>              <h4 id="1-集成-Spring-Cloud"   >          <a href="#1-集成-Spring-Cloud" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-集成-Spring-Cloud" class="headerlink" title="(1) 集成 Spring Cloud"></a><strong>(1) 集成 Spring Cloud</strong></h4>      <ul><li>在 Spring Cloud 中，Feign 被深度集成，支持自动配置和服务发现。</li><li>通过 <code>@EnableFeignClients</code> 注解启用 Feign 客户端。</li></ul>        <h4 id="2-自定义编码器和解码器"   >          <a href="#2-自定义编码器和解码器" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-自定义编码器和解码器" class="headerlink" title="(2) 自定义编码器和解码器"></a><strong>(2) 自定义编码器和解码器</strong></h4>      <ul><li>可以通过实现 <code>Encoder</code> 和 <code>Decoder</code> 接口自定义编码器和解码器。</li></ul>        <h4 id="3-自定义拦截器"   >          <a href="#3-自定义拦截器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-自定义拦截器" class="headerlink" title="(3) 自定义拦截器"></a><strong>(3) 自定义拦截器</strong></h4>      <ul><li>可以通过实现 <code>RequestInterceptor</code> 接口自定义拦截器。</li></ul>        <h4 id="4-日志配置"   >          <a href="#4-日志配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-日志配置" class="headerlink" title="(4) 日志配置"></a><strong>(4) 日志配置</strong></h4>      <ul><li>可以通过配置 <code>Logger.Level</code> 控制 Feign 的日志级别。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="6-Feign-的优缺点"   >          <a href="#6-Feign-的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Feign-的优缺点" class="headerlink" title="6. Feign 的优缺点"></a><strong>6. Feign 的优缺点</strong></h3>              <h4 id="1-优点"   >          <a href="#1-优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-优点" class="headerlink" title="(1) 优点"></a><strong>(1) 优点</strong></h4>      <ul><li><strong>声明式调用</strong>：简化 HTTP 请求的定义和调用。</li><li><strong>集成负载均衡</strong>：默认集成 Ribbon，支持客户端负载均衡。</li><li><strong>支持熔断和降级</strong>：集成 Hystrix，提供容错能力。</li><li><strong>易于扩展</strong>：支持自定义编码器、解码器、拦截器等。</li></ul>        <h4 id="2-缺点"   >          <a href="#2-缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a><strong>(2) 缺点</strong></h4>      <ul><li><strong>性能开销</strong>：动态代理和注解解析会带来一定的性能开销。</li><li><strong>学习成本</strong>：需要熟悉 Feign 的注解和配置。</li></ul><hr>        <h3 id="7-示例代码"   >          <a href="#7-示例代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-示例代码" class="headerlink" title="7. 示例代码"></a><strong>7. 示例代码</strong></h3>      <p>以下是一个完整的 Feign 示例：</p>        <h4 id="1-定义接口-1"   >          <a href="#1-定义接口-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义接口-1" class="headerlink" title="(1) 定义接口"></a><strong>(1) 定义接口</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;user-service&quot;, url = &quot;http://localhost:8080&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-启用-Feign-客户端"   >          <a href="#2-启用-Feign-客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-启用-Feign-客户端" class="headerlink" title="(2) 启用 Feign 客户端"></a><strong>(2) 启用 Feign 客户端</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-调用-Feign-客户端"   >          <a href="#3-调用-Feign-客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-调用-Feign-客户端" class="headerlink" title="(3) 调用 Feign 客户端"></a><strong>(3) 调用 Feign 客户端</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceClient userServiceClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userServiceClient.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userServiceClient.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Feign 通过声明式 API 和动态代理机制，简化了 HTTP 请求的定义和调用。其核心组件包括注解处理器、动态代理、编码器、解码器、HTTP 客户端等。Feign 默认集成 Ribbon 和 Hystrix，支持负载均衡和熔断降级。理解 Feign 的工作原理及其核心机制，有助于更好地使用和扩展 Feign。</p>]]></content>
    
    
    <summary type="html">Feign的工作原理</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Feign" scheme="https://ljd0620.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix的工作原理</title>
    <link href="https://ljd0620.github.io/2024/01/01/Hystrix%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://ljd0620.github.io/2024/01/01/Hystrix%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2024-01-01T04:20:08.000Z</published>
    <updated>2025-03-19T02:02:05.851Z</updated>
    
    <content type="html"><![CDATA[<p>Hystrix 是 Netflix 开源的一款容错库，主要用于处理分布式系统中的延迟和故障。其核心目标是<strong>防止雪崩效应</strong>，通过隔离、熔断、降级等机制，确保系统在部分服务不可用时仍能稳定运行。以下是 Hystrix 的工作原理及其核心机制的详细解析：</p><hr>        <h3 id="1-Hystrix-的核心目标"   >          <a href="#1-Hystrix-的核心目标" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Hystrix-的核心目标" class="headerlink" title="1. Hystrix 的核心目标"></a><strong>1. Hystrix 的核心目标</strong></h3>      <p>Hystrix 的设计目标是：</p><ol><li><strong>防止雪崩效应</strong>：通过隔离和熔断机制，避免单个服务的故障导致整个系统崩溃。</li><li><strong>快速失败</strong>：在服务不可用时，快速返回降级结果，而不是让请求长时间等待。</li><li><strong>自动恢复</strong>：当服务恢复后，自动重新尝试调用。</li></ol><hr>        <h3 id="2-Hystrix-的核心机制"   >          <a href="#2-Hystrix-的核心机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Hystrix-的核心机制" class="headerlink" title="2. Hystrix 的核心机制"></a><strong>2. Hystrix 的核心机制</strong></h3>      <p>Hystrix 通过以下核心机制实现其目标：</p>        <h4 id="1-命令模式（Command-Pattern）"   >          <a href="#1-命令模式（Command-Pattern）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-命令模式（Command-Pattern）" class="headerlink" title="(1) 命令模式（Command Pattern）"></a><strong>(1) 命令模式（Command Pattern）</strong></h4>      <ul><li>Hystrix 将每个外部调用封装为一个 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code> 对象。</li><li>通过命令模式，Hystrix 可以对每个调用进行隔离、监控和控制。</li></ul>        <h4 id="2-线程池隔离（Thread-Pool-Isolation）"   >          <a href="#2-线程池隔离（Thread-Pool-Isolation）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-线程池隔离（Thread-Pool-Isolation）" class="headerlink" title="(2) 线程池隔离（Thread Pool Isolation）"></a><strong>(2) 线程池隔离（Thread Pool Isolation）</strong></h4>      <ul><li>Hystrix 为每个依赖服务分配独立的线程池，避免某个服务的故障影响其他服务。</li><li>默认情况下，Hystrix 使用线程池隔离，但也可以配置为信号量隔离。</li></ul>        <h4 id="3-熔断器（Circuit-Breaker）"   >          <a href="#3-熔断器（Circuit-Breaker）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-熔断器（Circuit-Breaker）" class="headerlink" title="(3) 熔断器（Circuit Breaker）"></a><strong>(3) 熔断器（Circuit Breaker）</strong></h4>      <ul><li>Hystrix 通过熔断器机制监控请求的成功与失败情况。</li><li>当失败率达到阈值时，熔断器打开，所有请求快速失败。</li><li>经过一段时间后，熔断器进入半开状态，允许部分请求通过以检测服务是否恢复。</li></ul>        <h4 id="4-降级（Fallback）"   >          <a href="#4-降级（Fallback）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-降级（Fallback）" class="headerlink" title="(4) 降级（Fallback）"></a><strong>(4) 降级（Fallback）</strong></h4>      <ul><li>当请求失败或熔断器打开时，Hystrix 会执行降级逻辑，返回一个默认值或错误信息。</li><li>降级逻辑可以是一个静态值、缓存数据或调用其他服务。</li></ul>        <h4 id="5-请求缓存（Request-Caching）"   >          <a href="#5-请求缓存（Request-Caching）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-请求缓存（Request-Caching）" class="headerlink" title="(5) 请求缓存（Request Caching）"></a><strong>(5) 请求缓存（Request Caching）</strong></h4>      <ul><li>Hystrix 支持对请求结果进行缓存，减少重复请求的开销。</li><li>缓存的生命周期与请求一致，请求结束后缓存失效。</li></ul>        <h4 id="6-请求合并（Request-Collapsing）"   >          <a href="#6-请求合并（Request-Collapsing）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-请求合并（Request-Collapsing）" class="headerlink" title="(6) 请求合并（Request Collapsing）"></a><strong>(6) 请求合并（Request Collapsing）</strong></h4>      <ul><li>Hystrix 支持将多个请求合并为一个批量请求，减少网络开销。</li><li>适用于高并发场景。</li></ul>        <h4 id="7-实时监控（Real-time-Monitoring）"   >          <a href="#7-实时监控（Real-time-Monitoring）" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-实时监控（Real-time-Monitoring）" class="headerlink" title="(7) 实时监控（Real-time Monitoring）"></a><strong>(7) 实时监控（Real-time Monitoring）</strong></h4>      <ul><li>Hystrix 提供了实时的监控数据，包括请求量、失败率、熔断器状态等。</li><li>可以通过 Hystrix Dashboard 或 Turbine 查看监控数据。</li></ul><hr>        <h3 id="3-Hystrix-的工作流程"   >          <a href="#3-Hystrix-的工作流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Hystrix-的工作流程" class="headerlink" title="3. Hystrix 的工作流程"></a><strong>3. Hystrix 的工作流程</strong></h3>      <p>以下是 Hystrix 的工作流程：</p><ol><li><p><strong>封装请求</strong>：</p><ul><li>将每个外部调用封装为 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code>。</li></ul></li><li><p><strong>检查熔断器状态</strong>：</p><ul><li>如果熔断器打开，直接执行降级逻辑。</li><li>如果熔断器关闭，继续执行下一步。</li></ul></li><li><p><strong>检查线程池&#x2F;信号量资源</strong>：</p><ul><li>如果线程池或信号量资源已满，拒绝请求并执行降级逻辑。</li><li>如果资源可用，继续执行下一步。</li></ul></li><li><p><strong>执行请求</strong>：</p><ul><li>调用外部服务，获取结果。</li></ul></li><li><p><strong>统计请求结果</strong>：</p><ul><li>根据请求的成功与失败情况，更新熔断器的统计信息。</li></ul></li><li><p><strong>返回结果或降级</strong>：</p><ul><li>如果请求成功，返回结果。</li><li>如果请求失败或超时，执行降级逻辑。</li></ul></li><li><p><strong>更新熔断器状态</strong>：</p><ul><li>根据统计信息，决定是否打开或关闭熔断器。</li></ul></li></ol><hr>        <h3 id="4-Hystrix-的核心配置"   >          <a href="#4-Hystrix-的核心配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Hystrix-的核心配置" class="headerlink" title="4. Hystrix 的核心配置"></a><strong>4. Hystrix 的核心配置</strong></h3>      <p>Hystrix 的行为可以通过以下配置参数进行调整：</p><div class="table-container"><table><thead><tr><th>参数名</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>execution.isolation.strategy</code></td><td><code>THREAD</code></td><td>隔离策略（<code>THREAD</code> 或 <code>SEMAPHORE</code>）。</td></tr><tr><td><code>execution.isolation.thread.timeoutInMilliseconds</code></td><td><code>1000</code></td><td>请求超时时间（毫秒）。</td></tr><tr><td><code>circuitBreaker.enabled</code></td><td><code>true</code></td><td>是否启用熔断器。</td></tr><tr><td><code>circuitBreaker.requestVolumeThreshold</code></td><td><code>20</code></td><td>在时间窗口内触发熔断的最小请求数。</td></tr><tr><td><code>circuitBreaker.errorThresholdPercentage</code></td><td><code>50</code></td><td>触发熔断的失败率阈值（百分比）。</td></tr><tr><td><code>circuitBreaker.sleepWindowInMilliseconds</code></td><td><code>5000</code></td><td>熔断器打开后进入半开状态的时间窗口（毫秒）。</td></tr><tr><td><code>fallback.enabled</code></td><td><code>true</code></td><td>是否启用降级逻辑。</td></tr><tr><td><code>metrics.rollingStats.timeInMilliseconds</code></td><td><code>10000</code></td><td>统计时间窗口（毫秒）。</td></tr></tbody></table></div><hr>        <h3 id="5-Hystrix-的示例代码"   >          <a href="#5-Hystrix-的示例代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Hystrix-的示例代码" class="headerlink" title="5. Hystrix 的示例代码"></a><strong>5. Hystrix 的示例代码</strong></h3>      <p>以下是一个简单的 Hystrix 示例：</p>        <h4 id="1-定义-HystrixCommand"   >          <a href="#1-定义-HystrixCommand" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义-HystrixCommand" class="headerlink" title="(1) 定义 HystrixCommand"></a><strong>(1) 定义 HystrixCommand</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCommand</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserCommand</span><span class="params">(UserService userService, Long userId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;UserGroup&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">getFallback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1L</span>, <span class="string">&quot;Fallback User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-使用-HystrixCommand"   >          <a href="#2-使用-HystrixCommand" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用-HystrixCommand" class="headerlink" title="(2) 使用 HystrixCommand"></a><strong>(2) 使用 HystrixCommand</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCommand</span>(userService, <span class="number">1L</span>).execute();</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="6-Hystrix-的优缺点"   >          <a href="#6-Hystrix-的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Hystrix-的优缺点" class="headerlink" title="6. Hystrix 的优缺点"></a><strong>6. Hystrix 的优缺点</strong></h3>              <h4 id="1-优点"   >          <a href="#1-优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-优点" class="headerlink" title="(1) 优点"></a><strong>(1) 优点</strong></h4>      <ul><li><strong>防止雪崩效应</strong>：通过隔离和熔断机制，避免系统崩溃。</li><li><strong>快速失败</strong>：在服务不可用时，快速返回降级结果。</li><li><strong>自动恢复</strong>：当服务恢复后，自动重新尝试调用。</li><li><strong>实时监控</strong>：提供丰富的监控数据，便于问题排查。</li></ul>        <h4 id="2-缺点"   >          <a href="#2-缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a><strong>(2) 缺点</strong></h4>      <ul><li><strong>配置复杂</strong>：需要根据业务场景调整大量参数。</li><li><strong>性能开销</strong>：线程池隔离和熔断器机制会带来一定的性能开销。</li><li><strong>已停止维护</strong>：Hystrix 已停止维护，建议使用 Resilience4j 等替代方案。</li></ul><hr>        <h3 id="7-Hystrix-的替代方案"   >          <a href="#7-Hystrix-的替代方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-Hystrix-的替代方案" class="headerlink" title="7. Hystrix 的替代方案"></a><strong>7. Hystrix 的替代方案</strong></h3>      <p>由于 Hystrix 已停止维护，以下是一些常见的替代方案：</p><ol><li><p><strong>Resilience4j</strong>：</p><ul><li>轻量级的容错库，支持熔断、限流、重试等功能。</li><li>与 Spring Cloud 集成良好。</li></ul></li><li><p><strong>Sentinel</strong>：</p><ul><li>阿里巴巴开源的流量控制和熔断降级框架。</li><li>支持实时监控和动态配置。</li></ul></li><li><p><strong>Spring Cloud Circuit Breaker</strong>：</p><ul><li>Spring Cloud 提供的统一熔断器抽象，支持多种实现（如 Resilience4j、Sentinel 等）。</li></ul></li></ol><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Hystrix 通过命令模式、线程池隔离、熔断器、降级等机制，有效防止了分布式系统中的雪崩效应。其核心思想是快速失败和自动恢复，确保系统在高并发或服务故障时仍能稳定运行。尽管 Hystrix 已停止维护，但其设计思想和实现机制仍然值得学习和借鉴。</p>]]></content>
    
    
    <summary type="html">Hystrix的工作原理</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Hystrix" scheme="https://ljd0620.github.io/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch深度分页优化</title>
    <link href="https://ljd0620.github.io/2023/12/12/Elasticsearch%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/"/>
    <id>https://ljd0620.github.io/2023/12/12/Elasticsearch%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/</id>
    <published>2023-12-12T04:32:39.000Z</published>
    <updated>2025-03-19T02:01:50.700Z</updated>
    
    <content type="html"><![CDATA[<p>在 Elasticsearch 中，深度分页（Deep Pagination）是指查询结果的分页参数 <code>from</code> 值较大的情况（例如 <code>from=10000</code>）。深度分页会导致性能问题，因为 Elasticsearch 需要从每个分片中获取大量的文档，并在协调节点上合并和排序这些文档，这会消耗大量的内存和 CPU 资源。以下是优化 Elasticsearch 深度分页性能的几种常见策略：</p><hr>        <h3 id="1-避免深度分页"   >          <a href="#1-避免深度分页" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-避免深度分页" class="headerlink" title="1. 避免深度分页"></a><strong>1. 避免深度分页</strong></h3>      <p>深度分页通常不是用户实际需要的场景。可以通过以下方式避免深度分页：</p><ul><li><strong>限制分页深度</strong>：<ul><li>在前端或 API 层面限制 <code>from</code> 的最大值（例如 <code>from &lt;= 1000</code>）。</li></ul></li><li><strong>优化用户体验</strong>：<ul><li>提供更精确的搜索条件，减少结果集的大小。</li><li>使用排序和过滤条件，帮助用户快速定位所需数据。</li></ul></li></ul><hr>        <h3 id="2-使用-search-after-参数"   >          <a href="#2-使用-search-after-参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用-search-after-参数" class="headerlink" title="2. 使用 search_after 参数"></a><strong>2. 使用 <code>search_after</code> 参数</strong></h3>      <p><code>search_after</code> 是一种基于游标的分页方式，适合深度分页场景。它通过指定上一页最后一条记录的排序值来获取下一页数据，避免了传统分页的性能问题。</p>        <h4 id="使用方法："   >          <a href="#使用方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>在查询中指定排序字段（必须包含唯一字段，如 <code>_id</code>）。</li><li>使用 <code>search_after</code> 参数传递上一页最后一条记录的排序值。</li></ol>        <h4 id="示例："   >          <a href="#示例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1696166400000</span><span class="punctuation">,</span> <span class="string">&quot;abc123&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点："   >          <a href="#优点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>避免了传统分页的性能瓶颈。</li><li>适合深度分页和实时数据查询。</li></ul>        <h4 id="缺点："   >          <a href="#缺点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>需要客户端维护游标状态。</li><li>不支持跳转到任意页码。</li></ul><hr>        <h3 id="3-使用滚动查询（Scroll-API）"   >          <a href="#3-使用滚动查询（Scroll-API）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-使用滚动查询（Scroll-API）" class="headerlink" title="3. 使用滚动查询（Scroll API）"></a><strong>3. 使用滚动查询（Scroll API）</strong></h3>      <p>滚动查询（Scroll API）适合一次性获取大量数据的场景（如数据导出）。它通过创建一个快照（Snapshot）来保持查询的上下文，允许分批次获取数据。</p>        <h4 id="使用方法：-1"   >          <a href="#使用方法：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：-1" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>初始化滚动查询，设置滚动时间窗口（如 <code>1m</code>）。</li><li>使用 <code>scroll_id</code> 获取下一批数据。</li></ol>        <h4 id="示例：-1"   >          <a href="#示例：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <p>初始化滚动查询：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /my_index/_search?scroll=<span class="number">1</span>m</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure><p>获取下一批数据：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_search/scroll</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scroll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scroll_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAABIFj...&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点：-1"   >          <a href="#优点：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>适合一次性获取大量数据的场景。</li><li>避免了深度分页的性能问题。</li></ul>        <h4 id="缺点：-1"   >          <a href="#缺点：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-1" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>滚动查询会占用资源，直到滚动时间窗口过期。</li><li>不适合实时分页场景。</li></ul><hr>        <h3 id="4-使用-Point-In-Time（PIT）"   >          <a href="#4-使用-Point-In-Time（PIT）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-使用-Point-In-Time（PIT）" class="headerlink" title="4. 使用 Point In Time（PIT）"></a><strong>4. 使用 <code>Point In Time</code>（PIT）</strong></h3>      <p><code>Point In Time</code>（PIT）是 Elasticsearch 7.10 引入的功能，用于在滚动查询的基础上提供更高效的分页方式。它通过创建一个时间点视图（Point-in-Time View），允许在固定的数据视图上进行分页。</p>        <h4 id="使用方法：-2"   >          <a href="#使用方法：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：-2" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>创建一个 PIT。</li><li>使用 <code>search_after</code> 和 PIT 进行分页。</li></ol>        <h4 id="示例：-2"   >          <a href="#示例：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <p>创建 PIT：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /my_index/_pit?keep_alive=<span class="number">1</span>m</span><br></pre></td></tr></table></div></figure><p>使用 PIT 和 <code>search_after</code> 分页：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;pit&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keep_alive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1696166400000</span><span class="punctuation">,</span> <span class="string">&quot;abc123&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点：-2"   >          <a href="#优点：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-2" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>提供更高效的分页方式。</li><li>适合实时分页场景。</li></ul>        <h4 id="缺点：-2"   >          <a href="#缺点：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-2" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>需要 Elasticsearch 7.10 及以上版本。</li></ul><hr>        <h3 id="5-使用-slice-分片查询"   >          <a href="#5-使用-slice-分片查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-使用-slice-分片查询" class="headerlink" title="5. 使用 slice 分片查询"></a><strong>5. 使用 <code>slice</code> 分片查询</strong></h3>      <p><code>slice</code> 分片查询允许将查询分成多个子查询，每个子查询处理数据的一个子集。通过并行执行这些子查询，可以提高查询性能。</p>        <h4 id="使用方法：-3"   >          <a href="#使用方法：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：-3" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>指定 <code>slice</code> 参数，将查询分成多个子查询。</li><li>并行执行这些子查询。</li></ol>        <h4 id="示例：-3"   >          <a href="#示例：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-3" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;slice&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点：-3"   >          <a href="#优点：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-3" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>提高查询性能，适合大数据集。</li><li>可以并行执行多个子查询。</li></ul>        <h4 id="缺点：-3"   >          <a href="#缺点：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-3" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>需要客户端合并多个子查询的结果。</li><li>不适合实时分页场景。</li></ul><hr>        <h3 id="6-优化索引设计"   >          <a href="#6-优化索引设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-优化索引设计" class="headerlink" title="6. 优化索引设计"></a><strong>6. 优化索引设计</strong></h3>      <p>通过优化索引设计，可以减少查询时需要扫描的数据量，提高查询性能。</p>        <h4 id="优化策略："   >          <a href="#优化策略：" class="heading-link"><i class="fas fa-link"></i></a><a href="#优化策略：" class="headerlink" title="优化策略："></a><strong>优化策略</strong>：</h4>      <ul><li><strong>使用合适的字段类型</strong>：<ul><li>选择合适的数据类型（如 <code>keyword</code>、<code>text</code>、<code>date</code> 等），避免不必要的分词和分析。</li></ul></li><li><strong>使用过滤条件</strong>：<ul><li>在查询中添加过滤条件，减少需要扫描的数据量。</li></ul></li><li><strong>使用索引模板</strong>：<ul><li>使用索引模板统一管理索引的配置和映射。</li></ul></li></ul><hr>        <h3 id="7-使用缓存"   >          <a href="#7-使用缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-使用缓存" class="headerlink" title="7. 使用缓存"></a><strong>7. 使用缓存</strong></h3>      <p>对于不经常变化的数据，可以使用缓存（如 Redis）来存储分页结果，减少 Elasticsearch 的查询压力。</p>        <h4 id="示例：-4"   >          <a href="#示例：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-4" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <ol><li>将查询结果缓存到 Redis 中。</li><li>从缓存中获取分页数据。</li></ol>        <h4 id="优点：-4"   >          <a href="#优点：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-4" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>减少 Elasticsearch 的查询压力。</li><li>提高查询性能。</li></ul>        <h4 id="缺点：-4"   >          <a href="#缺点：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-4" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>数据变化时需要更新缓存。</li><li>适合不经常变化的数据。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>优化 Elasticsearch 深度分页性能的常见策略包括：</p><ol><li><strong>避免深度分页</strong>：限制分页深度，优化用户体验。</li><li><strong>使用 <code>search_after</code></strong>：适合深度分页和实时数据查询。</li><li><strong>使用滚动查询（Scroll API）</strong>：适合一次性获取大量数据的场景。</li><li><strong>使用 <code>Point In Time</code>（PIT）</strong>：提供更高效的分页方式，适合实时分页场景。</li><li><strong>使用 <code>slice</code> 分片查询</strong>：提高查询性能，适合大数据集。</li><li><strong>优化索引设计</strong>：减少查询时需要扫描的数据量。</li><li><strong>使用缓存</strong>：减少 Elasticsearch 的查询压力，适合不经常变化的数据。</li></ol><p>根据具体的业务场景和数据特点，选择合适的优化策略，可以显著提高 Elasticsearch 深度分页的性能。</p>]]></content>
    
    
    <summary type="html">Elasticsearch深度分页优化</summary>
    
    
    
    <category term="搜索引擎" scheme="https://ljd0620.github.io/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://ljd0620.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
</feed>
