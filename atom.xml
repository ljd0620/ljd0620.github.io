<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just Do IT.</title>
  
  
  <link href="https://ljd0620.github.io/atom.xml" rel="self"/>
  
  <link href="https://ljd0620.github.io/"/>
  <updated>2025-03-19T07:26:21.506Z</updated>
  <id>https://ljd0620.github.io/</id>
  
  <author>
    <name>Liujiduo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MQTT协议原理及应用</title>
    <link href="https://ljd0620.github.io/2025/03/19/MQTT%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://ljd0620.github.io/2025/03/19/MQTT%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2025-03-19T07:24:49.000Z</published>
    <updated>2025-03-19T07:26:21.506Z</updated>
    
    <content type="html"><![CDATA[<p>MQTT（Message Queuing Telemetry Transport）是一种基于<strong>发布&#x2F;订阅（Pub-Sub）模式</strong>的轻量级消息传输协议，专为<strong>低带宽、不可靠网络环境</strong>或<strong>资源受限设备</strong>设计。它广泛应用于物联网（IoT）、实时通信、传感器网络等领域。</p><hr>        <h3 id="一、MQTT协议核心原理"   >          <a href="#一、MQTT协议核心原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、MQTT协议核心原理" class="headerlink" title="一、MQTT协议核心原理"></a>一、MQTT协议核心原理</h3>              <h4 id="1-协议定位"   >          <a href="#1-协议定位" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-协议定位" class="headerlink" title="1. 协议定位"></a>1. <strong>协议定位</strong></h4>      <ul><li><strong>轻量级</strong>：专为低带宽、高延迟或不可靠网络设计，报文头最小仅2字节。</li><li><strong>发布&#x2F;订阅模型</strong>：解耦消息生产者（Publisher）与消费者（Subscriber），通过主题（Topic）路由消息。</li><li><strong>TCP&#x2F;IP基础</strong>：基于TCP长连接，默认端口1883（非加密）&#x2F;8883（SSL加密）。</li></ul>        <h4 id="2-核心组件"   >          <a href="#2-核心组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-核心组件" class="headerlink" title="2. 核心组件"></a>2. <strong>核心组件</strong></h4>      <div class="table-container"><table><thead><tr><th>组件</th><th>功能描述</th></tr></thead><tbody><tr><td><strong>Broker</strong></td><td>消息代理服务器，负责消息路由、客户端管理和会话状态维护（如EMQX、Mosquitto）</td></tr><tr><td><strong>Publisher</strong></td><td>消息发布者，向指定主题发送数据</td></tr><tr><td><strong>Subscriber</strong></td><td>消息订阅者，通过订阅主题接收数据</td></tr><tr><td><strong>Topic</strong></td><td>分层结构的消息路由标识（如<code>iot/device001/temperature</code>）</td></tr></tbody></table></div>        <h4 id="3-QoS等级"   >          <a href="#3-QoS等级" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-QoS等级" class="headerlink" title="3. QoS等级"></a>3. <strong>QoS等级</strong></h4>      <div class="table-container"><table><thead><tr><th>QoS级别</th><th>可靠性保障机制</th><th>网络开销</th><th>典型场景</th></tr></thead><tbody><tr><td>0</td><td>至多一次（At most once）</td><td>最低</td><td>传感器数据上报（允许丢失）</td></tr><tr><td>1</td><td>至少一次（At least once）</td><td>中等</td><td>设备控制指令（需确认）</td></tr><tr><td>2</td><td>恰好一次（Exactly once）</td><td>最高</td><td>支付交易（严格一致性）</td></tr></tbody></table></div>        <h4 id="4-会话机制"   >          <a href="#4-会话机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-会话机制" class="headerlink" title="4. 会话机制"></a>4. <strong>会话机制</strong></h4>      <ul><li><strong>Clean Session</strong>：<ul><li><code>true</code>：客户端断开后删除会话状态，适合临时设备。</li><li><code>false</code>：保留订阅列表和未确认消息（QoS 1&#x2F;2），支持断线重连后恢复。</li></ul></li><li><strong>Last Will（遗嘱消息）</strong>：客户端异常断开时，Broker自动发布预设消息。</li></ul><hr>        <h3 id="二、MQTT协议工作流程（时序图）"   >          <a href="#二、MQTT协议工作流程（时序图）" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、MQTT协议工作流程（时序图）" class="headerlink" title="二、MQTT协议工作流程（时序图）"></a>二、MQTT协议工作流程（时序图）</h3>      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">participant Publisher as P</span><br><span class="line">participant Broker as B</span><br><span class="line">participant Subscriber as S</span><br><span class="line"></span><br><span class="line">P -&gt; B: CONNECT (clientId=pub1)</span><br><span class="line">B --&gt; P: CONNACK (success)</span><br><span class="line"></span><br><span class="line">S -&gt; B: CONNECT (clientId=sub1)</span><br><span class="line">B --&gt; S: CONNACK (success)</span><br><span class="line">S -&gt; B: SUBSCRIBE (topic=iot/+/temp, QoS=1)</span><br><span class="line">B --&gt; S: SUBACK (QoS=1 granted)</span><br><span class="line"></span><br><span class="line">P -&gt; B: PUBLISH (topic=iot/device001/temp, payload=25.6, QoS=1)</span><br><span class="line">B -&gt; S: PUBLISH (topic=iot/device001/temp, payload=25.6, QoS=1)</span><br><span class="line">S -&gt; B: PUBACK (messageId=1)</span><br><span class="line">B -&gt; P: PUBACK (messageId=1)</span><br><span class="line">@enduml</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="三、典型应用场景"   >          <a href="#三、典型应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、典型应用场景" class="headerlink" title="三、典型应用场景"></a>三、典型应用场景</h3>              <h4 id="1-物联网设备通信"   >          <a href="#1-物联网设备通信" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-物联网设备通信" class="headerlink" title="1. 物联网设备通信"></a>1. <strong>物联网设备通信</strong></h4>      <ul><li><strong>场景特点</strong>：海量设备、低功耗、弱网络环境。</li><li><strong>技术实现</strong>：<ul><li>设备通过MQTT上报传感器数据（QoS 0）。</li><li>云端下发控制指令（QoS 1）：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Eclipse Paho发送控制指令</span></span><br><span class="line"><span class="type">MqttMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MqttMessage</span>(<span class="string">&quot;ON&quot;</span>.getBytes());</span><br><span class="line">message.setQos(<span class="number">1</span>);</span><br><span class="line">client.publish(<span class="string">&quot;iot/device001/switch&quot;</span>, message);</span><br></pre></td></tr></table></div></figure></li></ul></li><li><strong>优势</strong>：支持设备离线消息缓存（QoS 1&#x2F;2），适应网络波动。</li></ul>        <h4 id="2-移动端消息推送"   >          <a href="#2-移动端消息推送" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-移动端消息推送" class="headerlink" title="2. 移动端消息推送"></a>2. <strong>移动端消息推送</strong></h4>      <ul><li><strong>场景特点</strong>：需保持长连接、节省电量。</li><li><strong>技术实现</strong>：<ul><li>客户端订阅用户专属主题（如<code>user/12345/notify</code>）。</li><li>服务端触发推送时发布到对应主题：<figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python示例（使用paho-mqtt）</span></span><br><span class="line">client.publish(<span class="string">&quot;user/12345/notify&quot;</span>, <span class="string">&quot;New message&quot;</span>, qos=<span class="number">1</span>)</span><br></pre></td></tr></table></div></figure></li></ul></li><li><strong>优势</strong>：相比HTTP轮询，降低网络流量和服务器压力。</li></ul>        <h4 id="3-实时监控系统"   >          <a href="#3-实时监控系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-实时监控系统" class="headerlink" title="3. 实时监控系统"></a>3. <strong>实时监控系统</strong></h4>      <ul><li><strong>场景特点</strong>：数据高频更新、多终端同步。</li><li><strong>技术实现</strong>：<ul><li>使用通配符订阅（<code>#</code>多级，<code>+</code>单级）：<figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订阅所有温度数据</span></span><br><span class="line">SUBSCRIBE iot<span class="operator">/</span><span class="operator">+</span><span class="operator">/</span>temperature</span><br></pre></td></tr></table></div></figure></li><li>Broker集群部署（如EMQX集群），支撑百万级并发连接。</li></ul></li></ul>        <h4 id="4-车联网（V2X）"   >          <a href="#4-车联网（V2X）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-车联网（V2X）" class="headerlink" title="4. 车联网（V2X）"></a>4. <strong>车联网（V2X）</strong></h4>      <ul><li><strong>场景特点</strong>：低延迟、高可靠性。</li><li><strong>技术实现</strong>：<ul><li>车辆发布实时状态（位置&#x2F;速度）到<code>v2x/car001/status</code>。</li><li>边缘计算节点订阅数据，触发碰撞预警：<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++示例（使用MQTTAsync）</span></span><br><span class="line">MQTTAsync_responseOptions opts = MQTTAsync_responseOptions_initializer;</span><br><span class="line">opts.onSuccess = onPublishSuccess;</span><br><span class="line"><span class="built_in">MQTTAsync_send</span>(client, <span class="string">&quot;v2x/car001/status&quot;</span>, <span class="built_in">strlen</span>(data), data, <span class="number">2</span>, <span class="number">0</span>, &amp;opts);</span><br></pre></td></tr></table></div></figure></li></ul></li></ul><hr>        <h3 id="四、MQTT-5-0增强特性"   >          <a href="#四、MQTT-5-0增强特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、MQTT-5-0增强特性" class="headerlink" title="四、MQTT 5.0增强特性"></a>四、MQTT 5.0增强特性</h3>      <div class="table-container"><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td><strong>会话过期</strong></td><td>客户端可设置会话过期时间（Session Expiry Interval），优化资源管理</td></tr><tr><td><strong>原因码</strong></td><td>精细化错误反馈（如0x81表示协议版本不支持）</td></tr><tr><td><strong>共享订阅</strong></td><td>实现负载均衡（<code>$share/group1/topic</code>），避免单个消费者过载</td></tr><tr><td><strong>消息过期</strong></td><td>设置消息的生存时间（Message Expiry Interval），自动清理过期数据</td></tr></tbody></table></div><hr>        <h3 id="五、与同类协议对比"   >          <a href="#五、与同类协议对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、与同类协议对比" class="headerlink" title="五、与同类协议对比"></a>五、与同类协议对比</h3>      <div class="table-container"><table><thead><tr><th>协议</th><th>传输层</th><th>消息模型</th><th>头部开销</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>MQTT</strong></td><td>TCP</td><td>发布&#x2F;订阅</td><td>2-4字节</td><td>物联网、移动推送</td></tr><tr><td><strong>CoAP</strong></td><td>UDP</td><td>请求&#x2F;响应</td><td>4字节</td><td>受限设备（如NB-IoT）</td></tr><tr><td><strong>AMQP</strong></td><td>TCP</td><td>队列&#x2F;路由</td><td>8字节</td><td>企业级消息中间件</td></tr><tr><td><strong>HTTP</strong></td><td>TCP</td><td>请求&#x2F;响应</td><td>100+字节</td><td>RESTful API通信</td></tr></tbody></table></div><hr>        <h3 id="六、安全机制"   >          <a href="#六、安全机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、安全机制" class="headerlink" title="六、安全机制"></a>六、安全机制</h3>      <ol><li><p><strong>认证授权</strong>：</p><ul><li>用户名密码认证（PLAIN&#x2F;SCRAM-SHA-1）。</li><li>客户端证书双向认证（TLS）。</li><li>集成OAuth 2.0（如EMQX企业版）。</li></ul></li><li><p><strong>传输加密</strong>：</p><ul><li>TLS 1.3加密通信（默认端口8883）。</li><li>PSK（Pre-Shared Key）模式，适用于资源受限设备。</li></ul></li><li><p><strong>权限控制</strong>：</p><ul><li>ACL规则限制客户端发布&#x2F;订阅权限：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EMQX ACL示例</span></span><br><span class="line">&#123;allow, &#123;user, <span class="string">&quot;admin&quot;</span>&#125;, pubsub, [<span class="string">&quot;<span class="variable">$SYS</span>/#&quot;</span>]&#125;.</span><br><span class="line">&#123;deny, all, subscribe, [<span class="string">&quot;<span class="variable">$SYS</span>/#&quot;</span>]&#125;.</span><br></pre></td></tr></table></div></figure></li></ul></li></ol><hr>        <h3 id="七、实战建议"   >          <a href="#七、实战建议" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、实战建议" class="headerlink" title="七、实战建议"></a>七、实战建议</h3>      <ol><li><p><strong>Broker选型</strong>：</p><ul><li>开源方案：EMQX（支持集群）、Mosquitto（轻量级）。</li><li>商业方案：AWS IoT Core、Azure IoT Hub。</li></ul></li><li><p><strong>客户端库推荐</strong>：</p><ul><li>Java：Eclipse Paho <code>org.eclipse.paho:org.eclipse.paho.client.mqttv3</code></li><li>Python：<code>paho-mqtt</code></li><li>C&#x2F;C++：Eclipse Paho C库</li></ul></li><li><p><strong>性能调优</strong>：</p><ul><li>启用WebSocket支持（端口8083&#x2F;8084），方便浏览器集成。</li><li>配置持久化存储（如Redis&#x2F;MySQL），保障QoS 1&#x2F;2消息不丢失。</li><li>使用共享订阅实现消费者负载均衡。</li></ul></li></ol><hr><p>通过合理应用MQTT协议，可有效解决物联网场景下的海量连接、弱网通信和实时数据同步问题，建议结合具体业务需求选择合适的QoS级别和安全策略。</p>]]></content>
    
    
    <summary type="html">MQTT协议原理及应用</summary>
    
    
    
    <category term="物联网" scheme="https://ljd0620.github.io/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
    <category term="MQTT" scheme="https://ljd0620.github.io/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>Kafka工作原理详解</title>
    <link href="https://ljd0620.github.io/2024/07/18/Kafka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/"/>
    <id>https://ljd0620.github.io/2024/07/18/Kafka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-07-18T04:23:44.000Z</published>
    <updated>2025-03-19T01:59:27.540Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Kafka 是一个分布式流处理平台，专为高吞吐、低延迟的实时数据传输设计。以下是其核心工作原理的分层解析：</p><hr>        <h3 id="一、核心架构组件"   >          <a href="#一、核心架构组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、核心架构组件" class="headerlink" title="一、核心架构组件"></a>一、核心架构组件</h3>              <h4 id="1-Broker（代理节点）"   >          <a href="#1-Broker（代理节点）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Broker（代理节点）" class="headerlink" title="1. Broker（代理节点）"></a>1. <strong>Broker（代理节点）</strong></h4>      <p>• <strong>角色</strong>：Kafka 集群中的单台服务器，负责数据存储和消息传递。<br>• <strong>集群模式</strong>：多个 Broker 组成集群，每个 Broker 通过唯一 ID 标识，支持动态扩容。<br>• <strong>数据存储</strong>：每个 Broker 存储多个 <strong>Topic（主题）</strong> 的分区（Partition）副本。</p>        <h4 id="2-Topic（主题）"   >          <a href="#2-Topic（主题）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Topic（主题）" class="headerlink" title="2. Topic（主题）"></a>2. <strong>Topic（主题）</strong></h4>      <p>• <strong>逻辑分类</strong>：消息的类别标识（如 <code>user_click</code>、<code>payment_log</code>）。<br>• <strong>物理分片</strong>：每个 Topic 划分为多个 <strong>Partition（分区）</strong>，数据按分区存储，实现并行处理。<br>◦ <strong>分区特性</strong>：<br>◦ 每个分区是一个 <strong>有序、不可变</strong> 的消息序列。<br>◦ 消息通过 <strong>Offset（偏移量）</strong> 唯一标识，类似数组下标。</p>        <h4 id="3-Producer（生产者）"   >          <a href="#3-Producer（生产者）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Producer（生产者）" class="headerlink" title="3. Producer（生产者）"></a>3. <strong>Producer（生产者）</strong></h4>      <p>• <strong>功能</strong>：向 Topic 发送消息。<br>• <strong>路由策略</strong>：<br>◦ <strong>Key 哈希</strong>：若消息指定 Key，按 Key 哈希值分配到特定分区，保证相同 Key 的消息进入同一分区。<br>◦ <strong>轮询分配</strong>：无 Key 时轮询选择分区，实现负载均衡。</p>        <h4 id="4-Consumer（消费者）"   >          <a href="#4-Consumer（消费者）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Consumer（消费者）" class="headerlink" title="4. Consumer（消费者）"></a>4. <strong>Consumer（消费者）</strong></h4>      <p>• <strong>功能</strong>：从 Topic 拉取消息进行处理。<br>• <strong>消费者组（Consumer Group）</strong>：<br>◦ 组内消费者共享消费任务，每个分区只能由组内一个消费者消费。<br>◦ 横向扩展：增加消费者数量可提升消费并行度。</p>        <h4 id="5-Zookeeper-KRaft（集群管理）"   >          <a href="#5-Zookeeper-KRaft（集群管理）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Zookeeper-KRaft（集群管理）" class="headerlink" title="5. Zookeeper&#x2F;KRaft（集群管理）"></a>5. <strong>Zookeeper&#x2F;KRaft（集群管理）</strong></h4>      <p>• <strong>传统模式</strong>：依赖 Zookeeper 管理 Broker 元数据、Leader 选举、消费者 Offset。<br>• <strong>KRaft 模式</strong>（Kafka 2.8+）：去 Zookeeper 依赖，通过 Raft 协议实现集群元数据自管理。</p><hr>        <h3 id="二、数据写入流程（生产者视角）"   >          <a href="#二、数据写入流程（生产者视角）" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、数据写入流程（生产者视角）" class="headerlink" title="二、数据写入流程（生产者视角）"></a>二、数据写入流程（生产者视角）</h3>              <h4 id="1-消息发送"   >          <a href="#1-消息发送" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-消息发送" class="headerlink" title="1. 消息发送"></a>1. <strong>消息发送</strong></h4>      <p>• <strong>序列化</strong>：生产者将消息序列化为字节数组（支持 Avro、JSON 等格式）。<br>• <strong>分区选择</strong>：根据 Key 或轮询策略选择目标分区。<br>• <strong>批次压缩</strong>：消息按批次（Batch）压缩后发送（支持 LZ4、Snappy、GZIP）。</p>        <h4 id="2-Broker-处理"   >          <a href="#2-Broker-处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Broker-处理" class="headerlink" title="2. Broker 处理"></a>2. <strong>Broker 处理</strong></h4>      <p>• <strong>写入 Leader 分区</strong>：消息首先写入分区的 Leader Broker。<br>• <strong>副本同步</strong>：Follower 副本异步&#x2F;同步（<code>acks=all</code>）从 Leader 拉取数据。<br>• <strong>持久化存储</strong>：<br>◦ <strong>顺序写入磁盘</strong>：利用磁盘顺序 I&#x2F;O 的高性能特性。<br>◦ <strong>页缓存优化</strong>：通过 OS 页缓存加速读写，而非直接写磁盘。</p>        <h4 id="3-ACK-确认机制"   >          <a href="#3-ACK-确认机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-ACK-确认机制" class="headerlink" title="3. ACK 确认机制"></a>3. <strong>ACK 确认机制</strong></h4>      <p>• <strong>可靠性级别</strong>：<br>◦ <code>acks=0</code>：不等待确认，可能丢失数据。<br>◦ <code>acks=1</code>：Leader 写入成功即确认。<br>◦ <code>acks=all</code>：所有 ISR（In-Sync Replicas）副本写入成功才确认。</p><hr>        <h3 id="三、数据存储机制"   >          <a href="#三、数据存储机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、数据存储机制" class="headerlink" title="三、数据存储机制"></a>三、数据存储机制</h3>              <h4 id="1-分区结构"   >          <a href="#1-分区结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-分区结构" class="headerlink" title="1. 分区结构"></a>1. <strong>分区结构</strong></h4>      <p>• <strong>Segment 分段存储</strong>：<br>◦ 每个分区由多个 <strong>Segment 文件</strong> 组成（默认 1GB&#x2F;个）。<br>◦ 文件名以起始 Offset 命名（如 <code>00000000000000000000.log</code>）。<br>• <strong>索引文件</strong>：<code>.index</code> 和 <code>.timeindex</code> 文件加速 Offset 和时间范围查询。</p>        <h4 id="2-日志清理策略"   >          <a href="#2-日志清理策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-日志清理策略" class="headerlink" title="2. 日志清理策略"></a>2. <strong>日志清理策略</strong></h4>      <p>• <strong>删除策略</strong>：按时间（<code>retention.ms</code>）或大小（<code>retention.bytes</code>）删除旧数据。<br>• <strong>压缩策略</strong>：按 Key 合并重复消息，保留最新值（适用于状态更新场景）。</p><hr>        <h3 id="四、数据消费流程（消费者视角）"   >          <a href="#四、数据消费流程（消费者视角）" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、数据消费流程（消费者视角）" class="headerlink" title="四、数据消费流程（消费者视角）"></a>四、数据消费流程（消费者视角）</h3>              <h4 id="1-拉取模式（Pull）"   >          <a href="#1-拉取模式（Pull）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-拉取模式（Pull）" class="headerlink" title="1. 拉取模式（Pull）"></a>1. <strong>拉取模式（Pull）</strong></h4>      <p>• <strong>主动拉取</strong>：消费者通过 <code>poll()</code> 方法从 Broker 拉取消息，按需控制消费速率。<br>• <strong>批量消费</strong>：一次拉取多条消息，减少网络开销。</p>        <h4 id="2-Offset-管理"   >          <a href="#2-Offset-管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Offset-管理" class="headerlink" title="2. Offset 管理"></a>2. <strong>Offset 管理</strong></h4>      <p>• <strong>提交方式</strong>：<br>◦ <strong>自动提交</strong>：定期提交 Offset，可能重复消费。<br>◦ <strong>手动提交</strong>：处理完消息后显式提交（<code>commitSync()</code>&#x2F;<code>commitAsync()</code>）。<br>• <strong>存储位置</strong>：Offset 存储在内部 Topic <code>__consumer_offsets</code> 中。</p>        <h4 id="3-消费者组-Rebalance"   >          <a href="#3-消费者组-Rebalance" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-消费者组-Rebalance" class="headerlink" title="3. 消费者组 Rebalance"></a>3. <strong>消费者组 Rebalance</strong></h4>      <p>• <strong>触发条件</strong>：消费者加入&#x2F;退出、Topic 分区数变化。<br>• <strong>协调者（Coordinator）</strong>：由 Broker 担任，负责分配分区给消费者。</p><hr>        <h3 id="五、高可用性与容错"   >          <a href="#五、高可用性与容错" class="heading-link"><i class="fas fa-link"></i></a><a href="#五、高可用性与容错" class="headerlink" title="五、高可用性与容错"></a>五、高可用性与容错</h3>              <h4 id="1-副本机制（Replication）"   >          <a href="#1-副本机制（Replication）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-副本机制（Replication）" class="headerlink" title="1. 副本机制（Replication）"></a>1. <strong>副本机制（Replication）</strong></h4>      <p>• <strong>Leader-Follower 模型</strong>：<br>◦ 每个分区有多个副本，Leader 处理读写请求，Follower 同步数据。<br>◦ <strong>ISR（In-Sync Replicas）</strong>：与 Leader 数据同步的副本集合，用于故障切换。<br>• <strong>选举策略</strong>：Leader 宕机时，从 ISR 中选举新 Leader。</p>        <h4 id="2-数据一致性"   >          <a href="#2-数据一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据一致性" class="headerlink" title="2. 数据一致性"></a>2. <strong>数据一致性</strong></h4>      <p>• <strong>HW（High Watermark）</strong>：已成功复制到所有 ISR 副本的最高 Offset。<br>• <strong>消费者可见性</strong>：消费者只能读取到 HW 之前的消息，避免脏读。</p><hr>        <h3 id="六、性能优化关键技术"   >          <a href="#六、性能优化关键技术" class="heading-link"><i class="fas fa-link"></i></a><a href="#六、性能优化关键技术" class="headerlink" title="六、性能优化关键技术"></a>六、性能优化关键技术</h3>              <h4 id="1-零拷贝（Zero-Copy）"   >          <a href="#1-零拷贝（Zero-Copy）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-零拷贝（Zero-Copy）" class="headerlink" title="1. 零拷贝（Zero-Copy）"></a>1. <strong>零拷贝（Zero-Copy）</strong></h4>      <p>• <strong>原理</strong>：通过 <code>sendfile()</code> 系统调用，数据直接从磁盘文件发送到网络，绕过用户态内存复制。<br>• <strong>效果</strong>：降低 CPU 和内存开销，提升吞吐量。</p>        <h4 id="2-批量处理"   >          <a href="#2-批量处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-批量处理" class="headerlink" title="2. 批量处理"></a>2. <strong>批量处理</strong></h4>      <p>• <strong>生产者批量发送</strong>：累积消息成批次后发送，减少网络请求次数。<br>• <strong>消费者批量拉取</strong>：单次拉取多条消息，提升消费效率。</p><hr>        <h3 id="七、典型应用场景"   >          <a href="#七、典型应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#七、典型应用场景" class="headerlink" title="七、典型应用场景"></a>七、典型应用场景</h3>              <h4 id="1-实时日志聚合"   >          <a href="#1-实时日志聚合" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-实时日志聚合" class="headerlink" title="1. 实时日志聚合"></a>1. <strong>实时日志聚合</strong></h4>      <p>• <strong>场景</strong>：收集分布式系统日志，写入 Kafka 后供 Elasticsearch 或 Flink 处理。<br>• <strong>优势</strong>：高吞吐量支持海量日志写入。</p>        <h4 id="2-事件驱动架构"   >          <a href="#2-事件驱动架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-事件驱动架构" class="headerlink" title="2. 事件驱动架构"></a>2. <strong>事件驱动架构</strong></h4>      <p>• <strong>场景</strong>：微服务间通过 Topic 传递事件（如订单创建触发库存扣减）。<br>• <strong>优势</strong>：解耦服务，提升系统扩展性。</p>        <h4 id="3-流式数据处理"   >          <a href="#3-流式数据处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-流式数据处理" class="headerlink" title="3. 流式数据处理"></a>3. <strong>流式数据处理</strong></h4>      <p>• <strong>工具链</strong>：Kafka Streams 或 Flink 实时处理数据流（如用户行为分析）。<br>• <strong>优势</strong>：低延迟处理复杂计算（窗口聚合、Join 操作）。</p><hr>        <h3 id="八、核心优势与局限性"   >          <a href="#八、核心优势与局限性" class="heading-link"><i class="fas fa-link"></i></a><a href="#八、核心优势与局限性" class="headerlink" title="八、核心优势与局限性"></a>八、核心优势与局限性</h3>      <div class="table-container"><table><thead><tr><th><strong>优势</strong></th><th><strong>局限性</strong></th></tr></thead><tbody><tr><td>高吞吐量（百万级 QPS）</td><td>运维复杂度高（集群管理、调优）</td></tr><tr><td>低延迟（毫秒级响应）</td><td>小数据场景资源浪费</td></tr><tr><td>持久化与高可靠性</td><td>全局消息顺序无法保证</td></tr><tr><td>弹性扩展（水平扩容）</td><td>依赖外部组件（早期版本需 Zookeeper）</td></tr></tbody></table></div><hr>        <h3 id="九、总结"   >          <a href="#九、总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3>      <p>Kafka 通过 <strong>分布式分区存储</strong>、<strong>顺序磁盘 I&#x2F;O</strong> 和 <strong>副本容错机制</strong>，实现了高吞吐、高可靠的实时数据流处理。其核心设计理念是 <strong>将数据视为不可变事件流</strong>，适用于日志处理、事件驱动架构和大规模流式计算场景。但需注意其运维成本和资源消耗，合理权衡业务需求与技术选型。</p>]]></content>
    
    
    <summary type="html">Kafka工作原理详解</summary>
    
    
    
    <category term="消息队列" scheme="https://ljd0620.github.io/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="Kafka" scheme="https://ljd0620.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>如何保证数据一致性</title>
    <link href="https://ljd0620.github.io/2024/05/28/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://ljd0620.github.io/2024/05/28/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2024-05-28T04:34:17.000Z</published>
    <updated>2025-03-19T02:00:43.603Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，同时保证 MySQL、Redis 和 Elasticsearch 的数据一致性是一个复杂的挑战，因为每个组件有不同的特性和数据更新机制。以下是实现数据一致性的常见策略和最佳实践：</p><hr>        <h3 id="1-数据一致性问题分析"   >          <a href="#1-数据一致性问题分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据一致性问题分析" class="headerlink" title="1. 数据一致性问题分析"></a><strong>1. 数据一致性问题分析</strong></h3>      <p>在 MySQL、Redis 和 Elasticsearch 之间，数据一致性问题通常源于以下原因：</p><ol><li><strong>数据更新顺序</strong>：<ul><li>数据更新可能在不同组件之间出现延迟或顺序不一致。</li></ul></li><li><strong>数据更新失败</strong>：<ul><li>在更新多个组件时，部分组件可能更新失败，导致数据不一致。</li></ul></li><li><strong>缓存失效</strong>：<ul><li>Redis 缓存可能未及时更新或失效，导致读取到旧数据。</li></ul></li><li><strong>索引延迟</strong>：<ul><li>Elasticsearch 的索引可能存在延迟，导致查询结果不一致。</li></ul></li></ol><hr>        <h3 id="2-数据一致性策略"   >          <a href="#2-数据一致性策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据一致性策略" class="headerlink" title="2. 数据一致性策略"></a><strong>2. 数据一致性策略</strong></h3>      <p>以下是保证 MySQL、Redis 和 Elasticsearch 数据一致性的常见策略：</p>        <h4 id="1-写时同步更新"   >          <a href="#1-写时同步更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-写时同步更新" class="headerlink" title="(1) 写时同步更新"></a><strong>(1) 写时同步更新</strong></h4>      <p>在数据写入时，同步更新 MySQL、Redis 和 Elasticsearch。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li></ol></li><li><strong>优点</strong>：<ul><li>数据实时一致。</li></ul></li><li><strong>缺点</strong>：<ul><li>写入性能较低，因为需要同步更新多个组件。</li><li>如果某个组件更新失败，可能导致数据不一致。</li></ul></li></ul>        <h4 id="2-写时异步更新"   >          <a href="#2-写时异步更新" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-写时异步更新" class="headerlink" title="(2) 写时异步更新"></a><strong>(2) 写时异步更新</strong></h4>      <p>在数据写入时，异步更新 Redis 和 Elasticsearch。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>异步更新 Redis 缓存（如通过消息队列）。</li><li>异步更新 Elasticsearch 索引（如通过消息队列）。</li></ol></li><li><strong>优点</strong>：<ul><li>写入性能较高。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据可能存在短暂的不一致。</li></ul></li></ul>        <h4 id="3-基于消息队列的最终一致性"   >          <a href="#3-基于消息队列的最终一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-基于消息队列的最终一致性" class="headerlink" title="(3) 基于消息队列的最终一致性"></a><strong>(3) 基于消息队列的最终一致性</strong></h4>      <p>使用消息队列（如 Kafka、RabbitMQ）实现最终一致性。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>发送消息到消息队列，通知 Redis 和 Elasticsearch 更新。</li><li>消费者从消息队列中读取消息，更新 Redis 和 Elasticsearch。</li></ol></li><li><strong>优点</strong>：<ul><li>解耦数据更新逻辑，提高系统可扩展性。</li><li>保证最终一致性。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据可能存在短暂的不一致。</li><li>需要引入消息队列，增加系统复杂性。</li></ul></li></ul>        <h4 id="4-双写-补偿机制"   >          <a href="#4-双写-补偿机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-双写-补偿机制" class="headerlink" title="(4) 双写 + 补偿机制"></a><strong>(4) 双写 + 补偿机制</strong></h4>      <p>在数据写入时，同时写入 MySQL、Redis 和 Elasticsearch，并通过补偿机制处理失败情况。</p><ul><li><strong>流程</strong>：<ol><li>写入 MySQL。</li><li>写入 Redis。</li><li>写入 Elasticsearch。</li><li>如果某个组件写入失败，记录日志并触发补偿机制（如重试或回滚）。</li></ol></li><li><strong>优点</strong>：<ul><li>数据实时一致。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，需要处理各种失败场景。</li></ul></li></ul>        <h4 id="5-基于-CDC（Change-Data-Capture）的同步"   >          <a href="#5-基于-CDC（Change-Data-Capture）的同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-基于-CDC（Change-Data-Capture）的同步" class="headerlink" title="(5) 基于 CDC（Change Data Capture）的同步"></a><strong>(5) 基于 CDC（Change Data Capture）的同步</strong></h4>      <p>使用 CDC 工具（如 Debezium、Canal）捕获 MySQL 的变更，并同步到 Redis 和 Elasticsearch。</p><ul><li><strong>流程</strong>：<ol><li>MySQL 数据变更时，CDC 工具捕获变更事件。</li><li>CDC 工具将变更事件发送到消息队列。</li><li>消费者从消息队列中读取变更事件，更新 Redis 和 Elasticsearch。</li></ol></li><li><strong>优点</strong>：<ul><li>解耦数据更新逻辑，提高系统可扩展性。</li><li>保证最终一致性。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据可能存在短暂的不一致。</li><li>需要引入 CDC 工具和消息队列，增加系统复杂性。</li></ul></li></ul><hr>        <h3 id="3-具体实现方案"   >          <a href="#3-具体实现方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-具体实现方案" class="headerlink" title="3. 具体实现方案"></a><strong>3. 具体实现方案</strong></h3>      <p>以下是结合上述策略的具体实现方案：</p>        <h4 id="1-写时同步更新-补偿机制"   >          <a href="#1-写时同步更新-补偿机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-写时同步更新-补偿机制" class="headerlink" title="(1) 写时同步更新 + 补偿机制"></a><strong>(1) 写时同步更新 + 补偿机制</strong></h4>      <ul><li><strong>写入流程</strong>：<ol><li>开启事务，写入 MySQL。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li><li>提交事务。</li></ol></li><li><strong>补偿机制</strong>：<ul><li>如果某个组件更新失败，记录日志并触发补偿机制（如重试或回滚）。</li></ul></li></ul>        <h4 id="2-基于消息队列的最终一致性"   >          <a href="#2-基于消息队列的最终一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-基于消息队列的最终一致性" class="headerlink" title="(2) 基于消息队列的最终一致性"></a><strong>(2) 基于消息队列的最终一致性</strong></h4>      <ul><li><strong>写入流程</strong>：<ol><li>写入 MySQL。</li><li>发送消息到消息队列，通知 Redis 和 Elasticsearch 更新。</li></ol></li><li><strong>消费者流程</strong>：<ol><li>从消息队列中读取消息。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li></ol></li></ul>        <h4 id="3-基于-CDC-的同步"   >          <a href="#3-基于-CDC-的同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-基于-CDC-的同步" class="headerlink" title="(3) 基于 CDC 的同步"></a><strong>(3) 基于 CDC 的同步</strong></h4>      <ul><li><strong>CDC 工具配置</strong>：<ol><li>配置 Debezium 或 Canal，捕获 MySQL 的变更事件。</li><li>将变更事件发送到消息队列（如 Kafka）。</li></ol></li><li><strong>消费者流程</strong>：<ol><li>从消息队列中读取变更事件。</li><li>更新 Redis 缓存。</li><li>更新 Elasticsearch 索引。</li></ol></li></ul><hr>        <h3 id="4-最佳实践"   >          <a href="#4-最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a><strong>4. 最佳实践</strong></h3>      <ul><li><strong>合理选择一致性策略</strong>：<ul><li>根据业务需求选择强一致性或最终一致性。</li></ul></li><li><strong>引入消息队列</strong>：<ul><li>使用消息队列解耦数据更新逻辑，提高系统可扩展性。</li></ul></li><li><strong>监控与告警</strong>：<ul><li>监控 MySQL、Redis 和 Elasticsearch 的数据一致性，及时发现和处理问题。</li></ul></li><li><strong>补偿机制</strong>：<ul><li>设计完善的补偿机制，处理数据更新失败的情况。</li></ul></li><li><strong>测试与验证</strong>：<ul><li>在开发和测试环境中验证数据一致性策略，确保其正确性和可靠性。</li></ul></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>保证 MySQL、Redis 和 Elasticsearch 数据一致性的常见策略包括：</p><ol><li><strong>写时同步更新</strong>：适合强一致性场景，但性能较低。</li><li><strong>写时异步更新</strong>：适合最终一致性场景，性能较高。</li><li><strong>基于消息队列的最终一致性</strong>：解耦数据更新逻辑，适合高扩展性场景。</li><li><strong>双写 + 补偿机制</strong>：适合强一致性场景，但实现复杂。</li><li><strong>基于 CDC 的同步</strong>：适合最终一致性场景，解耦数据更新逻辑。</li></ol><p>根据具体的业务场景和性能需求，选择合适的策略，可以有效地保证 MySQL、Redis 和 Elasticsearch 的数据一致性。</p>]]></content>
    
    
    <summary type="html">如何保证数据一致性</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Elasticsearch" scheme="https://ljd0620.github.io/tags/Elasticsearch/"/>
    
    <category term="分布式" scheme="https://ljd0620.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="MySQL" scheme="https://ljd0620.github.io/tags/MySQL/"/>
    
    <category term="Redis" scheme="https://ljd0620.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式微服务架构</title>
    <link href="https://ljd0620.github.io/2024/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://ljd0620.github.io/2024/05/18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</id>
    <published>2024-05-18T04:36:46.000Z</published>
    <updated>2025-03-19T02:01:23.679Z</updated>
    
    <content type="html"><![CDATA[<p>分布式微服务架构是一种将应用程序拆分为多个小型、独立服务的开发模式，每个服务可以独立开发、部署和扩展。虽然微服务架构提供了灵活性和可扩展性，但也带来了许多挑战。以下是分布式微服务开发中需要注意的关键点：</p><hr>        <h3 id="1-服务拆分与设计"   >          <a href="#1-服务拆分与设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-服务拆分与设计" class="headerlink" title="1. 服务拆分与设计"></a><strong>1. 服务拆分与设计</strong></h3>              <h4 id="1-服务边界"   >          <a href="#1-服务边界" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-服务边界" class="headerlink" title="(1) 服务边界"></a><strong>(1) 服务边界</strong></h4>      <ul><li><strong>单一职责原则</strong>：<ul><li>每个服务应该只负责一个明确的业务功能。例如，用户服务只处理用户相关的逻辑，订单服务只处理订单相关的逻辑。</li><li>避免将多个不相关的功能耦合在一个服务中，否则会导致服务臃肿，难以维护。</li></ul></li><li><strong>领域驱动设计（DDD）</strong>：<ul><li>使用 DDD 的限界上下文（Bounded Context）来划分服务边界。例如，电商系统中可以将“订单”、“库存”、“支付”划分为不同的限界上下文，每个上下文对应一个服务。</li><li>限界上下文之间的交互通过明确的接口进行，避免直接依赖内部实现。</li></ul></li></ul>        <h4 id="2-服务粒度"   >          <a href="#2-服务粒度" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-服务粒度" class="headerlink" title="(2) 服务粒度"></a><strong>(2) 服务粒度</strong></h4>      <ul><li><strong>适度拆分</strong>：<ul><li>服务粒度过细会增加系统复杂性（如服务间通信成本增加），过粗则无法体现微服务的优势。</li><li>例如，初期可以将“用户服务”和“权限服务”合并为一个“用户权限服务”，随着业务发展再拆分为两个独立服务。</li></ul></li><li><strong>演进式设计</strong>：<ul><li>初期可以设计较粗粒度的服务，随着业务复杂性的增加逐步拆分。</li><li>例如，电商系统初期可以将“订单服务”和“库存服务”合并为一个“交易服务”，后期再拆分为独立的服务。</li></ul></li></ul><hr>        <h3 id="2-通信机制"   >          <a href="#2-通信机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-通信机制" class="headerlink" title="2. 通信机制"></a><strong>2. 通信机制</strong></h3>              <h4 id="1-通信协议"   >          <a href="#1-通信协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-通信协议" class="headerlink" title="(1) 通信协议"></a><strong>(1) 通信协议</strong></h4>      <ul><li><strong>同步通信</strong>：<ul><li>使用 RESTful API 或 gRPC 进行同步调用。RESTful API 适合简单的 HTTP 通信，gRPC 适合高性能、强类型的场景。</li><li>例如，订单服务调用支付服务时，可以使用 RESTful API 发送支付请求。</li></ul></li><li><strong>异步通信</strong>：<ul><li>使用消息队列（如 Kafka、RabbitMQ）进行异步通信。适合解耦服务间的依赖，提高系统的可扩展性。</li><li>例如，订单服务创建订单后，通过消息队列通知库存服务扣减库存。</li></ul></li></ul>        <h4 id="2-数据一致性"   >          <a href="#2-数据一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据一致性" class="headerlink" title="(2) 数据一致性"></a><strong>(2) 数据一致性</strong></h4>      <ul><li><strong>分布式事务</strong>：<ul><li>使用两阶段提交（2PC）或 Saga 模式保证跨服务的事务一致性。</li><li>例如，订单服务和库存服务通过 Saga 模式实现分布式事务：订单服务创建订单后，库存服务扣减库存；如果库存扣减失败，订单服务回滚订单。</li></ul></li><li><strong>最终一致性</strong>：<ul><li>通过消息队列实现最终一致性。例如，订单服务创建订单后，发送消息到消息队列，库存服务消费消息后扣减库存。</li></ul></li></ul>        <h4 id="3-服务发现与负载均衡"   >          <a href="#3-服务发现与负载均衡" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-服务发现与负载均衡" class="headerlink" title="(3) 服务发现与负载均衡"></a><strong>(3) 服务发现与负载均衡</strong></h4>      <ul><li><strong>服务发现</strong>：<ul><li>使用服务注册中心（如 Consul、Eureka）动态发现服务实例。例如，订单服务通过 Eureka 发现库存服务的实例。</li></ul></li><li><strong>负载均衡</strong>：<ul><li>使用客户端负载均衡（如 Ribbon）或服务端负载均衡（如 Nginx）。例如，订单服务通过 Ribbon 负载均衡调用库存服务的多个实例。</li></ul></li></ul><hr>        <h3 id="3-数据管理"   >          <a href="#3-数据管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-数据管理" class="headerlink" title="3. 数据管理"></a><strong>3. 数据管理</strong></h3>              <h4 id="1-数据库设计"   >          <a href="#1-数据库设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据库设计" class="headerlink" title="(1) 数据库设计"></a><strong>(1) 数据库设计</strong></h4>      <ul><li><strong>数据库拆分</strong>：<ul><li>每个服务使用独立的数据库，避免数据耦合。例如，订单服务使用 MySQL 存储订单数据，库存服务使用 PostgreSQL 存储库存数据。</li></ul></li><li><strong>数据同步</strong>：<ul><li>使用 CDC（Change Data Capture）工具（如 Debezium）同步数据。例如，订单服务的数据变更通过 Debezium 同步到数据仓库。</li></ul></li></ul>        <h4 id="2-缓存设计"   >          <a href="#2-缓存设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缓存设计" class="headerlink" title="(2) 缓存设计"></a><strong>(2) 缓存设计</strong></h4>      <ul><li><strong>分布式缓存</strong>：<ul><li>使用 Redis 或 Memcached 作为分布式缓存。例如，用户服务将用户信息缓存到 Redis 中，减少数据库查询压力。</li></ul></li><li><strong>缓存一致性</strong>：<ul><li>使用缓存失效策略（如写时失效）保证数据一致性。例如，用户信息更新时，同时失效 Redis 中的缓存。</li></ul></li></ul><hr>        <h3 id="4-容错与弹性"   >          <a href="#4-容错与弹性" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-容错与弹性" class="headerlink" title="4. 容错与弹性"></a><strong>4. 容错与弹性</strong></h3>              <h4 id="1-熔断与降级"   >          <a href="#1-熔断与降级" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-熔断与降级" class="headerlink" title="(1) 熔断与降级"></a><strong>(1) 熔断与降级</strong></h4>      <ul><li><strong>熔断器</strong>：<ul><li>使用熔断器（如 Hystrix、Resilience4j）防止服务雪崩。例如，当库存服务不可用时，订单服务触发熔断，直接返回错误提示。</li></ul></li><li><strong>降级策略</strong>：<ul><li>在服务不可用时返回默认值或缓存数据。例如，当推荐服务不可用时，返回默认的推荐列表。</li></ul></li></ul>        <h4 id="2-重试与超时"   >          <a href="#2-重试与超时" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-重试与超时" class="headerlink" title="(2) 重试与超时"></a><strong>(2) 重试与超时</strong></h4>      <ul><li><strong>重试机制</strong>：<ul><li>配置合理的重试次数和间隔（如指数退避）。例如，订单服务调用支付服务失败时，重试 3 次，每次间隔 1 秒。</li></ul></li><li><strong>超时设置</strong>：<ul><li>设置合理的超时时间，避免请求长时间阻塞。例如，订单服务调用库存服务的超时时间为 2 秒。</li></ul></li></ul>        <h4 id="3-限流与降级"   >          <a href="#3-限流与降级" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-限流与降级" class="headerlink" title="(3) 限流与降级"></a><strong>(3) 限流与降级</strong></h4>      <ul><li><strong>限流</strong>：<ul><li>使用限流算法（如令牌桶、漏桶）保护服务。例如，库存服务每秒最多处理 100 个请求，超过的请求直接拒绝。</li></ul></li><li><strong>降级</strong>：<ul><li>在系统压力过大时，关闭非核心功能。例如，促销活动期间关闭推荐服务，优先保证订单服务的可用性。</li></ul></li></ul><hr>        <h3 id="5-监控与日志"   >          <a href="#5-监控与日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-监控与日志" class="headerlink" title="5. 监控与日志"></a><strong>5. 监控与日志</strong></h3>              <h4 id="1-监控"   >          <a href="#1-监控" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-监控" class="headerlink" title="(1) 监控"></a><strong>(1) 监控</strong></h4>      <ul><li><strong>指标收集</strong>：<ul><li>使用 Prometheus 收集服务的性能指标。例如，监控订单服务的 QPS、响应时间等。</li></ul></li><li><strong>链路追踪</strong>：<ul><li>使用 Jaeger 或 Zipkin 追踪请求链路。例如，追踪订单服务调用支付服务的链路。</li></ul></li></ul>        <h4 id="2-日志"   >          <a href="#2-日志" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-日志" class="headerlink" title="(2) 日志"></a><strong>(2) 日志</strong></h4>      <ul><li><strong>集中日志</strong>：<ul><li>使用 ELK（Elasticsearch、Logstash、Kibana）或 Loki 集中管理日志。例如，将所有服务的日志收集到 Elasticsearch 中，通过 Kibana 查询。</li></ul></li><li><strong>结构化日志</strong>：<ul><li>使用 JSON 格式记录日志，便于分析和查询。例如，日志格式为 <code>&#123;&quot;level&quot;:&quot;info&quot;,&quot;message&quot;:&quot;Order created&quot;,&quot;orderId&quot;:123&#125;</code>。</li></ul></li></ul><hr>        <h3 id="6-安全性"   >          <a href="#6-安全性" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-安全性" class="headerlink" title="6. 安全性"></a><strong>6. 安全性</strong></h3>              <h4 id="1-认证与授权"   >          <a href="#1-认证与授权" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-认证与授权" class="headerlink" title="(1) 认证与授权"></a><strong>(1) 认证与授权</strong></h4>      <ul><li><strong>认证</strong>：<ul><li>使用 OAuth2 或 JWT 进行用户认证。例如，用户登录后获取 JWT，后续请求携带 JWT 进行认证。</li></ul></li><li><strong>授权</strong>：<ul><li>使用 RBAC（基于角色的访问控制）或 ABAC（基于属性的访问控制）进行权限管理。例如，管理员角色可以访问所有订单数据，普通用户只能访问自己的订单数据。</li></ul></li></ul>        <h4 id="2-数据安全"   >          <a href="#2-数据安全" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据安全" class="headerlink" title="(2) 数据安全"></a><strong>(2) 数据安全</strong></h4>      <ul><li><strong>加密传输</strong>：<ul><li>使用 HTTPS 加密通信数据。例如，订单服务与支付服务之间的通信使用 HTTPS。</li></ul></li><li><strong>数据脱敏</strong>：<ul><li>对敏感数据进行脱敏处理。例如，用户手机号显示为 <code>138****1234</code>。</li></ul></li></ul><hr>        <h3 id="7-部署与运维"   >          <a href="#7-部署与运维" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-部署与运维" class="headerlink" title="7. 部署与运维"></a><strong>7. 部署与运维</strong></h3>              <h4 id="1-容器化"   >          <a href="#1-容器化" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-容器化" class="headerlink" title="(1) 容器化"></a><strong>(1) 容器化</strong></h4>      <ul><li><strong>Docker</strong>：<ul><li>使用 Docker 容器化服务。例如，将订单服务打包为 Docker 镜像。</li></ul></li><li><strong>Kubernetes</strong>：<ul><li>使用 Kubernetes 管理容器化服务的部署和扩展。例如，通过 Kubernetes 自动扩展订单服务的实例数量。</li></ul></li></ul>        <h4 id="2-CI-CD"   >          <a href="#2-CI-CD" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-CI-CD" class="headerlink" title="(2) CI&#x2F;CD"></a><strong>(2) CI&#x2F;CD</strong></h4>      <ul><li><strong>持续集成</strong>：<ul><li>使用 Jenkins 或 GitLab CI 实现持续集成。例如，每次代码提交后自动运行单元测试。</li></ul></li><li><strong>持续交付</strong>：<ul><li>使用 ArgoCD 或 Spinnaker 实现持续交付。例如，通过 ArgoCD 自动将新版本部署到测试环境。</li></ul></li></ul>        <h4 id="3-配置管理"   >          <a href="#3-配置管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-配置管理" class="headerlink" title="(3) 配置管理"></a><strong>(3) 配置管理</strong></h4>      <ul><li><strong>集中配置</strong>：<ul><li>使用 Spring Cloud Config 或 Apollo 管理配置。例如，将所有服务的配置集中存储在 Apollo 中。</li></ul></li><li><strong>动态更新</strong>：<ul><li>支持配置的动态更新，避免重启服务。例如，通过 Apollo 动态修改订单服务的超时时间。</li></ul></li></ul><hr>        <h3 id="8-测试与验证"   >          <a href="#8-测试与验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-测试与验证" class="headerlink" title="8. 测试与验证"></a><strong>8. 测试与验证</strong></h3>              <h4 id="1-单元测试"   >          <a href="#1-单元测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-单元测试" class="headerlink" title="(1) 单元测试"></a><strong>(1) 单元测试</strong></h4>      <ul><li><strong>覆盖率</strong>：<ul><li>确保单元测试覆盖核心逻辑。例如，订单服务的单元测试覆盖创建订单、取消订单等核心功能。</li></ul></li><li><strong>Mock 测试</strong>：<ul><li>使用 Mockito 或 WireMock 模拟依赖服务。例如，模拟支付服务的响应，测试订单服务的逻辑。</li></ul></li></ul>        <h4 id="2-集成测试"   >          <a href="#2-集成测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-集成测试" class="headerlink" title="(2) 集成测试"></a><strong>(2) 集成测试</strong></h4>      <ul><li><strong>服务间测试</strong>：<ul><li>测试服务之间的通信和数据一致性。例如，测试订单服务调用库存服务的接口。</li></ul></li><li><strong>端到端测试</strong>：<ul><li>模拟真实用户场景，验证系统整体功能。例如，模拟用户从下单到支付的完整流程。</li></ul></li></ul>        <h4 id="3-性能测试"   >          <a href="#3-性能测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-性能测试" class="headerlink" title="(3) 性能测试"></a><strong>(3) 性能测试</strong></h4>      <ul><li><strong>压力测试</strong>：<ul><li>使用 JMeter 或 Gatling 进行压力测试。例如，模拟 1000 个用户同时下单，测试系统的性能。</li></ul></li><li><strong>容量规划</strong>：<ul><li>根据测试结果规划系统容量。例如，根据压力测试结果决定需要部署多少台服务器。</li></ul></li></ul><hr>        <h3 id="9-文档与协作"   >          <a href="#9-文档与协作" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-文档与协作" class="headerlink" title="9. 文档与协作"></a><strong>9. 文档与协作</strong></h3>              <h4 id="1-API-文档"   >          <a href="#1-API-文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-API-文档" class="headerlink" title="(1) API 文档"></a><strong>(1) API 文档</strong></h4>      <ul><li><strong>Swagger</strong>：<ul><li>使用 Swagger 生成 API 文档。例如，订单服务的 API 文档通过 Swagger 自动生成。</li></ul></li><li><strong>版本管理</strong>：<ul><li>对 API 进行版本管理，避免兼容性问题。例如，订单服务的 API 版本为 <code>v1</code> 和 <code>v2</code>，旧版本逐步淘汰。</li></ul></li></ul>        <h4 id="2-团队协作"   >          <a href="#2-团队协作" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-团队协作" class="headerlink" title="(2) 团队协作"></a><strong>(2) 团队协作</strong></h4>      <ul><li><strong>代码规范</strong>：<ul><li>制定统一的代码规范，便于团队协作。例如，使用 Google Java Style Guide 规范代码格式。</li></ul></li><li><strong>知识共享</strong>：<ul><li>定期进行技术分享，提升团队整体水平。例如，每周组织一次技术分享会。</li></ul></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>分布式微服务开发需要注意以下关键点：</p><ol><li><strong>服务拆分与设计</strong>：合理定义服务边界和粒度。</li><li><strong>通信机制</strong>：选择合适的通信协议和数据一致性方案。</li><li><strong>数据管理</strong>：设计独立的数据库和缓存策略。</li><li><strong>容错与弹性</strong>：实现熔断、降级、限流等机制。</li><li><strong>监控与日志</strong>：集中管理监控指标和日志。</li><li><strong>安全性</strong>：确保认证、授权和数据安全。</li><li><strong>部署与运维</strong>：使用容器化和 CI&#x2F;CD 工具。</li><li><strong>测试与验证</strong>：进行全面的单元测试、集成测试和性能测试。</li><li><strong>文档与协作</strong>：维护 API 文档和团队协作规范。</li></ol><p>通过关注这些关键点，可以构建高效、可靠的分布式微服务系统。</p>]]></content>
    
    
    <summary type="html">分布式微服务架构</summary>
    
    
    
    <category term="分布式" scheme="https://ljd0620.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="分布式" scheme="https://ljd0620.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Resilience4j的工作原理</title>
    <link href="https://ljd0620.github.io/2024/04/13/Resilience4j%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://ljd0620.github.io/2024/04/13/Resilience4j%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2024-04-13T04:20:48.000Z</published>
    <updated>2025-03-19T02:03:26.173Z</updated>
    
    <content type="html"><![CDATA[<p>Resilience4j 是一个轻量级的容错库，专为 Java 8 和函数式编程设计。它提供了熔断器、限流器、重试机制、隔舱模式等功能，帮助开发者构建健壮的分布式系统。Resilience4j 的设计目标是<strong>简单、轻量、模块化</strong>，并且与 Spring Boot 和 Spring Cloud 集成良好。以下是 Resilience4j 的工作原理及其核心机制的详细解析：</p><hr>        <h3 id="1-Resilience4j-的核心功能"   >          <a href="#1-Resilience4j-的核心功能" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Resilience4j-的核心功能" class="headerlink" title="1. Resilience4j 的核心功能"></a><strong>1. Resilience4j 的核心功能</strong></h3>      <p>Resilience4j 提供了以下核心功能：</p><ol><li><strong>熔断器（Circuit Breaker）</strong>：<ul><li>防止系统因某个服务的故障而崩溃。</li></ul></li><li><strong>限流器（Rate Limiter）</strong>：<ul><li>控制请求的速率，防止系统过载。</li></ul></li><li><strong>重试机制（Retry）</strong>：<ul><li>在请求失败时自动重试。</li></ul></li><li><strong>隔舱模式（Bulkhead）</strong>：<ul><li>隔离资源，避免某个服务的故障影响其他服务。</li></ul></li><li><strong>缓存（Cache）</strong>：<ul><li>对请求结果进行缓存，减少重复请求的开销。</li></ul></li><li><strong>时间限制器（Time Limiter）</strong>：<ul><li>限制方法的执行时间，避免长时间阻塞。</li></ul></li></ol><hr>        <h3 id="2-Resilience4j-的工作原理"   >          <a href="#2-Resilience4j-的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Resilience4j-的工作原理" class="headerlink" title="2. Resilience4j 的工作原理"></a><strong>2. Resilience4j 的工作原理</strong></h3>      <p>Resilience4j 的工作原理基于<strong>装饰器模式</strong>，通过装饰器对方法调用进行增强，从而实现容错功能。以下是 Resilience4j 的工作流程：</p>        <h4 id="1-定义核心逻辑"   >          <a href="#1-定义核心逻辑" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义核心逻辑" class="headerlink" title="(1) 定义核心逻辑"></a><strong>(1) 定义核心逻辑</strong></h4>      <p>开发者定义需要保护的核心逻辑（如调用外部服务）。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">callExternalService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用外部服务</span></span><br><span class="line">    <span class="keyword">return</span> externalService.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-创建装饰器"   >          <a href="#2-创建装饰器" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-创建装饰器" class="headerlink" title="(2) 创建装饰器"></a><strong>(2) 创建装饰器</strong></h4>      <p>使用 Resilience4j 提供的装饰器对核心逻辑进行增强。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CircuitBreaker</span> <span class="variable">circuitBreaker</span> <span class="operator">=</span> CircuitBreaker.ofDefaults(<span class="string">&quot;externalService&quot;</span>);</span><br><span class="line"><span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.ofDefaults(<span class="string">&quot;externalService&quot;</span>);</span><br><span class="line"><span class="type">Retry</span> <span class="variable">retry</span> <span class="operator">=</span> Retry.ofDefaults(<span class="string">&quot;externalService&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> CircuitBreaker.decorateSupplier(circuitBreaker, () -&gt;</span><br><span class="line">    RateLimiter.decorateSupplier(rateLimiter, () -&gt;</span><br><span class="line">        Retry.decorateSupplier(retry, () -&gt;</span><br><span class="line">            callExternalService()</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">).get();</span><br></pre></td></tr></table></div></figure>        <h4 id="3-执行装饰后的逻辑"   >          <a href="#3-执行装饰后的逻辑" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-执行装饰后的逻辑" class="headerlink" title="(3) 执行装饰后的逻辑"></a><strong>(3) 执行装饰后的逻辑</strong></h4>      <p>调用装饰后的逻辑，Resilience4j 会根据配置的规则（如熔断、限流、重试等）执行核心逻辑。</p><hr>        <h3 id="3-Resilience4j-的核心机制"   >          <a href="#3-Resilience4j-的核心机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Resilience4j-的核心机制" class="headerlink" title="3. Resilience4j 的核心机制"></a><strong>3. Resilience4j 的核心机制</strong></h3>      <p>以下是 Resilience4j 的核心机制及其实现原理：</p>        <h4 id="1-熔断器（Circuit-Breaker）"   >          <a href="#1-熔断器（Circuit-Breaker）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-熔断器（Circuit-Breaker）" class="headerlink" title="(1) 熔断器（Circuit Breaker）"></a><strong>(1) 熔断器（Circuit Breaker）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>监控请求的成功与失败情况。</li><li>当失败率达到阈值时，熔断器打开，所有请求快速失败。</li><li>经过一段时间后，熔断器进入半开状态，允许部分请求通过以检测服务是否恢复。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>failureRateThreshold</code>：失败率阈值（默认 50%）。</li><li><code>waitDurationInOpenState</code>：熔断器打开后进入半开状态的时间（默认 60 秒）。</li><li><code>ringBufferSizeInHalfOpenState</code>：半开状态下的请求数（默认 10）。</li><li><code>ringBufferSizeInClosedState</code>：关闭状态下的请求数（默认 100）。</li></ul></li></ul>        <h4 id="2-限流器（Rate-Limiter）"   >          <a href="#2-限流器（Rate-Limiter）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-限流器（Rate-Limiter）" class="headerlink" title="(2) 限流器（Rate Limiter）"></a><strong>(2) 限流器（Rate Limiter）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>控制请求的速率，防止系统过载。</li><li>使用令牌桶算法实现限流。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>limitRefreshPeriod</code>：令牌刷新周期（默认 500 纳秒）。</li><li><code>limitForPeriod</code>：每个周期的请求限制（默认 50）。</li></ul></li></ul>        <h4 id="3-重试机制（Retry）"   >          <a href="#3-重试机制（Retry）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-重试机制（Retry）" class="headerlink" title="(3) 重试机制（Retry）"></a><strong>(3) 重试机制（Retry）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>在请求失败时自动重试。</li><li>支持配置重试次数、重试间隔等。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>maxAttempts</code>：最大重试次数（默认 3）。</li><li><code>waitDuration</code>：重试间隔（默认 500 毫秒）。</li></ul></li></ul>        <h4 id="4-隔舱模式（Bulkhead）"   >          <a href="#4-隔舱模式（Bulkhead）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-隔舱模式（Bulkhead）" class="headerlink" title="(4) 隔舱模式（Bulkhead）"></a><strong>(4) 隔舱模式（Bulkhead）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>隔离资源，避免某个服务的故障影响其他服务。</li><li>支持线程池隔离和信号量隔离。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>maxConcurrentCalls</code>：最大并发调用数（默认 25）。</li><li><code>maxWaitDuration</code>：最大等待时间（默认 0 毫秒）。</li></ul></li></ul>        <h4 id="5-时间限制器（Time-Limiter）"   >          <a href="#5-时间限制器（Time-Limiter）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-时间限制器（Time-Limiter）" class="headerlink" title="(5) 时间限制器（Time Limiter）"></a><strong>(5) 时间限制器（Time Limiter）</strong></h4>      <ul><li><strong>工作原理</strong>：<ul><li>限制方法的执行时间，避免长时间阻塞。</li><li>如果方法执行超时，抛出 <code>TimeoutException</code>。</li></ul></li><li><strong>配置参数</strong>：<ul><li><code>timeoutDuration</code>：超时时间（默认 1 秒）。</li></ul></li></ul><hr>        <h3 id="4-Resilience4j-的示例代码"   >          <a href="#4-Resilience4j-的示例代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Resilience4j-的示例代码" class="headerlink" title="4. Resilience4j 的示例代码"></a><strong>4. Resilience4j 的示例代码</strong></h3>      <p>以下是一个完整的 Resilience4j 示例：</p>        <h4 id="1-添加依赖"   >          <a href="#1-添加依赖" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-添加依赖" class="headerlink" title="(1) 添加依赖"></a><strong>(1) 添加依赖</strong></h4>      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-spring-boot2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="2-配置-Resilience4j"   >          <a href="#2-配置-Resilience4j" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-配置-Resilience4j" class="headerlink" title="(2) 配置 Resilience4j"></a><strong>(2) 配置 Resilience4j</strong></h4>      <figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">externalService:</span></span><br><span class="line">        <span class="attr">failureRateThreshold:</span> <span class="number">50</span></span><br><span class="line">        <span class="attr">waitDurationInOpenState:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">ringBufferSizeInHalfOpenState:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">ringBufferSizeInClosedState:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">ratelimiter:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">externalService:</span></span><br><span class="line">        <span class="attr">limitForPeriod:</span> <span class="number">10</span></span><br><span class="line">        <span class="attr">limitRefreshPeriod:</span> <span class="string">1s</span></span><br><span class="line">  <span class="attr">retry:</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">externalService:</span></span><br><span class="line">        <span class="attr">maxAttempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">waitDuration:</span> <span class="string">500ms</span></span><br></pre></td></tr></table></div></figure>        <h4 id="3-使用-Resilience4j"   >          <a href="#3-使用-Resilience4j" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-使用-Resilience4j" class="headerlink" title="(3) 使用 Resilience4j"></a><strong>(3) 使用 Resilience4j</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalService</span> &#123;</span><br><span class="line">    <span class="meta">@CircuitBreaker(name = &quot;externalService&quot;, fallbackMethod = &quot;fallback&quot;)</span></span><br><span class="line">    <span class="meta">@RateLimiter(name = &quot;externalService&quot;)</span></span><br><span class="line">    <span class="meta">@Retry(name = &quot;externalService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">callExternalService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用外部服务</span></span><br><span class="line">        <span class="keyword">return</span> externalService.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fallback</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fallback response&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="5-Resilience4j-的优缺点"   >          <a href="#5-Resilience4j-的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Resilience4j-的优缺点" class="headerlink" title="5. Resilience4j 的优缺点"></a><strong>5. Resilience4j 的优缺点</strong></h3>              <h4 id="1-优点"   >          <a href="#1-优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-优点" class="headerlink" title="(1) 优点"></a><strong>(1) 优点</strong></h4>      <ul><li><strong>轻量级</strong>：模块化设计，按需引入功能。</li><li><strong>易于集成</strong>：与 Spring Boot 和 Spring Cloud 集成良好。</li><li><strong>丰富的功能</strong>：支持熔断、限流、重试、隔舱等多种容错机制。</li><li><strong>灵活的配置</strong>：支持通过配置文件或代码进行配置。</li></ul>        <h4 id="2-缺点"   >          <a href="#2-缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a><strong>(2) 缺点</strong></h4>      <ul><li><strong>学习成本</strong>：需要熟悉 Resilience4j 的 API 和配置。</li><li><strong>性能开销</strong>：装饰器模式会带来一定的性能开销。</li></ul><hr>        <h3 id="6-Resilience4j-的替代方案"   >          <a href="#6-Resilience4j-的替代方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Resilience4j-的替代方案" class="headerlink" title="6. Resilience4j 的替代方案"></a><strong>6. Resilience4j 的替代方案</strong></h3>      <ol><li><strong>Hystrix</strong>：<ul><li>Netflix 开源的容错库，已停止维护。</li></ul></li><li><strong>Sentinel</strong>：<ul><li>阿里巴巴开源的流量控制和熔断降级框架。</li></ul></li><li><strong>Spring Cloud Circuit Breaker</strong>：<ul><li>Spring Cloud 提供的统一熔断器抽象，支持多种实现（如 Resilience4j、Sentinel 等）。</li></ul></li></ol><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Resilience4j 通过装饰器模式提供了熔断、限流、重试、隔舱等容错机制，帮助开发者构建健壮的分布式系统。其轻量级、模块化的设计使其易于集成和扩展。尽管 Resilience4j 有一定的学习成本和性能开销，但其丰富的功能和灵活的配置使其成为现代分布式系统中的理想选择。</p>]]></content>
    
    
    <summary type="html">Resilience4j的工作原理</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Resilience4j" scheme="https://ljd0620.github.io/tags/Resilience4j/"/>
    
  </entry>
  
  <entry>
    <title>Feign定制化开发指南</title>
    <link href="https://ljd0620.github.io/2024/03/26/Feign%E5%AE%9A%E5%88%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    <id>https://ljd0620.github.io/2024/03/26/Feign%E5%AE%9A%E5%88%B6%E5%8C%96%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</id>
    <published>2024-03-26T04:33:52.000Z</published>
    <updated>2025-03-19T02:01:58.712Z</updated>
    
    <content type="html"><![CDATA[<p>Feign 是一个声明式的 Web 服务客户端，主要用于简化 HTTP 请求的调用。然而，在非 HTTP 请求的场景下，例如区块链应用中常见的 gRPC、WebSocket 或者直接的 TCP&#x2F;IP 协议通信，Feign 并不是直接适用的。但是，通过一些定制化开发，你可以扩展 Feign 来适应这些不同的协议。</p><p>要在非 HTTP 请求的场景下，例如区块链智能合约调用中使用 Feign 框架进行定制化开发，你需要对 Feign 进行扩展或替换其核心组件以适应新的协议。以下是一个详细的步骤指南，帮助你在这种情况下使用 Feign：</p>        <h3 id="1-理解需求"   >          <a href="#1-理解需求" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-理解需求" class="headerlink" title="1. 理解需求"></a>1. 理解需求</h3>      <p>首先明确你希望实现的目标。对于区块链智能合约调用，通常需要通过某种方式与区块链节点通信（如通过 JSON-RPC、gRPC 或者 WebSocket），而不是直接的 HTTP 请求。</p>        <h3 id="2-设计接口"   >          <a href="#2-设计接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-设计接口" class="headerlink" title="2. 设计接口"></a>2. 设计接口</h3>      <p>设计一个接口来表示你想要执行的操作。这个接口将作为 Feign 的客户端接口，并且应该包含所有必要的方法定义。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;blockchain-client&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockchainClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestLine(&quot;GET /eth_call&quot;)</span></span><br><span class="line">    String <span class="title function_">callSmartContract</span><span class="params">(<span class="meta">@Param(&quot;data&quot;)</span> String data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>请注意，这里的 <code>@RequestLine</code> 注解是用于指定请求的方法和路径，而在实际的区块链交互中，这可能并不适用。因此，你可能需要自定义注解或者完全不使用这些注解。</p>        <h3 id="3-创建自定义-Client-实现"   >          <a href="#3-创建自定义-Client-实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-创建自定义-Client-实现" class="headerlink" title="3. 创建自定义 Client 实现"></a>3. 创建自定义 Client 实现</h3>      <p>由于 Feign 默认是为 HTTP 设计的，所以你需要创建一个新的 <code>feign.Client</code> 实现类来处理特定于区块链的通信逻辑。例如，如果你正在使用 Web3j 库与 Ethereum 区块链交互，你可以这样做：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Client;</span><br><span class="line"><span class="keyword">import</span> feign.Request;</span><br><span class="line"><span class="keyword">import</span> feign.Response;</span><br><span class="line"><span class="keyword">import</span> org.web3j.protocol.Web3j;</span><br><span class="line"><span class="keyword">import</span> org.web3j.protocol.core.methods.response.EthCall;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Web3jClient</span> <span class="keyword">implements</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Web3j web3j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Web3jClient</span><span class="params">(Web3j web3j)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.web3j = web3j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Request.Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 解析请求中的参数并构造相应的 Web3j 调用</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(request.body());</span><br><span class="line">        <span class="type">EthCall</span> <span class="variable">response</span> <span class="operator">=</span> web3j.ethCall(</span><br><span class="line">                <span class="comment">// 根据你的需求解析 requestBody 并构造正确的参数</span></span><br><span class="line">                <span class="comment">// 这里只是一个示例</span></span><br><span class="line">                Transaction.createEthCallTransaction(</span><br><span class="line">                        <span class="string">&quot;fromAddress&quot;</span>, </span><br><span class="line">                        <span class="string">&quot;toAddress&quot;</span>, </span><br><span class="line">                        <span class="string">&quot;data&quot;</span></span><br><span class="line">                ),</span><br><span class="line">                DefaultBlockParameterName.LATEST</span><br><span class="line">        ).send();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 Feign 的 Response 对象</span></span><br><span class="line">        <span class="keyword">return</span> Response.builder()</span><br><span class="line">                .status(<span class="number">200</span>)</span><br><span class="line">                .reason(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line">                .body(response.getResult(), StandardCharsets.UTF_8)</span><br><span class="line">                .headers(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="4-配置-Feign-使用自定义-Client"   >          <a href="#4-配置-Feign-使用自定义-Client" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-配置-Feign-使用自定义-Client" class="headerlink" title="4. 配置 Feign 使用自定义 Client"></a>4. 配置 Feign 使用自定义 Client</h3>      <p>在 Spring Boot 中，你可以通过配置文件或编程方式指定自定义的 <code>Client</code> 实现。</p><ul><li><p><strong>编程方式</strong>：</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Client <span class="title function_">feignClient</span><span class="params">(Web3j web3j)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Web3jClient</span>(web3j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>配置文件方式</strong>：</p><p>如果你有多个不同的客户端配置，可以在 <code>application.yml</code> 中进行配置。</p><figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">blockchain-client:</span></span><br><span class="line">        <span class="attr">client:</span> <span class="string">com.example.Web3jClient</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h3 id="5-处理复杂场景"   >          <a href="#5-处理复杂场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-处理复杂场景" class="headerlink" title="5. 处理复杂场景"></a>5. 处理复杂场景</h3>      <p>对于更复杂的场景，比如区块链中的 P2P 通信或者智能合约调用，你可能需要进一步定制化 Feign 的行为。这包括但不限于：</p><ul><li><p><strong>编码器与解码器</strong>：根据具体协议的要求，编写自定义的 <code>Encoder</code> 和 <code>Decoder</code> 来序列化和反序列化请求和响应数据。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Encoder <span class="title function_">feignEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomBlockchainEncoder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Decoder <span class="title function_">feignDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomBlockchainDecoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>拦截器</strong>：使用 <code>RequestInterceptor</code> 来添加必要的头信息或者其他预处理逻辑。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">customRequestInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> template -&gt; &#123;</span><br><span class="line">        <span class="comment">// 添加必要的预处理逻辑</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li><p><strong>错误处理器</strong>：实现自定义的 <code>ErrorDecoder</code> 来处理不同类型的错误响应。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ErrorDecoder <span class="title function_">errorDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomBlockchainErrorDecoder</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h3 id="6-测试与调试"   >          <a href="#6-测试与调试" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-测试与调试" class="headerlink" title="6. 测试与调试"></a>6. 测试与调试</h3>      <p>完成上述步骤后，确保对你的 Feign 客户端进行全面的测试，以验证它是否能够正确地与区块链节点进行交互，并处理各种异常情况。</p>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>      <p>虽然 Feign 主要是为了简化 HTTP 请求而设计的，但通过创建自定义的 <code>Client</code> 实现，你可以使其适应其他协议的需求。关键在于理解 Feign 的插件化架构，并利用其提供的扩展点来插入适合特定协议的实现。这样，即使在非 HTTP 请求的场景下，如区块链智能合约调用，你也能享受到 Feign 带来的便捷性和一致性。</p>]]></content>
    
    
    <summary type="html">Feign定制化开发指南</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Feign" scheme="https://ljd0620.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix的熔断机制</title>
    <link href="https://ljd0620.github.io/2024/03/01/Hystrix%E7%9A%84%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
    <id>https://ljd0620.github.io/2024/03/01/Hystrix%E7%9A%84%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2024-03-01T04:21:36.000Z</published>
    <updated>2025-03-19T02:02:10.228Z</updated>
    
    <content type="html"><![CDATA[<p>Hystrix通过监控请求的成功与失败情况，动态调整熔断器的状态。以下是Hystrix熔断器关闭的具体条件和机制：</p><hr>        <h3 id="1-熔断器的三种状态"   >          <a href="#1-熔断器的三种状态" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-熔断器的三种状态" class="headerlink" title="1. 熔断器的三种状态"></a><strong>1. 熔断器的三种状态</strong></h3>      <p>Hystrix熔断器有三种状态：</p><ol><li><p><strong>Closed（关闭状态）</strong>：</p><ul><li>默认状态，允许请求通过。</li><li>Hystrix会统计请求的成功与失败情况。</li></ul></li><li><p><strong>Open（打开状态）</strong>：</p><ul><li>当失败率达到阈值时，熔断器会进入打开状态。</li><li>在打开状态下，所有请求都会被快速失败（直接调用降级逻辑），不会尝试执行实际逻辑。</li></ul></li><li><p><strong>Half-Open（半开状态）</strong>：</p><ul><li>熔断器在打开状态一段时间后，会尝试进入半开状态。</li><li>在半开状态下，允许部分请求通过，用于检测后端服务是否恢复。</li></ul></li></ol><hr>        <h3 id="2-熔断器关闭的条件"   >          <a href="#2-熔断器关闭的条件" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-熔断器关闭的条件" class="headerlink" title="2. 熔断器关闭的条件"></a><strong>2. 熔断器关闭的条件</strong></h3>      <p>熔断器从<strong>Open状态</strong>切换到<strong>Closed状态</strong>的条件如下：</p><ol><li><p><strong>时间窗口到期</strong>：</p><ul><li>熔断器在打开状态后会保持一段时间（默认5秒），这段时间内所有请求都会被快速失败。</li><li>当时间窗口到期后，熔断器会进入半开状态。</li></ul></li><li><p><strong>半开状态下的请求成功</strong>：</p><ul><li>在半开状态下，Hystrix会允许部分请求通过（默认是1个请求）。</li><li>如果这些请求成功，熔断器会认为后端服务已恢复，从而关闭熔断器，进入Closed状态。</li><li>如果这些请求失败，熔断器会重新进入Open状态，并继续等待下一个时间窗口。</li></ul></li></ol><hr>        <h3 id="3-相关配置参数"   >          <a href="#3-相关配置参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-相关配置参数" class="headerlink" title="3. 相关配置参数"></a><strong>3. 相关配置参数</strong></h3>      <p>Hystrix熔断器的行为可以通过以下参数进行配置：</p><ul><li><strong><code>circuitBreaker.enabled</code></strong>：是否启用熔断器（默认<code>true</code>）。</li><li><strong><code>circuitBreaker.requestVolumeThreshold</code></strong>：在时间窗口内触发熔断的最小请求数（默认20）。</li><li><strong><code>circuitBreaker.errorThresholdPercentage</code></strong>：触发熔断的失败率阈值（默认50%，即50%的请求失败会触发熔断）。</li><li><strong><code>circuitBreaker.sleepWindowInMilliseconds</code></strong>：熔断器打开后进入半开状态的时间窗口（默认5000毫秒）。</li><li><strong><code>circuitBreaker.forceClosed</code></strong>：强制关闭熔断器（默认<code>false</code>）。</li><li><strong><code>circuitBreaker.forceOpen</code></strong>：强制打开熔断器（默认<code>false</code>）。</li></ul><hr>        <h3 id="4-熔断器关闭的流程"   >          <a href="#4-熔断器关闭的流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-熔断器关闭的流程" class="headerlink" title="4. 熔断器关闭的流程"></a><strong>4. 熔断器关闭的流程</strong></h3>      <p>以下是熔断器关闭的具体流程：</p><ol><li><p><strong>熔断器打开</strong>：</p><ul><li>当失败率达到阈值时，熔断器进入Open状态，所有请求快速失败。</li></ul></li><li><p><strong>时间窗口到期</strong>：</p><ul><li>经过<code>sleepWindowInMilliseconds</code>时间后，熔断器进入Half-Open状态。</li></ul></li><li><p><strong>尝试请求</strong>：</p><ul><li>在半开状态下，允许部分请求通过，执行实际逻辑。</li></ul></li><li><p><strong>判断请求结果</strong>：</p><ul><li>如果请求成功，熔断器关闭，进入Closed状态。</li><li>如果请求失败，熔断器重新进入Open状态。</li></ul></li></ol><hr>        <h3 id="5-示例"   >          <a href="#5-示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-示例" class="headerlink" title="5. 示例"></a><strong>5. 示例</strong></h3>      <p>假设配置如下：</p><ul><li><code>circuitBreaker.requestVolumeThreshold = 20</code></li><li><code>circuitBreaker.errorThresholdPercentage = 50</code></li><li><code>circuitBreaker.sleepWindowInMilliseconds = 5000</code></li></ul><p><strong>流程</strong>：</p><ol><li>在时间窗口内，如果请求数达到20，且失败率超过50%，熔断器打开。</li><li>熔断器保持打开状态5秒，期间所有请求快速失败。</li><li>5秒后，熔断器进入半开状态，允许1个请求通过。</li><li>如果该请求成功，熔断器关闭；如果失败，熔断器重新打开。</li></ol><hr>        <h3 id="6-注意事项"   >          <a href="#6-注意事项" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a><strong>6. 注意事项</strong></h3>      <ul><li><strong>熔断器的目的是保护系统</strong>：避免因后端服务不可用导致系统雪崩。</li><li><strong>合理配置参数</strong>：根据实际业务场景调整熔断器的参数，避免过于敏感或迟钝。</li><li><strong>结合降级逻辑</strong>：在熔断器打开时，提供合理的降级逻辑，确保用户体验。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Hystrix熔断器在以下情况下会关闭：</p><ol><li>熔断器进入半开状态后，允许的请求成功执行。</li><li>熔断器的时间窗口到期，且后端服务恢复正常。</li></ol><p>通过合理配置熔断器参数，可以确保系统在高并发或后端服务不稳定的情况下仍能保持稳定运行。</p>]]></content>
    
    
    <summary type="html">Hystrix的熔断机制</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Hystrix" scheme="https://ljd0620.github.io/tags/Hystrix/"/>
    
    <category term="熔断降级" scheme="https://ljd0620.github.io/tags/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Feign的工作原理</title>
    <link href="https://ljd0620.github.io/2024/01/18/Feign%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://ljd0620.github.io/2024/01/18/Feign%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2024-01-18T04:19:02.000Z</published>
    <updated>2025-03-19T02:02:03.473Z</updated>
    
    <content type="html"><![CDATA[<p>Feign 是 Netflix 开源的一个声明式的 HTTP 客户端，旨在简化 HTTP API 的调用。它通过注解和接口定义的方式，让开发者可以像调用本地方法一样调用远程服务。Feign 的核心思想是<strong>将 HTTP 请求抽象为 Java 接口</strong>，从而隐藏了底层的 HTTP 通信细节。以下是 Feign 的工作原理及其核心机制的详细解析：</p><hr>        <h3 id="1-Feign-的核心特点"   >          <a href="#1-Feign-的核心特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Feign-的核心特点" class="headerlink" title="1. Feign 的核心特点"></a><strong>1. Feign 的核心特点</strong></h3>      <ul><li><strong>声明式 API</strong>：通过 Java 接口和注解定义 HTTP 请求。</li><li><strong>集成 Ribbon</strong>：支持客户端负载均衡。</li><li><strong>集成 Hystrix</strong>：支持熔断和降级。</li><li><strong>易于扩展</strong>：支持自定义编码器、解码器、拦截器等。</li></ul><hr>        <h3 id="2-Feign-的工作原理"   >          <a href="#2-Feign-的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Feign-的工作原理" class="headerlink" title="2. Feign 的工作原理"></a><strong>2. Feign 的工作原理</strong></h3>      <p>Feign 的工作原理可以分为以下几个步骤：</p>        <h4 id="1-定义接口"   >          <a href="#1-定义接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义接口" class="headerlink" title="(1) 定义接口"></a><strong>(1) 定义接口</strong></h4>      <p>开发者通过 Java 接口定义 HTTP 请求，使用注解描述请求的细节（如 URL、HTTP 方法、参数等）。</p><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;user-service&quot;, url = &quot;http://localhost:8080&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-动态代理"   >          <a href="#2-动态代理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-动态代理" class="headerlink" title="(2) 动态代理"></a><strong>(2) 动态代理</strong></h4>      <p>Feign 在运行时通过 <strong>JDK 动态代理</strong> 或 <strong>CGLIB</strong> 为接口生成代理对象。当调用接口方法时，代理对象会拦截方法调用，并根据注解生成 HTTP 请求。</p>        <h4 id="3-解析注解"   >          <a href="#3-解析注解" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-解析注解" class="headerlink" title="(3) 解析注解"></a><strong>(3) 解析注解</strong></h4>      <p>Feign 解析接口方法上的注解（如 <code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PathVariable</code> 等），生成 HTTP 请求的 URL、方法、参数等信息。</p>        <h4 id="4-编码请求"   >          <a href="#4-编码请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-编码请求" class="headerlink" title="(4) 编码请求"></a><strong>(4) 编码请求</strong></h4>      <p>Feign 使用 <strong>编码器（Encoder）</strong> 将 Java 对象转换为 HTTP 请求体（如 JSON、XML 等）。</p>        <h4 id="5-发送请求"   >          <a href="#5-发送请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-发送请求" class="headerlink" title="(5) 发送请求"></a><strong>(5) 发送请求</strong></h4>      <p>Feign 使用底层的 HTTP 客户端（如 <code>java.net.HttpURLConnection</code>、<code>OkHttp</code>、<code>Apache HttpClient</code> 等）发送 HTTP 请求。</p>        <h4 id="6-解码响应"   >          <a href="#6-解码响应" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-解码响应" class="headerlink" title="(6) 解码响应"></a><strong>(6) 解码响应</strong></h4>      <p>Feign 使用 <strong>解码器（Decoder）</strong> 将 HTTP 响应体（如 JSON、XML 等）转换为 Java 对象。</p>        <h4 id="7-返回结果"   >          <a href="#7-返回结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-返回结果" class="headerlink" title="(7) 返回结果"></a><strong>(7) 返回结果</strong></h4>      <p>将解码后的结果返回给调用方。</p><hr>        <h3 id="3-Feign-的核心组件"   >          <a href="#3-Feign-的核心组件" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Feign-的核心组件" class="headerlink" title="3. Feign 的核心组件"></a><strong>3. Feign 的核心组件</strong></h3>      <p>Feign 的核心组件包括：</p>        <h4 id="1-注解处理器"   >          <a href="#1-注解处理器" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-注解处理器" class="headerlink" title="(1) 注解处理器"></a><strong>(1) 注解处理器</strong></h4>      <ul><li>负责解析接口方法上的注解（如 <code>@RequestLine</code>、<code>@Param</code>、<code>@Headers</code> 等）。</li><li>生成 HTTP 请求的元数据（如 URL、方法、参数等）。</li></ul>        <h4 id="2-动态代理-1"   >          <a href="#2-动态代理-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-动态代理-1" class="headerlink" title="(2) 动态代理"></a><strong>(2) 动态代理</strong></h4>      <ul><li>通过 JDK 动态代理或 CGLIB 生成接口的代理对象。</li><li>拦截方法调用并触发 HTTP 请求。</li></ul>        <h4 id="3-编码器（Encoder）"   >          <a href="#3-编码器（Encoder）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-编码器（Encoder）" class="headerlink" title="(3) 编码器（Encoder）"></a><strong>(3) 编码器（Encoder）</strong></h4>      <ul><li>将 Java 对象转换为 HTTP 请求体。</li><li>默认使用 <code>Jackson</code> 或 <code>Gson</code> 将对象编码为 JSON。</li></ul>        <h4 id="4-解码器（Decoder）"   >          <a href="#4-解码器（Decoder）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-解码器（Decoder）" class="headerlink" title="(4) 解码器（Decoder）"></a><strong>(4) 解码器（Decoder）</strong></h4>      <ul><li>将 HTTP 响应体转换为 Java 对象。</li><li>默认使用 <code>Jackson</code> 或 <code>Gson</code> 将 JSON 解码为对象。</li></ul>        <h4 id="5-HTTP-客户端"   >          <a href="#5-HTTP-客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-HTTP-客户端" class="headerlink" title="(5) HTTP 客户端"></a><strong>(5) HTTP 客户端</strong></h4>      <ul><li>负责发送 HTTP 请求。</li><li>支持多种底层实现（如 <code>java.net.HttpURLConnection</code>、<code>OkHttp</code>、<code>Apache HttpClient</code> 等）。</li></ul>        <h4 id="6-拦截器（Interceptor）"   >          <a href="#6-拦截器（Interceptor）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-拦截器（Interceptor）" class="headerlink" title="(6) 拦截器（Interceptor）"></a><strong>(6) 拦截器（Interceptor）</strong></h4>      <ul><li>在请求发送前或响应返回后执行自定义逻辑。</li><li>可以用于添加请求头、记录日志等。</li></ul>        <h4 id="7-负载均衡（Ribbon）"   >          <a href="#7-负载均衡（Ribbon）" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-负载均衡（Ribbon）" class="headerlink" title="(7) 负载均衡（Ribbon）"></a><strong>(7) 负载均衡（Ribbon）</strong></h4>      <ul><li>Feign 默认集成 Ribbon，支持客户端负载均衡。</li><li>根据服务名从注册中心获取可用实例列表，并选择其中一个实例发送请求。</li></ul>        <h4 id="8-熔断器（Hystrix）"   >          <a href="#8-熔断器（Hystrix）" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-熔断器（Hystrix）" class="headerlink" title="(8) 熔断器（Hystrix）"></a><strong>(8) 熔断器（Hystrix）</strong></h4>      <ul><li>Feign 支持集成 Hystrix，提供熔断和降级功能。</li><li>当服务调用失败时，执行降级逻辑。</li></ul><hr>        <h3 id="4-Feign-的工作流程"   >          <a href="#4-Feign-的工作流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Feign-的工作流程" class="headerlink" title="4. Feign 的工作流程"></a><strong>4. Feign 的工作流程</strong></h3>      <p>以下是 Feign 的工作流程：</p><ol><li><strong>定义接口</strong>：开发者通过 Java 接口定义 HTTP 请求。</li><li><strong>生成代理</strong>：Feign 在运行时为接口生成代理对象。</li><li><strong>解析注解</strong>：代理对象解析方法上的注解，生成 HTTP 请求元数据。</li><li><strong>编码请求</strong>：使用编码器将 Java 对象转换为 HTTP 请求体。</li><li><strong>发送请求</strong>：通过 HTTP 客户端发送请求。</li><li><strong>解码响应</strong>：使用解码器将 HTTP 响应体转换为 Java 对象。</li><li><strong>返回结果</strong>：将结果返回给调用方。</li></ol><hr>        <h3 id="5-Feign-的集成与扩展"   >          <a href="#5-Feign-的集成与扩展" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Feign-的集成与扩展" class="headerlink" title="5. Feign 的集成与扩展"></a><strong>5. Feign 的集成与扩展</strong></h3>              <h4 id="1-集成-Spring-Cloud"   >          <a href="#1-集成-Spring-Cloud" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-集成-Spring-Cloud" class="headerlink" title="(1) 集成 Spring Cloud"></a><strong>(1) 集成 Spring Cloud</strong></h4>      <ul><li>在 Spring Cloud 中，Feign 被深度集成，支持自动配置和服务发现。</li><li>通过 <code>@EnableFeignClients</code> 注解启用 Feign 客户端。</li></ul>        <h4 id="2-自定义编码器和解码器"   >          <a href="#2-自定义编码器和解码器" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-自定义编码器和解码器" class="headerlink" title="(2) 自定义编码器和解码器"></a><strong>(2) 自定义编码器和解码器</strong></h4>      <ul><li>可以通过实现 <code>Encoder</code> 和 <code>Decoder</code> 接口自定义编码器和解码器。</li></ul>        <h4 id="3-自定义拦截器"   >          <a href="#3-自定义拦截器" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-自定义拦截器" class="headerlink" title="(3) 自定义拦截器"></a><strong>(3) 自定义拦截器</strong></h4>      <ul><li>可以通过实现 <code>RequestInterceptor</code> 接口自定义拦截器。</li></ul>        <h4 id="4-日志配置"   >          <a href="#4-日志配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-日志配置" class="headerlink" title="(4) 日志配置"></a><strong>(4) 日志配置</strong></h4>      <ul><li>可以通过配置 <code>Logger.Level</code> 控制 Feign 的日志级别。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="6-Feign-的优缺点"   >          <a href="#6-Feign-的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Feign-的优缺点" class="headerlink" title="6. Feign 的优缺点"></a><strong>6. Feign 的优缺点</strong></h3>              <h4 id="1-优点"   >          <a href="#1-优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-优点" class="headerlink" title="(1) 优点"></a><strong>(1) 优点</strong></h4>      <ul><li><strong>声明式调用</strong>：简化 HTTP 请求的定义和调用。</li><li><strong>集成负载均衡</strong>：默认集成 Ribbon，支持客户端负载均衡。</li><li><strong>支持熔断和降级</strong>：集成 Hystrix，提供容错能力。</li><li><strong>易于扩展</strong>：支持自定义编码器、解码器、拦截器等。</li></ul>        <h4 id="2-缺点"   >          <a href="#2-缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a><strong>(2) 缺点</strong></h4>      <ul><li><strong>性能开销</strong>：动态代理和注解解析会带来一定的性能开销。</li><li><strong>学习成本</strong>：需要熟悉 Feign 的注解和配置。</li></ul><hr>        <h3 id="7-示例代码"   >          <a href="#7-示例代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-示例代码" class="headerlink" title="7. 示例代码"></a><strong>7. 示例代码</strong></h3>      <p>以下是一个完整的 Feign 示例：</p>        <h4 id="1-定义接口-1"   >          <a href="#1-定义接口-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义接口-1" class="headerlink" title="(1) 定义接口"></a><strong>(1) 定义接口</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;user-service&quot;, url = &quot;http://localhost:8080&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line">    User <span class="title function_">createUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-启用-Feign-客户端"   >          <a href="#2-启用-Feign-客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-启用-Feign-客户端" class="headerlink" title="(2) 启用 Feign 客户端"></a><strong>(2) 启用 Feign 客户端</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-调用-Feign-客户端"   >          <a href="#3-调用-Feign-客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-调用-Feign-客户端" class="headerlink" title="(3) 调用 Feign 客户端"></a><strong>(3) 调用 Feign 客户端</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceClient userServiceClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userServiceClient.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userServiceClient.createUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Feign 通过声明式 API 和动态代理机制，简化了 HTTP 请求的定义和调用。其核心组件包括注解处理器、动态代理、编码器、解码器、HTTP 客户端等。Feign 默认集成 Ribbon 和 Hystrix，支持负载均衡和熔断降级。理解 Feign 的工作原理及其核心机制，有助于更好地使用和扩展 Feign。</p>]]></content>
    
    
    <summary type="html">Feign的工作原理</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Feign" scheme="https://ljd0620.github.io/tags/Feign/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix的工作原理</title>
    <link href="https://ljd0620.github.io/2024/01/01/Hystrix%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://ljd0620.github.io/2024/01/01/Hystrix%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2024-01-01T04:20:08.000Z</published>
    <updated>2025-03-19T02:02:05.851Z</updated>
    
    <content type="html"><![CDATA[<p>Hystrix 是 Netflix 开源的一款容错库，主要用于处理分布式系统中的延迟和故障。其核心目标是<strong>防止雪崩效应</strong>，通过隔离、熔断、降级等机制，确保系统在部分服务不可用时仍能稳定运行。以下是 Hystrix 的工作原理及其核心机制的详细解析：</p><hr>        <h3 id="1-Hystrix-的核心目标"   >          <a href="#1-Hystrix-的核心目标" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Hystrix-的核心目标" class="headerlink" title="1. Hystrix 的核心目标"></a><strong>1. Hystrix 的核心目标</strong></h3>      <p>Hystrix 的设计目标是：</p><ol><li><strong>防止雪崩效应</strong>：通过隔离和熔断机制，避免单个服务的故障导致整个系统崩溃。</li><li><strong>快速失败</strong>：在服务不可用时，快速返回降级结果，而不是让请求长时间等待。</li><li><strong>自动恢复</strong>：当服务恢复后，自动重新尝试调用。</li></ol><hr>        <h3 id="2-Hystrix-的核心机制"   >          <a href="#2-Hystrix-的核心机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Hystrix-的核心机制" class="headerlink" title="2. Hystrix 的核心机制"></a><strong>2. Hystrix 的核心机制</strong></h3>      <p>Hystrix 通过以下核心机制实现其目标：</p>        <h4 id="1-命令模式（Command-Pattern）"   >          <a href="#1-命令模式（Command-Pattern）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-命令模式（Command-Pattern）" class="headerlink" title="(1) 命令模式（Command Pattern）"></a><strong>(1) 命令模式（Command Pattern）</strong></h4>      <ul><li>Hystrix 将每个外部调用封装为一个 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code> 对象。</li><li>通过命令模式，Hystrix 可以对每个调用进行隔离、监控和控制。</li></ul>        <h4 id="2-线程池隔离（Thread-Pool-Isolation）"   >          <a href="#2-线程池隔离（Thread-Pool-Isolation）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-线程池隔离（Thread-Pool-Isolation）" class="headerlink" title="(2) 线程池隔离（Thread Pool Isolation）"></a><strong>(2) 线程池隔离（Thread Pool Isolation）</strong></h4>      <ul><li>Hystrix 为每个依赖服务分配独立的线程池，避免某个服务的故障影响其他服务。</li><li>默认情况下，Hystrix 使用线程池隔离，但也可以配置为信号量隔离。</li></ul>        <h4 id="3-熔断器（Circuit-Breaker）"   >          <a href="#3-熔断器（Circuit-Breaker）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-熔断器（Circuit-Breaker）" class="headerlink" title="(3) 熔断器（Circuit Breaker）"></a><strong>(3) 熔断器（Circuit Breaker）</strong></h4>      <ul><li>Hystrix 通过熔断器机制监控请求的成功与失败情况。</li><li>当失败率达到阈值时，熔断器打开，所有请求快速失败。</li><li>经过一段时间后，熔断器进入半开状态，允许部分请求通过以检测服务是否恢复。</li></ul>        <h4 id="4-降级（Fallback）"   >          <a href="#4-降级（Fallback）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-降级（Fallback）" class="headerlink" title="(4) 降级（Fallback）"></a><strong>(4) 降级（Fallback）</strong></h4>      <ul><li>当请求失败或熔断器打开时，Hystrix 会执行降级逻辑，返回一个默认值或错误信息。</li><li>降级逻辑可以是一个静态值、缓存数据或调用其他服务。</li></ul>        <h4 id="5-请求缓存（Request-Caching）"   >          <a href="#5-请求缓存（Request-Caching）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-请求缓存（Request-Caching）" class="headerlink" title="(5) 请求缓存（Request Caching）"></a><strong>(5) 请求缓存（Request Caching）</strong></h4>      <ul><li>Hystrix 支持对请求结果进行缓存，减少重复请求的开销。</li><li>缓存的生命周期与请求一致，请求结束后缓存失效。</li></ul>        <h4 id="6-请求合并（Request-Collapsing）"   >          <a href="#6-请求合并（Request-Collapsing）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-请求合并（Request-Collapsing）" class="headerlink" title="(6) 请求合并（Request Collapsing）"></a><strong>(6) 请求合并（Request Collapsing）</strong></h4>      <ul><li>Hystrix 支持将多个请求合并为一个批量请求，减少网络开销。</li><li>适用于高并发场景。</li></ul>        <h4 id="7-实时监控（Real-time-Monitoring）"   >          <a href="#7-实时监控（Real-time-Monitoring）" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-实时监控（Real-time-Monitoring）" class="headerlink" title="(7) 实时监控（Real-time Monitoring）"></a><strong>(7) 实时监控（Real-time Monitoring）</strong></h4>      <ul><li>Hystrix 提供了实时的监控数据，包括请求量、失败率、熔断器状态等。</li><li>可以通过 Hystrix Dashboard 或 Turbine 查看监控数据。</li></ul><hr>        <h3 id="3-Hystrix-的工作流程"   >          <a href="#3-Hystrix-的工作流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Hystrix-的工作流程" class="headerlink" title="3. Hystrix 的工作流程"></a><strong>3. Hystrix 的工作流程</strong></h3>      <p>以下是 Hystrix 的工作流程：</p><ol><li><p><strong>封装请求</strong>：</p><ul><li>将每个外部调用封装为 <code>HystrixCommand</code> 或 <code>HystrixObservableCommand</code>。</li></ul></li><li><p><strong>检查熔断器状态</strong>：</p><ul><li>如果熔断器打开，直接执行降级逻辑。</li><li>如果熔断器关闭，继续执行下一步。</li></ul></li><li><p><strong>检查线程池&#x2F;信号量资源</strong>：</p><ul><li>如果线程池或信号量资源已满，拒绝请求并执行降级逻辑。</li><li>如果资源可用，继续执行下一步。</li></ul></li><li><p><strong>执行请求</strong>：</p><ul><li>调用外部服务，获取结果。</li></ul></li><li><p><strong>统计请求结果</strong>：</p><ul><li>根据请求的成功与失败情况，更新熔断器的统计信息。</li></ul></li><li><p><strong>返回结果或降级</strong>：</p><ul><li>如果请求成功，返回结果。</li><li>如果请求失败或超时，执行降级逻辑。</li></ul></li><li><p><strong>更新熔断器状态</strong>：</p><ul><li>根据统计信息，决定是否打开或关闭熔断器。</li></ul></li></ol><hr>        <h3 id="4-Hystrix-的核心配置"   >          <a href="#4-Hystrix-的核心配置" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Hystrix-的核心配置" class="headerlink" title="4. Hystrix 的核心配置"></a><strong>4. Hystrix 的核心配置</strong></h3>      <p>Hystrix 的行为可以通过以下配置参数进行调整：</p><div class="table-container"><table><thead><tr><th>参数名</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>execution.isolation.strategy</code></td><td><code>THREAD</code></td><td>隔离策略（<code>THREAD</code> 或 <code>SEMAPHORE</code>）。</td></tr><tr><td><code>execution.isolation.thread.timeoutInMilliseconds</code></td><td><code>1000</code></td><td>请求超时时间（毫秒）。</td></tr><tr><td><code>circuitBreaker.enabled</code></td><td><code>true</code></td><td>是否启用熔断器。</td></tr><tr><td><code>circuitBreaker.requestVolumeThreshold</code></td><td><code>20</code></td><td>在时间窗口内触发熔断的最小请求数。</td></tr><tr><td><code>circuitBreaker.errorThresholdPercentage</code></td><td><code>50</code></td><td>触发熔断的失败率阈值（百分比）。</td></tr><tr><td><code>circuitBreaker.sleepWindowInMilliseconds</code></td><td><code>5000</code></td><td>熔断器打开后进入半开状态的时间窗口（毫秒）。</td></tr><tr><td><code>fallback.enabled</code></td><td><code>true</code></td><td>是否启用降级逻辑。</td></tr><tr><td><code>metrics.rollingStats.timeInMilliseconds</code></td><td><code>10000</code></td><td>统计时间窗口（毫秒）。</td></tr></tbody></table></div><hr>        <h3 id="5-Hystrix-的示例代码"   >          <a href="#5-Hystrix-的示例代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Hystrix-的示例代码" class="headerlink" title="5. Hystrix 的示例代码"></a><strong>5. Hystrix 的示例代码</strong></h3>      <p>以下是一个简单的 Hystrix 示例：</p>        <h4 id="1-定义-HystrixCommand"   >          <a href="#1-定义-HystrixCommand" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义-HystrixCommand" class="headerlink" title="(1) 定义 HystrixCommand"></a><strong>(1) 定义 HystrixCommand</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCommand</span> <span class="keyword">extends</span> <span class="title class_">HystrixCommand</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserCommand</span><span class="params">(UserService userService, Long userId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">&quot;UserGroup&quot;</span>));</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> User <span class="title function_">getFallback</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1L</span>, <span class="string">&quot;Fallback User&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-使用-HystrixCommand"   >          <a href="#2-使用-HystrixCommand" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用-HystrixCommand" class="headerlink" title="(2) 使用 HystrixCommand"></a><strong>(2) 使用 HystrixCommand</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCommand</span>(userService, <span class="number">1L</span>).execute();</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="6-Hystrix-的优缺点"   >          <a href="#6-Hystrix-的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Hystrix-的优缺点" class="headerlink" title="6. Hystrix 的优缺点"></a><strong>6. Hystrix 的优缺点</strong></h3>              <h4 id="1-优点"   >          <a href="#1-优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-优点" class="headerlink" title="(1) 优点"></a><strong>(1) 优点</strong></h4>      <ul><li><strong>防止雪崩效应</strong>：通过隔离和熔断机制，避免系统崩溃。</li><li><strong>快速失败</strong>：在服务不可用时，快速返回降级结果。</li><li><strong>自动恢复</strong>：当服务恢复后，自动重新尝试调用。</li><li><strong>实时监控</strong>：提供丰富的监控数据，便于问题排查。</li></ul>        <h4 id="2-缺点"   >          <a href="#2-缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a><strong>(2) 缺点</strong></h4>      <ul><li><strong>配置复杂</strong>：需要根据业务场景调整大量参数。</li><li><strong>性能开销</strong>：线程池隔离和熔断器机制会带来一定的性能开销。</li><li><strong>已停止维护</strong>：Hystrix 已停止维护，建议使用 Resilience4j 等替代方案。</li></ul><hr>        <h3 id="7-Hystrix-的替代方案"   >          <a href="#7-Hystrix-的替代方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-Hystrix-的替代方案" class="headerlink" title="7. Hystrix 的替代方案"></a><strong>7. Hystrix 的替代方案</strong></h3>      <p>由于 Hystrix 已停止维护，以下是一些常见的替代方案：</p><ol><li><p><strong>Resilience4j</strong>：</p><ul><li>轻量级的容错库，支持熔断、限流、重试等功能。</li><li>与 Spring Cloud 集成良好。</li></ul></li><li><p><strong>Sentinel</strong>：</p><ul><li>阿里巴巴开源的流量控制和熔断降级框架。</li><li>支持实时监控和动态配置。</li></ul></li><li><p><strong>Spring Cloud Circuit Breaker</strong>：</p><ul><li>Spring Cloud 提供的统一熔断器抽象，支持多种实现（如 Resilience4j、Sentinel 等）。</li></ul></li></ol><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Hystrix 通过命令模式、线程池隔离、熔断器、降级等机制，有效防止了分布式系统中的雪崩效应。其核心思想是快速失败和自动恢复，确保系统在高并发或服务故障时仍能稳定运行。尽管 Hystrix 已停止维护，但其设计思想和实现机制仍然值得学习和借鉴。</p>]]></content>
    
    
    <summary type="html">Hystrix的工作原理</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="微服务" scheme="https://ljd0620.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Hystrix" scheme="https://ljd0620.github.io/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch深度分页优化</title>
    <link href="https://ljd0620.github.io/2023/12/12/Elasticsearch%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/"/>
    <id>https://ljd0620.github.io/2023/12/12/Elasticsearch%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/</id>
    <published>2023-12-12T04:32:39.000Z</published>
    <updated>2025-03-19T02:01:50.700Z</updated>
    
    <content type="html"><![CDATA[<p>在 Elasticsearch 中，深度分页（Deep Pagination）是指查询结果的分页参数 <code>from</code> 值较大的情况（例如 <code>from=10000</code>）。深度分页会导致性能问题，因为 Elasticsearch 需要从每个分片中获取大量的文档，并在协调节点上合并和排序这些文档，这会消耗大量的内存和 CPU 资源。以下是优化 Elasticsearch 深度分页性能的几种常见策略：</p><hr>        <h3 id="1-避免深度分页"   >          <a href="#1-避免深度分页" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-避免深度分页" class="headerlink" title="1. 避免深度分页"></a><strong>1. 避免深度分页</strong></h3>      <p>深度分页通常不是用户实际需要的场景。可以通过以下方式避免深度分页：</p><ul><li><strong>限制分页深度</strong>：<ul><li>在前端或 API 层面限制 <code>from</code> 的最大值（例如 <code>from &lt;= 1000</code>）。</li></ul></li><li><strong>优化用户体验</strong>：<ul><li>提供更精确的搜索条件，减少结果集的大小。</li><li>使用排序和过滤条件，帮助用户快速定位所需数据。</li></ul></li></ul><hr>        <h3 id="2-使用-search-after-参数"   >          <a href="#2-使用-search-after-参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用-search-after-参数" class="headerlink" title="2. 使用 search_after 参数"></a><strong>2. 使用 <code>search_after</code> 参数</strong></h3>      <p><code>search_after</code> 是一种基于游标的分页方式，适合深度分页场景。它通过指定上一页最后一条记录的排序值来获取下一页数据，避免了传统分页的性能问题。</p>        <h4 id="使用方法："   >          <a href="#使用方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>在查询中指定排序字段（必须包含唯一字段，如 <code>_id</code>）。</li><li>使用 <code>search_after</code> 参数传递上一页最后一条记录的排序值。</li></ol>        <h4 id="示例："   >          <a href="#示例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1696166400000</span><span class="punctuation">,</span> <span class="string">&quot;abc123&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点："   >          <a href="#优点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>避免了传统分页的性能瓶颈。</li><li>适合深度分页和实时数据查询。</li></ul>        <h4 id="缺点："   >          <a href="#缺点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>需要客户端维护游标状态。</li><li>不支持跳转到任意页码。</li></ul><hr>        <h3 id="3-使用滚动查询（Scroll-API）"   >          <a href="#3-使用滚动查询（Scroll-API）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-使用滚动查询（Scroll-API）" class="headerlink" title="3. 使用滚动查询（Scroll API）"></a><strong>3. 使用滚动查询（Scroll API）</strong></h3>      <p>滚动查询（Scroll API）适合一次性获取大量数据的场景（如数据导出）。它通过创建一个快照（Snapshot）来保持查询的上下文，允许分批次获取数据。</p>        <h4 id="使用方法：-1"   >          <a href="#使用方法：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：-1" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>初始化滚动查询，设置滚动时间窗口（如 <code>1m</code>）。</li><li>使用 <code>scroll_id</code> 获取下一批数据。</li></ol>        <h4 id="示例：-1"   >          <a href="#示例：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <p>初始化滚动查询：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /my_index/_search?scroll=<span class="number">1</span>m</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure><p>获取下一批数据：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_search/scroll</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scroll&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scroll_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAABIFj...&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点：-1"   >          <a href="#优点：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>适合一次性获取大量数据的场景。</li><li>避免了深度分页的性能问题。</li></ul>        <h4 id="缺点：-1"   >          <a href="#缺点：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-1" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>滚动查询会占用资源，直到滚动时间窗口过期。</li><li>不适合实时分页场景。</li></ul><hr>        <h3 id="4-使用-Point-In-Time（PIT）"   >          <a href="#4-使用-Point-In-Time（PIT）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-使用-Point-In-Time（PIT）" class="headerlink" title="4. 使用 Point In Time（PIT）"></a><strong>4. 使用 <code>Point In Time</code>（PIT）</strong></h3>      <p><code>Point In Time</code>（PIT）是 Elasticsearch 7.10 引入的功能，用于在滚动查询的基础上提供更高效的分页方式。它通过创建一个时间点视图（Point-in-Time View），允许在固定的数据视图上进行分页。</p>        <h4 id="使用方法：-2"   >          <a href="#使用方法：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：-2" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>创建一个 PIT。</li><li>使用 <code>search_after</code> 和 PIT 进行分页。</li></ol>        <h4 id="示例：-2"   >          <a href="#示例：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <p>创建 PIT：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /my_index/_pit?keep_alive=<span class="number">1</span>m</span><br></pre></td></tr></table></div></figure><p>使用 PIT 和 <code>search_after</code> 分页：</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;pit&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keep_alive&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1m&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;search_after&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">1696166400000</span><span class="punctuation">,</span> <span class="string">&quot;abc123&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点：-2"   >          <a href="#优点：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-2" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>提供更高效的分页方式。</li><li>适合实时分页场景。</li></ul>        <h4 id="缺点：-2"   >          <a href="#缺点：-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-2" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>需要 Elasticsearch 7.10 及以上版本。</li></ul><hr>        <h3 id="5-使用-slice-分片查询"   >          <a href="#5-使用-slice-分片查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-使用-slice-分片查询" class="headerlink" title="5. 使用 slice 分片查询"></a><strong>5. 使用 <code>slice</code> 分片查询</strong></h3>      <p><code>slice</code> 分片查询允许将查询分成多个子查询，每个子查询处理数据的一个子集。通过并行执行这些子查询，可以提高查询性能。</p>        <h4 id="使用方法：-3"   >          <a href="#使用方法：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用方法：-3" class="headerlink" title="使用方法："></a><strong>使用方法</strong>：</h4>      <ol><li>指定 <code>slice</code> 参数，将查询分成多个子查询。</li><li>并行执行这些子查询。</li></ol>        <h4 id="示例：-3"   >          <a href="#示例：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-3" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;slice&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="优点：-3"   >          <a href="#优点：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-3" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>提高查询性能，适合大数据集。</li><li>可以并行执行多个子查询。</li></ul>        <h4 id="缺点：-3"   >          <a href="#缺点：-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-3" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>需要客户端合并多个子查询的结果。</li><li>不适合实时分页场景。</li></ul><hr>        <h3 id="6-优化索引设计"   >          <a href="#6-优化索引设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-优化索引设计" class="headerlink" title="6. 优化索引设计"></a><strong>6. 优化索引设计</strong></h3>      <p>通过优化索引设计，可以减少查询时需要扫描的数据量，提高查询性能。</p>        <h4 id="优化策略："   >          <a href="#优化策略：" class="heading-link"><i class="fas fa-link"></i></a><a href="#优化策略：" class="headerlink" title="优化策略："></a><strong>优化策略</strong>：</h4>      <ul><li><strong>使用合适的字段类型</strong>：<ul><li>选择合适的数据类型（如 <code>keyword</code>、<code>text</code>、<code>date</code> 等），避免不必要的分词和分析。</li></ul></li><li><strong>使用过滤条件</strong>：<ul><li>在查询中添加过滤条件，减少需要扫描的数据量。</li></ul></li><li><strong>使用索引模板</strong>：<ul><li>使用索引模板统一管理索引的配置和映射。</li></ul></li></ul><hr>        <h3 id="7-使用缓存"   >          <a href="#7-使用缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-使用缓存" class="headerlink" title="7. 使用缓存"></a><strong>7. 使用缓存</strong></h3>      <p>对于不经常变化的数据，可以使用缓存（如 Redis）来存储分页结果，减少 Elasticsearch 的查询压力。</p>        <h4 id="示例：-4"   >          <a href="#示例：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#示例：-4" class="headerlink" title="示例："></a><strong>示例</strong>：</h4>      <ol><li>将查询结果缓存到 Redis 中。</li><li>从缓存中获取分页数据。</li></ol>        <h4 id="优点：-4"   >          <a href="#优点：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点：-4" class="headerlink" title="优点："></a><strong>优点</strong>：</h4>      <ul><li>减少 Elasticsearch 的查询压力。</li><li>提高查询性能。</li></ul>        <h4 id="缺点：-4"   >          <a href="#缺点：-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点：-4" class="headerlink" title="缺点："></a><strong>缺点</strong>：</h4>      <ul><li>数据变化时需要更新缓存。</li><li>适合不经常变化的数据。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>优化 Elasticsearch 深度分页性能的常见策略包括：</p><ol><li><strong>避免深度分页</strong>：限制分页深度，优化用户体验。</li><li><strong>使用 <code>search_after</code></strong>：适合深度分页和实时数据查询。</li><li><strong>使用滚动查询（Scroll API）</strong>：适合一次性获取大量数据的场景。</li><li><strong>使用 <code>Point In Time</code>（PIT）</strong>：提供更高效的分页方式，适合实时分页场景。</li><li><strong>使用 <code>slice</code> 分片查询</strong>：提高查询性能，适合大数据集。</li><li><strong>优化索引设计</strong>：减少查询时需要扫描的数据量。</li><li><strong>使用缓存</strong>：减少 Elasticsearch 的查询压力，适合不经常变化的数据。</li></ol><p>根据具体的业务场景和数据特点，选择合适的优化策略，可以显著提高 Elasticsearch 深度分页的性能。</p>]]></content>
    
    
    <summary type="html">Elasticsearch深度分页优化</summary>
    
    
    
    <category term="搜索引擎" scheme="https://ljd0620.github.io/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://ljd0620.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>JVM性能调优策略</title>
    <link href="https://ljd0620.github.io/2023/12/10/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/"/>
    <id>https://ljd0620.github.io/2023/12/10/JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5/</id>
    <published>2023-12-10T04:28:05.000Z</published>
    <updated>2025-03-19T02:02:29.960Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 性能调优是 Java 应用程序优化的重要环节，旨在通过调整 JVM 参数、优化代码和选择合适的垃圾收集器，提升应用程序的性能、减少内存占用、降低垃圾回收的开销。以下是 JVM 性能调优的主要策略及其详细解析：</p><hr>        <h3 id="1-内存调优"   >          <a href="#1-内存调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-内存调优" class="headerlink" title="1. 内存调优"></a><strong>1. 内存调优</strong></h3>      <p>内存调优是 JVM 性能调优的核心，主要目标是合理分配堆内存、方法区和直接内存，避免 <code>OutOfMemoryError</code> 和频繁的垃圾回收。</p>        <h4 id="1-堆内存调优"   >          <a href="#1-堆内存调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-堆内存调优" class="headerlink" title="(1) 堆内存调优"></a><strong>(1) 堆内存调优</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-Xms</code>：设置堆的初始大小（如 <code>-Xms512m</code>）。</li><li><code>-Xmx</code>：设置堆的最大大小（如 <code>-Xmx2048m</code>）。</li></ul></li><li><strong>建议</strong>：<ul><li>将 <code>-Xms</code> 和 <code>-Xmx</code> 设置为相同的值，避免堆内存动态扩展带来的性能开销。</li><li>根据应用程序的内存需求，合理设置堆大小，避免过小导致频繁 GC 或过大导致内存浪费。</li></ul></li></ul>        <h4 id="2-新生代和老年代调优"   >          <a href="#2-新生代和老年代调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-新生代和老年代调优" class="headerlink" title="(2) 新生代和老年代调优"></a><strong>(2) 新生代和老年代调优</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-XX:NewRatio</code>：设置新生代与老年代的比例（如 <code>-XX:NewRatio=2</code> 表示新生代占 1&#x2F;3，老年代占 2&#x2F;3）。</li><li><code>-XX:SurvivorRatio</code>：设置 Eden 区与 Survivor 区的比例（如 <code>-XX:SurvivorRatio=8</code> 表示 Eden 区占 8&#x2F;10，每个 Survivor 区占 1&#x2F;10）。</li></ul></li><li><strong>建议</strong>：<ul><li>根据对象的生命周期调整新生代和老年代的比例，避免老年代过早被填满。</li><li>根据对象的存活率调整 Survivor 区的大小，避免对象过早进入老年代。</li></ul></li></ul>        <h4 id="3-方法区调优"   >          <a href="#3-方法区调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-方法区调优" class="headerlink" title="(3) 方法区调优"></a><strong>(3) 方法区调优</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-XX:MetaspaceSize</code>：设置元空间的初始大小（如 <code>-XX:MetaspaceSize=128m</code>）。</li><li><code>-XX:MaxMetaspaceSize</code>：设置元空间的最大大小（如 <code>-XX:MaxMetaspaceSize=512m</code>）。</li></ul></li><li><strong>建议</strong>：<ul><li>根据应用程序的类加载需求，合理设置元空间大小，避免频繁的元空间垃圾回收。</li></ul></li></ul>        <h4 id="4-直接内存调优"   >          <a href="#4-直接内存调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-直接内存调优" class="headerlink" title="(4) 直接内存调优"></a><strong>(4) 直接内存调优</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-XX:MaxDirectMemorySize</code>：设置直接内存的最大大小（如 <code>-XX:MaxDirectMemorySize=512m</code>）。</li></ul></li><li><strong>建议</strong>：<ul><li>根据 NIO 操作的需求，合理设置直接内存大小，避免直接内存不足。</li></ul></li></ul><hr>        <h3 id="2-垃圾回收调优"   >          <a href="#2-垃圾回收调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-垃圾回收调优" class="headerlink" title="2. 垃圾回收调优"></a><strong>2. 垃圾回收调优</strong></h3>      <p>垃圾回收调优的目标是减少垃圾回收的频率和时间，提高应用程序的吞吐量和响应速度。</p>        <h4 id="1-选择合适的垃圾收集器"   >          <a href="#1-选择合适的垃圾收集器" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-选择合适的垃圾收集器" class="headerlink" title="(1) 选择合适的垃圾收集器"></a><strong>(1) 选择合适的垃圾收集器</strong></h4>      <ul><li><strong>串行收集器（Serial GC）</strong>：<ul><li>适用于单核 CPU 或小型应用。</li><li>参数：<code>-XX:+UseSerialGC</code>。</li></ul></li><li><strong>并行收集器（Parallel GC）</strong>：<ul><li>适用于多核 CPU 且追求高吞吐量的应用。</li><li>参数：<code>-XX:+UseParallelGC</code>。</li></ul></li><li><strong>CMS 收集器（Concurrent Mark Sweep GC）</strong>：<ul><li>适用于追求低延迟的应用。</li><li>参数：<code>-XX:+UseConcMarkSweepGC</code>。</li></ul></li><li><strong>G1 收集器（Garbage-First GC）</strong>：<ul><li>适用于大内存、低延迟的应用。</li><li>参数：<code>-XX:+UseG1GC</code>。</li></ul></li><li><strong>ZGC 收集器（Z Garbage Collector）</strong>：<ul><li>适用于超大内存、极低延迟的应用。</li><li>参数：<code>-XX:+UseZGC</code>。</li></ul></li></ul>        <h4 id="2-调整垃圾回收参数"   >          <a href="#2-调整垃圾回收参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-调整垃圾回收参数" class="headerlink" title="(2) 调整垃圾回收参数"></a><strong>(2) 调整垃圾回收参数</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-XX:MaxGCPauseMillis</code>：设置最大垃圾回收停顿时间（如 <code>-XX:MaxGCPauseMillis=200</code>）。</li><li><code>-XX:GCTimeRatio</code>：设置垃圾回收时间与应用程序时间的比例（如 <code>-XX:GCTimeRatio=19</code> 表示垃圾回收时间占 5%）。</li></ul></li><li><strong>建议</strong>：<ul><li>根据应用程序的性能需求，合理设置垃圾回收参数，平衡吞吐量和延迟。</li></ul></li></ul><hr>        <h3 id="3-线程调优"   >          <a href="#3-线程调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-线程调优" class="headerlink" title="3. 线程调优"></a><strong>3. 线程调优</strong></h3>      <p>线程调优的目标是合理配置线程栈大小和线程池参数，避免 <code>StackOverflowError</code> 和线程资源浪费。</p>        <h4 id="1-线程栈大小调优"   >          <a href="#1-线程栈大小调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-线程栈大小调优" class="headerlink" title="(1) 线程栈大小调优"></a><strong>(1) 线程栈大小调优</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-Xss</code>：设置线程栈的大小（如 <code>-Xss1m</code>）。</li></ul></li><li><strong>建议</strong>：<ul><li>根据应用程序的线程数量和递归深度，合理设置线程栈大小，避免栈溢出或内存浪费。</li></ul></li></ul>        <h4 id="2-线程池调优"   >          <a href="#2-线程池调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-线程池调优" class="headerlink" title="(2) 线程池调优"></a><strong>(2) 线程池调优</strong></h4>      <ul><li><strong>参数</strong>：<ul><li>核心线程数、最大线程数、队列大小等。</li></ul></li><li><strong>建议</strong>：<ul><li>根据任务的类型和数量，合理配置线程池参数，避免线程资源浪费或任务堆积。</li></ul></li></ul><hr>        <h3 id="4-JIT-编译器调优"   >          <a href="#4-JIT-编译器调优" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-JIT-编译器调优" class="headerlink" title="4. JIT 编译器调优"></a><strong>4. JIT 编译器调优</strong></h3>      <p>JIT（Just-In-Time）编译器是 JVM 性能优化的关键，通过将热点代码编译为本地机器码，提高执行效率。</p>        <h4 id="1-启用分层编译"   >          <a href="#1-启用分层编译" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-启用分层编译" class="headerlink" title="(1) 启用分层编译"></a><strong>(1) 启用分层编译</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-XX:+TieredCompilation</code>：启用分层编译。</li></ul></li><li><strong>建议</strong>：<ul><li>分层编译可以在启动阶段使用解释器执行代码，在运行阶段使用 JIT 编译器优化热点代码。</li></ul></li></ul>        <h4 id="2-调整编译阈值"   >          <a href="#2-调整编译阈值" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-调整编译阈值" class="headerlink" title="(2) 调整编译阈值"></a><strong>(2) 调整编译阈值</strong></h4>      <ul><li><strong>参数</strong>：<ul><li><code>-XX:CompileThreshold</code>：设置方法调用次数达到该值时触发 JIT 编译（如 <code>-XX:CompileThreshold=10000</code>）。</li></ul></li><li><strong>建议</strong>：<ul><li>根据应用程序的特点，合理调整编译阈值，避免过早或过晚触发 JIT 编译。</li></ul></li></ul><hr>        <h3 id="5-监控与诊断"   >          <a href="#5-监控与诊断" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-监控与诊断" class="headerlink" title="5. 监控与诊断"></a><strong>5. 监控与诊断</strong></h3>      <p>通过监控和诊断工具，可以实时了解 JVM 的运行状态，发现性能瓶颈。</p>        <h4 id="1-使用-JVM-内置工具"   >          <a href="#1-使用-JVM-内置工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用-JVM-内置工具" class="headerlink" title="(1) 使用 JVM 内置工具"></a><strong>(1) 使用 JVM 内置工具</strong></h4>      <ul><li><strong>jstat</strong>：监控 JVM 的内存和垃圾回收情况。</li><li><strong>jmap</strong>：生成堆内存快照。</li><li><strong>jstack</strong>：生成线程快照。</li><li><strong>jvisualvm</strong>：图形化监控工具。</li></ul>        <h4 id="2-使用第三方工具"   >          <a href="#2-使用第三方工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用第三方工具" class="headerlink" title="(2) 使用第三方工具"></a><strong>(2) 使用第三方工具</strong></h4>      <ul><li><strong>Prometheus + Grafana</strong>：实时监控和可视化 JVM 指标。</li><li><strong>Arthas</strong>：动态诊断 Java 应用程序。</li></ul><hr>        <h3 id="6-代码优化"   >          <a href="#6-代码优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-代码优化" class="headerlink" title="6. 代码优化"></a><strong>6. 代码优化</strong></h3>      <p>JVM 调优不仅仅是参数调整，还需要结合代码优化，从源头上减少资源消耗。</p>        <h4 id="1-减少对象创建"   >          <a href="#1-减少对象创建" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-减少对象创建" class="headerlink" title="(1) 减少对象创建"></a><strong>(1) 减少对象创建</strong></h4>      <ul><li>避免频繁创建临时对象，使用对象池或缓存。</li></ul>        <h4 id="2-优化数据结构"   >          <a href="#2-优化数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-优化数据结构" class="headerlink" title="(2) 优化数据结构"></a><strong>(2) 优化数据结构</strong></h4>      <ul><li>根据场景选择合适的数据结构，如使用 <code>ArrayList</code> 代替 <code>LinkedList</code>。</li></ul>        <h4 id="3-减少锁竞争"   >          <a href="#3-减少锁竞争" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-减少锁竞争" class="headerlink" title="(3) 减少锁竞争"></a><strong>(3) 减少锁竞争</strong></h4>      <ul><li>使用无锁数据结构（如 <code>ConcurrentHashMap</code>）或减小锁粒度。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>JVM 性能调优是一个系统性的工作，需要从内存、垃圾回收、线程、JIT 编译器和代码等多个方面进行优化。通过合理配置 JVM 参数、选择合适的垃圾收集器、优化代码结构，可以显著提高 Java 应用程序的性能和稳定性。同时，结合监控和诊断工具，可以实时发现和解决性能瓶颈。</p>]]></content>
    
    
    <summary type="html">JVM性能调优策略</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://ljd0620.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch的工作原理</title>
    <link href="https://ljd0620.github.io/2023/11/05/Elasticsearch%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://ljd0620.github.io/2023/11/05/Elasticsearch%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2023-11-05T04:22:33.000Z</published>
    <updated>2025-03-19T02:01:53.565Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 是一个分布式的搜索和分析引擎，基于 Apache Lucene 构建。它能够快速地存储、搜索和分析大量数据，广泛应用于日志分析、全文搜索、实时数据分析等场景。以下是 Elasticsearch 的工作原理及其核心机制的详细解析：</p><hr>        <h3 id="1-Elasticsearch-的核心概念"   >          <a href="#1-Elasticsearch-的核心概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-Elasticsearch-的核心概念" class="headerlink" title="1. Elasticsearch 的核心概念"></a><strong>1. Elasticsearch 的核心概念</strong></h3>      <p>在理解 Elasticsearch 的工作原理之前，需要先了解其核心概念：</p>        <h4 id="1-文档（Document）"   >          <a href="#1-文档（Document）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-文档（Document）" class="headerlink" title="(1) 文档（Document）"></a><strong>(1) 文档（Document）</strong></h4>      <ul><li>Elasticsearch 中的基本数据单元，类似于关系数据库中的一行记录。</li><li>文档是以 JSON 格式存储的。</li></ul>        <h4 id="2-索引（Index）"   >          <a href="#2-索引（Index）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-索引（Index）" class="headerlink" title="(2) 索引（Index）"></a><strong>(2) 索引（Index）</strong></h4>      <ul><li>索引是文档的集合，类似于关系数据库中的表。</li><li>每个索引有一个唯一的名称，用于标识和查询。</li></ul>        <h4 id="3-类型（Type）（已弃用）"   >          <a href="#3-类型（Type）（已弃用）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-类型（Type）（已弃用）" class="headerlink" title="(3) 类型（Type）（已弃用）"></a><strong>(3) 类型（Type）</strong>（已弃用）</h4>      <ul><li>在早期版本中，索引可以包含多个类型，类似于关系数据库中的表结构。</li><li>从 Elasticsearch 7.x 开始，类型已被弃用，每个索引只能包含一个类型 <code>_doc</code>。</li></ul>        <h4 id="4-分片（Shard）"   >          <a href="#4-分片（Shard）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-分片（Shard）" class="headerlink" title="(4) 分片（Shard）"></a><strong>(4) 分片（Shard）</strong></h4>      <ul><li>索引可以被分成多个分片，每个分片是一个独立的 Lucene 索引。</li><li>分片分为主分片（Primary Shard）和副本分片（Replica Shard）。</li></ul>        <h4 id="5-节点（Node）"   >          <a href="#5-节点（Node）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-节点（Node）" class="headerlink" title="(5) 节点（Node）"></a><strong>(5) 节点（Node）</strong></h4>      <ul><li>一个运行中的 Elasticsearch 实例称为节点。</li><li>节点可以加入集群（Cluster），集群由一个或多个节点组成。</li></ul>        <h4 id="6-集群（Cluster）"   >          <a href="#6-集群（Cluster）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-集群（Cluster）" class="headerlink" title="(6) 集群（Cluster）"></a><strong>(6) 集群（Cluster）</strong></h4>      <ul><li>集群是一个或多个节点的集合，共同存储数据并提供搜索服务。</li><li>集群有一个唯一的名称，默认名称为 <code>elasticsearch</code>。</li></ul><hr>        <h3 id="2-Elasticsearch-的工作原理"   >          <a href="#2-Elasticsearch-的工作原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Elasticsearch-的工作原理" class="headerlink" title="2. Elasticsearch 的工作原理"></a><strong>2. Elasticsearch 的工作原理</strong></h3>      <p>Elasticsearch 的工作原理可以分为以下几个部分：</p>        <h4 id="1-数据写入"   >          <a href="#1-数据写入" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-数据写入" class="headerlink" title="(1) 数据写入"></a><strong>(1) 数据写入</strong></h4>      <ol><li><strong>客户端发送请求</strong>：<ul><li>客户端向 Elasticsearch 发送写入请求（如插入、更新、删除文档）。</li></ul></li><li><strong>路由到主分片</strong>：<ul><li>Elasticsearch 根据文档的 <code>_id</code> 和索引的分片数量，计算文档应存储的主分片。</li></ul></li><li><strong>写入主分片</strong>：<ul><li>主分片将文档写入 Lucene 索引，并生成倒排索引。</li></ul></li><li><strong>同步副本分片</strong>：<ul><li>主分片将数据同步到副本分片，确保数据冗余和高可用性。</li></ul></li><li><strong>返回响应</strong>：<ul><li>客户端收到写入成功的响应。</li></ul></li></ol>        <h4 id="2-数据搜索"   >          <a href="#2-数据搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据搜索" class="headerlink" title="(2) 数据搜索"></a><strong>(2) 数据搜索</strong></h4>      <ol><li><strong>客户端发送请求</strong>：<ul><li>客户端向 Elasticsearch 发送搜索请求。</li></ul></li><li><strong>路由到所有分片</strong>：<ul><li>Elasticsearch 将搜索请求发送到索引的所有分片（主分片和副本分片）。</li></ul></li><li><strong>执行搜索</strong>：<ul><li>每个分片在本地执行搜索，并返回结果。</li></ul></li><li><strong>合并结果</strong>：<ul><li>Elasticsearch 将各个分片的结果合并，排序后返回给客户端。</li></ul></li></ol>        <h4 id="3-数据存储"   >          <a href="#3-数据存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-数据存储" class="headerlink" title="(3) 数据存储"></a><strong>(3) 数据存储</strong></h4>      <ul><li>Elasticsearch 使用 Lucene 作为底层存储引擎。</li><li>数据以倒排索引（Inverted Index）的形式存储，支持高效的全文搜索。</li></ul>        <h4 id="4-数据分布"   >          <a href="#4-数据分布" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-数据分布" class="headerlink" title="(4) 数据分布"></a><strong>(4) 数据分布</strong></h4>      <ul><li>Elasticsearch 是一个分布式系统，数据分布在多个节点和分片上。</li><li>通过分片和副本机制，Elasticsearch 实现了数据的高可用性和扩展性。</li></ul><hr>        <h3 id="3-Elasticsearch-的核心机制"   >          <a href="#3-Elasticsearch-的核心机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Elasticsearch-的核心机制" class="headerlink" title="3. Elasticsearch 的核心机制"></a><strong>3. Elasticsearch 的核心机制</strong></h3>      <p>以下是 Elasticsearch 的核心机制及其实现原理：</p>        <h4 id="1-倒排索引（Inverted-Index）"   >          <a href="#1-倒排索引（Inverted-Index）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-倒排索引（Inverted-Index）" class="headerlink" title="(1) 倒排索引（Inverted Index）"></a><strong>(1) 倒排索引（Inverted Index）</strong></h4>      <ul><li><strong>定义</strong>：<ul><li>倒排索引是一种数据结构，用于快速查找包含某个词条的文档。</li><li>倒排索引由词条词典（Term Dictionary）和倒排列表（Posting List）组成。</li></ul></li><li><strong>示例</strong>：<ul><li>文档 1：<code>&#123;&quot;content&quot;: &quot;hello world&quot;&#125;</code></li><li>文档 2：<code>&#123;&quot;content&quot;: &quot;hello elasticsearch&quot;&#125;</code></li><li>倒排索引：<br>hello -&gt; [1, 2]<br>world -&gt; [1]<br>elasticsearch -&gt; [2]</li></ul></li></ul>        <h4 id="2-分片和副本"   >          <a href="#2-分片和副本" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-分片和副本" class="headerlink" title="(2) 分片和副本"></a><strong>(2) 分片和副本</strong></h4>      <ul><li><strong>主分片（Primary Shard）</strong>：<ul><li>每个索引被分成多个主分片，主分片负责数据的写入和搜索。</li></ul></li><li><strong>副本分片（Replica Shard）</strong>：<ul><li>每个主分片可以有多个副本分片，副本分片提供数据冗余和高可用性。</li></ul></li></ul>        <h4 id="3-分布式搜索"   >          <a href="#3-分布式搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-分布式搜索" class="headerlink" title="(3) 分布式搜索"></a><strong>(3) 分布式搜索</strong></h4>      <ul><li><strong>查询阶段（Query Phase）</strong>：<ul><li>客户端发送搜索请求，Elasticsearch 将请求路由到所有分片。</li><li>每个分片在本地执行搜索，并返回结果。</li></ul></li><li><strong>取回阶段（Fetch Phase）</strong>：<ul><li>Elasticsearch 将各个分片的结果合并，排序后返回给客户端。</li></ul></li></ul>        <h4 id="4-近实时搜索（Near-Real-Time-Search）"   >          <a href="#4-近实时搜索（Near-Real-Time-Search）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-近实时搜索（Near-Real-Time-Search）" class="headerlink" title="(4) 近实时搜索（Near Real-Time Search）"></a><strong>(4) 近实时搜索（Near Real-Time Search）</strong></h4>      <ul><li><strong>刷新（Refresh）</strong>：<ul><li>Elasticsearch 默认每隔 1 秒刷新一次索引，使新写入的文档可被搜索。</li></ul></li><li><strong>事务日志（Translog）</strong>：<ul><li>事务日志用于保证数据的持久性，在刷新索引之前，数据会先写入事务日志。</li></ul></li></ul>        <h4 id="5-集群发现和选举"   >          <a href="#5-集群发现和选举" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-集群发现和选举" class="headerlink" title="(5) 集群发现和选举"></a><strong>(5) 集群发现和选举</strong></h4>      <ul><li><strong>集群发现</strong>：<ul><li>Elasticsearch 使用 Zen Discovery 机制发现集群中的节点。</li></ul></li><li><strong>主节点选举</strong>：<ul><li>集群中的节点通过选举产生主节点（Master Node），主节点负责管理集群状态。</li></ul></li></ul><hr>        <h3 id="4-Elasticsearch-的架构"   >          <a href="#4-Elasticsearch-的架构" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Elasticsearch-的架构" class="headerlink" title="4. Elasticsearch 的架构"></a><strong>4. Elasticsearch 的架构</strong></h3>      <p>Elasticsearch 的架构可以分为以下几个部分：</p>        <h4 id="1-客户端节点（Client-Node）"   >          <a href="#1-客户端节点（Client-Node）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-客户端节点（Client-Node）" class="headerlink" title="(1) 客户端节点（Client Node）"></a><strong>(1) 客户端节点（Client Node）</strong></h4>      <ul><li>负责接收客户端的请求，并将请求路由到数据节点。</li></ul>        <h4 id="2-数据节点（Data-Node）"   >          <a href="#2-数据节点（Data-Node）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据节点（Data-Node）" class="headerlink" title="(2) 数据节点（Data Node）"></a><strong>(2) 数据节点（Data Node）</strong></h4>      <ul><li>负责存储数据，并执行搜索和聚合操作。</li></ul>        <h4 id="3-主节点（Master-Node）"   >          <a href="#3-主节点（Master-Node）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-主节点（Master-Node）" class="headerlink" title="(3) 主节点（Master Node）"></a><strong>(3) 主节点（Master Node）</strong></h4>      <ul><li>负责管理集群状态，如创建索引、分配分片等。</li></ul>        <h4 id="4-协调节点（Coordinating-Node）"   >          <a href="#4-协调节点（Coordinating-Node）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-协调节点（Coordinating-Node）" class="headerlink" title="(4) 协调节点（Coordinating Node）"></a><strong>(4) 协调节点（Coordinating Node）</strong></h4>      <ul><li>负责协调搜索请求，合并各个分片的结果。</li></ul><hr>        <h3 id="5-Elasticsearch-的示例"   >          <a href="#5-Elasticsearch-的示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Elasticsearch-的示例" class="headerlink" title="5. Elasticsearch 的示例"></a><strong>5. Elasticsearch 的示例</strong></h3>      <p>以下是一个简单的 Elasticsearch 示例：</p>        <h4 id="1-创建索引"   >          <a href="#1-创建索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-创建索引" class="headerlink" title="(1) 创建索引"></a><strong>(1) 创建索引</strong></h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>: 3,</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-插入文档"   >          <a href="#2-插入文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-插入文档" class="headerlink" title="(2) 插入文档"></a><strong>(2) 插入文档</strong></h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /my_index/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-搜索文档"   >          <a href="#3-搜索文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-搜索文档" class="headerlink" title="(3) 搜索文档"></a><strong>(3) 搜索文档</strong></h4>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="6-Elasticsearch-的优缺点"   >          <a href="#6-Elasticsearch-的优缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Elasticsearch-的优缺点" class="headerlink" title="6. Elasticsearch 的优缺点"></a><strong>6. Elasticsearch 的优缺点</strong></h3>              <h4 id="1-优点"   >          <a href="#1-优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-优点" class="headerlink" title="(1) 优点"></a><strong>(1) 优点</strong></h4>      <ul><li><strong>高性能</strong>：支持快速的全文搜索和实时数据分析。</li><li><strong>分布式</strong>：支持水平扩展，适合处理大规模数据。</li><li><strong>高可用性</strong>：通过分片和副本机制，确保数据的高可用性。</li><li><strong>易用性</strong>：提供 RESTful API，易于集成和使用。</li></ul>        <h4 id="2-缺点"   >          <a href="#2-缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-缺点" class="headerlink" title="(2) 缺点"></a><strong>(2) 缺点</strong></h4>      <ul><li><strong>资源消耗</strong>：Elasticsearch 对内存和 CPU 的需求较高。</li><li><strong>复杂性</strong>：分布式系统的管理和维护较为复杂。</li><li><strong>数据一致性</strong>：在分布式环境下，数据一致性可能受到影响。</li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Elasticsearch 是一个强大的分布式搜索和分析引擎，基于倒排索引和分布式架构，能够快速处理大规模数据。其核心机制包括倒排索引、分片和副本、分布式搜索、近实时搜索等。理解 Elasticsearch 的工作原理及其核心机制，有助于更好地使用和优化 Elasticsearch。</p>]]></content>
    
    
    <summary type="html">Elasticsearch的工作原理</summary>
    
    
    
    <category term="搜索引擎" scheme="https://ljd0620.github.io/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://ljd0620.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>ES集群如何处理查询请求</title>
    <link href="https://ljd0620.github.io/2023/10/18/ES%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82/"/>
    <id>https://ljd0620.github.io/2023/10/18/ES%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%9F%A5%E8%AF%A2%E8%AF%B7%E6%B1%82/</id>
    <published>2023-10-18T04:29:25.000Z</published>
    <updated>2025-03-19T02:01:56.375Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 是一个分布式的搜索和分析引擎，能够高效地处理大规模数据的查询请求。在 Elasticsearch 集群中，查询请求的处理涉及多个步骤和组件，包括客户端请求、协调节点、数据节点和分片等。以下是 Elasticsearch 集群处理查询请求的详细流程：</p><hr>        <h3 id="1-查询请求的发起"   >          <a href="#1-查询请求的发起" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-查询请求的发起" class="headerlink" title="1. 查询请求的发起"></a><strong>1. 查询请求的发起</strong></h3>      <ul><li><strong>客户端发送请求</strong>：<ul><li>客户端（如应用程序或用户）向 Elasticsearch 集群发送查询请求。</li><li>请求可以发送到集群中的任意节点，该节点称为<strong>协调节点（Coordinating Node）</strong>。</li></ul></li></ul><hr>        <h3 id="2-协调节点接收请求"   >          <a href="#2-协调节点接收请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-协调节点接收请求" class="headerlink" title="2. 协调节点接收请求"></a><strong>2. 协调节点接收请求</strong></h3>      <ul><li><strong>协调节点的角色</strong>：<ul><li>协调节点负责接收客户端的请求，并将请求分发到相关的数据节点。</li><li>协调节点本身不存储数据，而是负责协调查询的执行和结果的合并。</li></ul></li></ul><hr>        <h3 id="3-查询解析与路由"   >          <a href="#3-查询解析与路由" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-查询解析与路由" class="headerlink" title="3. 查询解析与路由"></a><strong>3. 查询解析与路由</strong></h3>      <ul><li><strong>解析查询</strong>：<ul><li>协调节点解析查询请求，确定需要查询的索引和分片。</li></ul></li><li><strong>路由请求</strong>：<ul><li>根据索引的分片配置，协调节点将查询请求路由到包含相关数据的分片。</li><li>每个分片可能位于集群中的不同数据节点上。</li></ul></li></ul><hr>        <h3 id="4-分片执行查询"   >          <a href="#4-分片执行查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-分片执行查询" class="headerlink" title="4. 分片执行查询"></a><strong>4. 分片执行查询</strong></h3>      <ul><li><strong>分片的角色</strong>：<ul><li>每个分片是一个独立的 Lucene 索引，负责存储和检索数据。</li></ul></li><li><strong>查询执行</strong>：<ul><li>每个分片在本地执行查询，搜索匹配的文档。</li><li>分片返回查询结果（通常是文档 ID 和相关性分数）给协调节点。</li></ul></li></ul><hr>        <h3 id="5-结果合并与排序"   >          <a href="#5-结果合并与排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-结果合并与排序" class="headerlink" title="5. 结果合并与排序"></a><strong>5. 结果合并与排序</strong></h3>      <ul><li><strong>协调节点合并结果</strong>：<ul><li>协调节点从所有相关分片收集查询结果。</li><li>根据查询的排序规则（如相关性分数、字段值等），协调节点对结果进行合并和排序。</li></ul></li><li><strong>分页处理</strong>：<ul><li>如果查询请求包含分页参数（如 <code>from</code> 和 <code>size</code>），协调节点会根据分页参数截取结果。</li></ul></li></ul><hr>        <h3 id="6-返回最终结果"   >          <a href="#6-返回最终结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-返回最终结果" class="headerlink" title="6. 返回最终结果"></a><strong>6. 返回最终结果</strong></h3>      <ul><li><strong>返回结果给客户端</strong>：<ul><li>协调节点将最终的查询结果返回给客户端。</li><li>结果通常包括匹配的文档列表、总命中数、分页信息等。</li></ul></li></ul><hr>        <h3 id="7-查询类型与优化"   >          <a href="#7-查询类型与优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-查询类型与优化" class="headerlink" title="7. 查询类型与优化"></a><strong>7. 查询类型与优化</strong></h3>      <p>Elasticsearch 支持多种查询类型，每种查询类型的处理方式可能有所不同：</p>        <h4 id="1-简单查询（如-match-查询）"   >          <a href="#1-简单查询（如-match-查询）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-简单查询（如-match-查询）" class="headerlink" title="(1) 简单查询（如 match 查询）"></a><strong>(1) 简单查询（如 <code>match</code> 查询）</strong></h4>      <ul><li>直接在倒排索引中查找匹配的文档。</li><li>适用于全文搜索。</li></ul>        <h4 id="2-聚合查询（Aggregation）"   >          <a href="#2-聚合查询（Aggregation）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-聚合查询（Aggregation）" class="headerlink" title="(2) 聚合查询（Aggregation）"></a><strong>(2) 聚合查询（Aggregation）</strong></h4>      <ul><li>在查询结果的基础上进行统计分析（如求和、平均值、分组等）。</li><li>聚合查询需要在所有分片上执行，并将结果合并。</li></ul>        <h4 id="3-过滤查询（Filter）"   >          <a href="#3-过滤查询（Filter）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-过滤查询（Filter）" class="headerlink" title="(3) 过滤查询（Filter）"></a><strong>(3) 过滤查询（Filter）</strong></h4>      <ul><li>过滤查询不会计算相关性分数，通常用于精确匹配。</li><li>过滤查询的结果会被缓存，以提高性能。</li></ul>        <h4 id="4-排序查询（Sort）"   >          <a href="#4-排序查询（Sort）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-排序查询（Sort）" class="headerlink" title="(4) 排序查询（Sort）"></a><strong>(4) 排序查询（Sort）</strong></h4>      <ul><li>根据指定的字段对结果进行排序。</li><li>如果排序字段未索引，可能需要加载文档字段值。</li></ul><hr>        <h3 id="8-查询优化策略"   >          <a href="#8-查询优化策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-查询优化策略" class="headerlink" title="8. 查询优化策略"></a><strong>8. 查询优化策略</strong></h3>      <p>为了提高查询性能，Elasticsearch 提供了多种优化策略：</p>        <h4 id="1-使用过滤器缓存"   >          <a href="#1-使用过滤器缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-使用过滤器缓存" class="headerlink" title="(1) 使用过滤器缓存"></a><strong>(1) 使用过滤器缓存</strong></h4>      <ul><li>过滤查询的结果会被缓存，避免重复计算。</li><li>适用于频繁执行的过滤条件。</li></ul>        <h4 id="2-分片分配与副本"   >          <a href="#2-分片分配与副本" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-分片分配与副本" class="headerlink" title="(2) 分片分配与副本"></a><strong>(2) 分片分配与副本</strong></h4>      <ul><li>合理分配分片和副本，避免查询集中在少数节点上。</li><li>增加副本分片可以提高查询的并发能力。</li></ul>        <h4 id="3-使用搜索模板"   >          <a href="#3-使用搜索模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-使用搜索模板" class="headerlink" title="(3) 使用搜索模板"></a><strong>(3) 使用搜索模板</strong></h4>      <ul><li>将常用的查询保存为模板，减少查询解析的开销。</li></ul>        <h4 id="4-优化索引设计"   >          <a href="#4-优化索引设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-优化索引设计" class="headerlink" title="(4) 优化索引设计"></a><strong>(4) 优化索引设计</strong></h4>      <ul><li>使用合适的分词器和字段类型，提高查询效率。</li><li>避免使用过多的嵌套字段和脚本。</li></ul>        <h4 id="5-分页优化"   >          <a href="#5-分页优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-分页优化" class="headerlink" title="(5) 分页优化"></a><strong>(5) 分页优化</strong></h4>      <ul><li>避免深度分页（如 <code>from</code> 值过大），可以使用 <code>search_after</code> 或滚动查询（Scroll API）。</li></ul><hr>        <h3 id="9-查询请求的示例"   >          <a href="#9-查询请求的示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-查询请求的示例" class="headerlink" title="9. 查询请求的示例"></a><strong>9. 查询请求的示例</strong></h3>      <p>以下是一个简单的查询请求示例：</p>        <h4 id="1-查询请求"   >          <a href="#1-查询请求" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-查询请求" class="headerlink" title="(1) 查询请求"></a><strong>(1) 查询请求</strong></h4>      <figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Elasticsearch&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure>        <h4 id="2-查询结果"   >          <a href="#2-查询结果" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-查询结果" class="headerlink" title="(2) 查询结果"></a><strong>(2) 查询结果</strong></h4>      <figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span><span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my_index&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_score&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;_source&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Elasticsearch is awesome&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-10-01T12:00:00Z&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="number">1696166400000</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></div></figure><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>Elasticsearch 集群处理查询请求的流程包括客户端请求、协调节点路由、分片执行查询、结果合并与排序，最终返回结果给客户端。通过合理设计索引、优化查询和使用缓存等策略，可以显著提高查询性能。理解 Elasticsearch 的查询处理机制，有助于更好地使用和优化 Elasticsearch。</p>]]></content>
    
    
    <summary type="html">ES集群如何处理查询请求</summary>
    
    
    
    <category term="搜索引擎" scheme="https://ljd0620.github.io/categories/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="Elasticsearch" scheme="https://ljd0620.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>分布式ID生成方案</title>
    <link href="https://ljd0620.github.io/2023/09/22/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"/>
    <id>https://ljd0620.github.io/2023/09/22/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</id>
    <published>2023-09-22T04:39:31.000Z</published>
    <updated>2025-03-19T02:03:36.345Z</updated>
    
    <content type="html"><![CDATA[<p>分布式ID生成方案是分布式系统中的核心问题之一，尤其是在高并发、高可用的场景下，需要保证生成的ID具备以下特性：</p><ol><li><strong>全局唯一性</strong>：ID在分布式系统中必须唯一。</li><li><strong>有序性</strong>：ID最好是有序的，便于数据库索引和查询。</li><li><strong>高性能</strong>：ID生成速度要快，不能成为系统瓶颈。</li><li><strong>高可用性</strong>：ID生成服务必须高可用，避免单点故障。</li><li><strong>可扩展性</strong>：支持水平扩展，适应业务增长。</li></ol><p>以下是几种常见的分布式ID生成方案及其实现细节：</p><hr>        <h3 id="一、常见分布式ID生成方案"   >          <a href="#一、常见分布式ID生成方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#一、常见分布式ID生成方案" class="headerlink" title="一、常见分布式ID生成方案"></a>一、常见分布式ID生成方案</h3>              <h4 id="1-UUID"   >          <a href="#1-UUID" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-UUID" class="headerlink" title="1. UUID"></a>1. <strong>UUID</strong></h4>      <ul><li><strong>原理</strong>：基于随机数生成128位的唯一标识符。</li><li><strong>优点</strong>：<ul><li>简单易用，无需中心化服务。</li><li>生成速度快。</li></ul></li><li><strong>缺点</strong>：<ul><li>无序，不适合作为数据库主键。</li><li>存储空间大（36字符）。</li><li>查询性能差。</li></ul></li><li><strong>适用场景</strong>：小规模、非连续ID场景。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UUIDGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="2-数据库自增ID"   >          <a href="#2-数据库自增ID" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-数据库自增ID" class="headerlink" title="2. 数据库自增ID"></a>2. <strong>数据库自增ID</strong></h4>      <ul><li><strong>原理</strong>：利用数据库的自增主键特性生成ID。</li><li><strong>优点</strong>：<ul><li>简单易实现。</li><li>ID有序。</li></ul></li><li><strong>缺点</strong>：<ul><li>性能瓶颈，单点故障。</li><li>不适合高并发场景。</li></ul></li><li><strong>适用场景</strong>：小规模、低并发场景。</li></ul><figure class="highlight sql"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> id_generator (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="3-Redis自增ID"   >          <a href="#3-Redis自增ID" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-Redis自增ID" class="headerlink" title="3. Redis自增ID"></a>3. <strong>Redis自增ID</strong></h4>      <ul><li><strong>原理</strong>：利用Redis的<code>INCR</code>命令生成自增ID。</li><li><strong>优点</strong>：<ul><li>高性能，支持分布式。</li><li>简单易用。</li></ul></li><li><strong>缺点</strong>：<ul><li>依赖Redis，需考虑持久化和高可用。</li></ul></li><li><strong>适用场景</strong>：中等规模、高并发场景。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_KEY</span> <span class="operator">=</span> <span class="string">&quot;global:id&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdGenerator</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedis.incr(ID_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="4-Snowflake算法"   >          <a href="#4-Snowflake算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Snowflake算法" class="headerlink" title="4. Snowflake算法"></a>4. <strong>Snowflake算法</strong></h4>      <ul><li><strong>原理</strong>：生成64位的ID，包含时间戳、机器ID和序列号。</li><li><strong>优点</strong>：<ul><li>高性能，分布式生成。</li><li>ID有序。</li></ul></li><li><strong>缺点</strong>：<ul><li>依赖机器时钟，时钟回拨问题。</li></ul></li><li><strong>适用场景</strong>：大规模、高并发场景。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowflakeIdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">epoch</span> <span class="operator">=</span> <span class="number">1609459200000L</span>; <span class="comment">// 2021-01-01 00:00:00</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">10L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnowflakeIdGenerator</span><span class="params">(<span class="type">long</span> workerId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Worker ID超出范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;时钟回拨异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timestamp == lastTimestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="keyword">return</span> ((timestamp - epoch) &lt;&lt; timestampShift)</span><br><span class="line">                | (workerId &lt;&lt; workerIdShift)</span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h4 id="5-Leaf算法"   >          <a href="#5-Leaf算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Leaf算法" class="headerlink" title="5. Leaf算法"></a>5. <strong>Leaf算法</strong></h4>      <ul><li><strong>原理</strong>：美团开源的分布式ID生成服务，支持号段模式和Snowflake模式。</li><li><strong>优点</strong>：<ul><li>高性能，支持分段缓存。</li><li>ID有序。</li></ul></li><li><strong>缺点</strong>：<ul><li>依赖数据库，实现复杂。</li></ul></li><li><strong>适用场景</strong>：大规模、高并发场景。</li></ul><figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafSegmentService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong currentId;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong maxId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> step;</span><br><span class="line">    <span class="keyword">private</span> String bizTag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeafSegmentService</span><span class="params">(String bizTag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bizTag = bizTag;</span><br><span class="line">        loadSegment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadSegment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从数据库获取号段</span></span><br><span class="line">        <span class="type">IdSegment</span> <span class="variable">segment</span> <span class="operator">=</span> idSegmentDAO.getSegment(bizTag);</span><br><span class="line">        currentId = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(segment.getMaxId() - segment.getStep());</span><br><span class="line">        maxId = <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(segment.getMaxId());</span><br><span class="line">        step = segment.getStep();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> currentId.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= maxId.get()) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (id &gt;= maxId.get()) &#123;</span><br><span class="line">                    loadSegment();</span><br><span class="line">                    id = currentId.incrementAndGet();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="二、方案对比与选型建议"   >          <a href="#二、方案对比与选型建议" class="heading-link"><i class="fas fa-link"></i></a><a href="#二、方案对比与选型建议" class="headerlink" title="二、方案对比与选型建议"></a>二、方案对比与选型建议</h3>      <div class="table-container"><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>UUID</strong></td><td>简单、无需中心化服务</td><td>无序、存储空间大、查询性能差</td><td>小规模、非连续ID场景</td></tr><tr><td><strong>数据库自增ID</strong></td><td>简单、有序</td><td>性能瓶颈、单点故障</td><td>小规模、低并发场景</td></tr><tr><td><strong>Redis自增ID</strong></td><td>性能高、支持分布式</td><td>依赖Redis、持久化问题</td><td>中等规模、高并发场景</td></tr><tr><td><strong>Snowflake算法</strong></td><td>高性能、有序、分布式</td><td>依赖机器时钟、时钟回拨问题</td><td>大规模、高并发场景</td></tr><tr><td><strong>Leaf算法</strong></td><td>高性能、支持分段缓存</td><td>依赖数据库、实现复杂</td><td>大规模、高并发场景</td></tr></tbody></table></div><hr>        <h3 id="三、性能优化建议"   >          <a href="#三、性能优化建议" class="heading-link"><i class="fas fa-link"></i></a><a href="#三、性能优化建议" class="headerlink" title="三、性能优化建议"></a>三、性能优化建议</h3>      <ol><li><p><strong>Snowflake优化</strong>：</p><ul><li>使用Zookeeper或Nacos动态分配<code>workerId</code>。</li><li>增加时钟回拨检测机制。</li></ul></li><li><p><strong>Leaf-Segment优化</strong>：</p><ul><li>增加双Buffer机制，预加载下一个号段。</li><li>使用本地缓存减少数据库访问。</li></ul></li><li><p><strong>Redis优化</strong>：</p><ul><li>使用Redis集群提高可用性。</li><li>设置合理的<code>INCR</code>步长，减少网络开销。</li></ul></li></ol><hr>        <h3 id="四、典型场景示例"   >          <a href="#四、典型场景示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#四、典型场景示例" class="headerlink" title="四、典型场景示例"></a>四、典型场景示例</h3>              <h4 id="1-电商订单ID生成"   >          <a href="#1-电商订单ID生成" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-电商订单ID生成" class="headerlink" title="1. 电商订单ID生成"></a>1. <strong>电商订单ID生成</strong></h4>      <ul><li>使用Snowflake算法，确保ID有序且高性能。</li><li>业务标识嵌入<code>workerId</code>，便于分库分表。</li></ul>        <h4 id="2-日志追踪ID生成"   >          <a href="#2-日志追踪ID生成" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-日志追踪ID生成" class="headerlink" title="2. 日志追踪ID生成"></a>2. <strong>日志追踪ID生成</strong></h4>      <ul><li>使用Leaf-Segment方案，支持大范围ID分配。</li><li>结合业务标识（如<code>biz_tag</code>）实现多业务隔离。</li></ul>        <h4 id="3-分布式锁ID生成"   >          <a href="#3-分布式锁ID生成" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-分布式锁ID生成" class="headerlink" title="3. 分布式锁ID生成"></a>3. <strong>分布式锁ID生成</strong></h4>      <ul><li>使用Redis自增ID，简单高效。</li><li>结合<code>EXPIRE</code>命令实现锁超时机制。</li></ul><hr><p>通过以上方案，可以根据具体业务需求选择合适的分布式ID生成策略，确保系统的高性能和高可用性。</p>]]></content>
    
    
    <summary type="html">分布式ID生成方案</summary>
    
    
    
    <category term="架构" scheme="https://ljd0620.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="分布式" scheme="https://ljd0620.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java分布式事务方案</title>
    <link href="https://ljd0620.github.io/2023/08/20/Java%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/"/>
    <id>https://ljd0620.github.io/2023/08/20/Java%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/</id>
    <published>2023-08-20T04:35:43.000Z</published>
    <updated>2025-03-19T02:02:12.561Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，事务的一致性是一个复杂的问题，因为数据可能分布在不同的服务或数据库中。Java 生态中有多种实现分布式事务的方案，以下是常见的几种方案及其详细说明：</p><hr>        <h3 id="1-两阶段提交（2PC）"   >          <a href="#1-两阶段提交（2PC）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-两阶段提交（2PC）" class="headerlink" title="1. 两阶段提交（2PC）"></a><strong>1. 两阶段提交（2PC）</strong></h3>              <h4 id="概述"   >          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4>      <ul><li><strong>2PC</strong> 是一种经典的分布式事务协议，分为准备阶段和提交阶段。</li><li><strong>角色</strong>：<ul><li>协调者（Coordinator）：负责协调事务的提交或回滚。</li><li>参与者（Participant）：执行本地事务并反馈结果。</li></ul></li></ul>        <h4 id="流程"   >          <a href="#流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h4>      <ol><li><strong>准备阶段</strong>：<ul><li>协调者向所有参与者发送准备请求。</li><li>参与者执行本地事务，但不提交，反馈“准备成功”或“准备失败”。</li></ul></li><li><strong>提交阶段</strong>：<ul><li>如果所有参与者都反馈“准备成功”，协调者发送提交请求。</li><li>如果任一参与者反馈“准备失败”，协调者发送回滚请求。</li></ul></li></ol>        <h4 id="优点"   >          <a href="#优点" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4>      <ul><li>强一致性，适合对一致性要求高的场景。</li></ul>        <h4 id="缺点"   >          <a href="#缺点" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4>      <ul><li><strong>性能问题</strong>：同步阻塞，事务执行时间长。</li><li><strong>单点故障</strong>：协调者宕机会导致事务阻塞。</li><li><strong>数据不一致</strong>：在提交阶段，如果协调者或参与者宕机，可能导致数据不一致。</li></ul>        <h4 id="实现"   >          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现" class="headerlink" title="实现"></a><strong>实现</strong></h4>      <ul><li><strong>Java 实现</strong>：<ul><li>使用 JTA（Java Transaction API）和 XA 协议。</li><li>示例：Atomikos、Bitronix。</li></ul></li></ul><hr>        <h3 id="2-补偿事务（Saga）"   >          <a href="#2-补偿事务（Saga）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-补偿事务（Saga）" class="headerlink" title="2. 补偿事务（Saga）"></a><strong>2. 补偿事务（Saga）</strong></h3>              <h4 id="概述-1"   >          <a href="#概述-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述-1" class="headerlink" title="概述"></a><strong>概述</strong></h4>      <ul><li><strong>Saga</strong> 是一种最终一致性方案，通过补偿机制实现分布式事务。</li><li><strong>核心思想</strong>：将一个大事务拆分为多个本地事务，每个本地事务都有对应的补偿操作。</li></ul>        <h4 id="流程-1"   >          <a href="#流程-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程-1" class="headerlink" title="流程"></a><strong>流程</strong></h4>      <ol><li><strong>正向操作</strong>：<ul><li>依次执行每个本地事务。</li></ul></li><li><strong>补偿操作</strong>：<ul><li>如果某个本地事务失败，依次执行已提交事务的补偿操作。</li></ul></li></ol>        <h4 id="优点-1"   >          <a href="#优点-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4>      <ul><li><strong>高性能</strong>：无全局锁，适合长事务。</li><li><strong>松耦合</strong>：适合微服务架构。</li></ul>        <h4 id="缺点-1"   >          <a href="#缺点-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4>      <ul><li><strong>实现复杂</strong>：需要为每个事务设计补偿逻辑。</li><li><strong>最终一致性</strong>：数据一致性需要一定时间。</li></ul>        <h4 id="实现-1"   >          <a href="#实现-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现-1" class="headerlink" title="实现"></a><strong>实现</strong></h4>      <ul><li><strong>Java 实现</strong>：<ul><li>使用消息队列（如 Kafka、RabbitMQ）实现 Saga。</li><li>示例：Apache ServiceComb Saga、Seata Saga 模式。</li></ul></li></ul><hr>        <h3 id="3-本地消息表（Local-Message-Table）"   >          <a href="#3-本地消息表（Local-Message-Table）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-本地消息表（Local-Message-Table）" class="headerlink" title="3. 本地消息表（Local Message Table）"></a><strong>3. 本地消息表（Local Message Table）</strong></h3>              <h4 id="概述-2"   >          <a href="#概述-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述-2" class="headerlink" title="概述"></a><strong>概述</strong></h4>      <ul><li><strong>本地消息表</strong> 是一种基于消息队列的最终一致性方案。</li><li><strong>核心思想</strong>：将分布式事务拆分为本地事务和消息发送，通过消息队列保证最终一致性。</li></ul>        <h4 id="流程-2"   >          <a href="#流程-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程-2" class="headerlink" title="流程"></a><strong>流程</strong></h4>      <ol><li><strong>本地事务</strong>：<ul><li>执行本地事务，同时将消息插入本地消息表。</li></ul></li><li><strong>消息发送</strong>：<ul><li>定时任务从本地消息表读取消息，发送到消息队列。</li></ul></li><li><strong>消息消费</strong>：<ul><li>消费者从消息队列读取消息，执行对应的业务逻辑。</li></ul></li></ol>        <h4 id="优点-2"   >          <a href="#优点-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点-2" class="headerlink" title="优点"></a><strong>优点</strong></h4>      <ul><li><strong>简单易用</strong>：适合中小型系统。</li><li><strong>最终一致性</strong>：通过消息队列保证数据一致性。</li></ul>        <h4 id="缺点-2"   >          <a href="#缺点-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点-2" class="headerlink" title="缺点"></a><strong>缺点</strong></h4>      <ul><li><strong>消息重复</strong>：需要处理消息幂等性。</li><li><strong>延迟</strong>：数据一致性需要一定时间。</li></ul>        <h4 id="实现-2"   >          <a href="#实现-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现-2" class="headerlink" title="实现"></a><strong>实现</strong></h4>      <ul><li><strong>Java 实现</strong>：<ul><li>使用 Spring 的 <code>@Transactional</code> 和消息队列（如 RabbitMQ、Kafka）。</li><li>示例：RocketMQ 事务消息。</li></ul></li></ul><hr>        <h3 id="4-TCC（Try-Confirm-Cancel）"   >          <a href="#4-TCC（Try-Confirm-Cancel）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-TCC（Try-Confirm-Cancel）" class="headerlink" title="4. TCC（Try-Confirm-Cancel）"></a><strong>4. TCC（Try-Confirm-Cancel）</strong></h3>              <h4 id="概述-3"   >          <a href="#概述-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述-3" class="headerlink" title="概述"></a><strong>概述</strong></h4>      <ul><li><strong>TCC</strong> 是一种基于补偿的分布式事务方案，分为三个阶段：<ol><li><strong>Try</strong>：预留资源。</li><li><strong>Confirm</strong>：提交资源。</li><li><strong>Cancel</strong>：释放资源。</li></ol></li></ul>        <h4 id="流程-3"   >          <a href="#流程-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程-3" class="headerlink" title="流程"></a><strong>流程</strong></h4>      <ol><li><strong>Try 阶段</strong>：<ul><li>调用所有参与者的 Try 方法，预留资源。</li></ul></li><li><strong>Confirm 阶段</strong>：<ul><li>如果所有 Try 方法成功，调用 Confirm 方法提交资源。</li></ul></li><li><strong>Cancel 阶段</strong>：<ul><li>如果任一 Try 方法失败，调用 Cancel 方法释放资源。</li></ul></li></ol>        <h4 id="优点-3"   >          <a href="#优点-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点-3" class="headerlink" title="优点"></a><strong>优点</strong></h4>      <ul><li><strong>高性能</strong>：无全局锁，适合高并发场景。</li><li><strong>强一致性</strong>：通过补偿机制保证数据一致性。</li></ul>        <h4 id="缺点-3"   >          <a href="#缺点-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点-3" class="headerlink" title="缺点"></a><strong>缺点</strong></h4>      <ul><li><strong>实现复杂</strong>：需要为每个事务设计 Try、Confirm、Cancel 逻辑。</li><li><strong>业务侵入性</strong>：需要修改业务代码。</li></ul>        <h4 id="实现-3"   >          <a href="#实现-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现-3" class="headerlink" title="实现"></a><strong>实现</strong></h4>      <ul><li><strong>Java 实现</strong>：<ul><li>使用 Seata 的 TCC 模式。</li><li>示例：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;createOrder&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryCreateOrder</span><span class="params">(BusinessActionContext actionContext, Order order)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">confirm</span><span class="params">(BusinessActionContext actionContext)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(BusinessActionContext actionContext)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul></li></ul><hr>        <h3 id="5-可靠消息最终一致性（MQ-事务消息）"   >          <a href="#5-可靠消息最终一致性（MQ-事务消息）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-可靠消息最终一致性（MQ-事务消息）" class="headerlink" title="5. 可靠消息最终一致性（MQ 事务消息）"></a><strong>5. 可靠消息最终一致性（MQ 事务消息）</strong></h3>              <h4 id="概述-4"   >          <a href="#概述-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述-4" class="headerlink" title="概述"></a><strong>概述</strong></h4>      <ul><li><strong>可靠消息最终一致性</strong> 是一种基于消息队列的最终一致性方案。</li><li><strong>核心思想</strong>：通过消息队列的可靠性保证数据一致性。</li></ul>        <h4 id="流程-4"   >          <a href="#流程-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程-4" class="headerlink" title="流程"></a><strong>流程</strong></h4>      <ol><li><strong>发送半消息</strong>：<ul><li>生产者发送半消息到消息队列。</li></ul></li><li><strong>执行本地事务</strong>：<ul><li>生产者执行本地事务。</li></ul></li><li><strong>提交&#x2F;回滚消息</strong>：<ul><li>如果本地事务成功，提交消息；否则，回滚消息。</li></ul></li><li><strong>消息消费</strong>：<ul><li>消费者从消息队列读取消息，执行对应的业务逻辑。</li></ul></li></ol>        <h4 id="优点-4"   >          <a href="#优点-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点-4" class="headerlink" title="优点"></a><strong>优点</strong></h4>      <ul><li><strong>解耦</strong>：适合微服务架构。</li><li><strong>最终一致性</strong>：通过消息队列保证数据一致性。</li></ul>        <h4 id="缺点-4"   >          <a href="#缺点-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点-4" class="headerlink" title="缺点"></a><strong>缺点</strong></h4>      <ul><li><strong>延迟</strong>：数据一致性需要一定时间。</li><li><strong>消息重复</strong>：需要处理消息幂等性。</li></ul>        <h4 id="实现-4"   >          <a href="#实现-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现-4" class="headerlink" title="实现"></a><strong>实现</strong></h4>      <ul><li><strong>Java 实现</strong>：<ul><li>使用 RocketMQ 的事务消息。</li><li>示例：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TransactionMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionMQProducer</span>(<span class="string">&quot;group&quot;</span>);</span><br><span class="line">producer.setTransactionListener(<span class="keyword">new</span> <span class="title class_">TransactionListener</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行本地事务</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查本地事务状态</span></span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">producer.sendMessageInTransaction(message, <span class="literal">null</span>);</span><br></pre></td></tr></table></div></figure></li></ul></li></ul><hr>        <h3 id="6-Seata（分布式事务框架）"   >          <a href="#6-Seata（分布式事务框架）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-Seata（分布式事务框架）" class="headerlink" title="6. Seata（分布式事务框架）"></a><strong>6. Seata（分布式事务框架）</strong></h3>              <h4 id="概述-5"   >          <a href="#概述-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#概述-5" class="headerlink" title="概述"></a><strong>概述</strong></h4>      <ul><li><strong>Seata</strong> 是一个开源的分布式事务解决方案，支持 AT、TCC、Saga 和 XA 模式。</li><li><strong>核心思想</strong>：通过全局事务管理器（TC）协调分布式事务。</li></ul>        <h4 id="模式"   >          <a href="#模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#模式" class="headerlink" title="模式"></a><strong>模式</strong></h4>      <ol><li><strong>AT 模式</strong>：<ul><li>基于两阶段提交，自动生成反向 SQL 实现回滚。</li></ul></li><li><strong>TCC 模式</strong>：<ul><li>基于补偿机制，需要手动实现 Try、Confirm、Cancel 逻辑。</li></ul></li><li><strong>Saga 模式</strong>：<ul><li>基于状态机，适合长事务。</li></ul></li><li><strong>XA 模式</strong>：<ul><li>基于 XA 协议，适合强一致性场景。</li></ul></li></ol>        <h4 id="优点-5"   >          <a href="#优点-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#优点-5" class="headerlink" title="优点"></a><strong>优点</strong></h4>      <ul><li><strong>灵活</strong>：支持多种分布式事务模式。</li><li><strong>易用</strong>：提供开箱即用的解决方案。</li></ul>        <h4 id="缺点-5"   >          <a href="#缺点-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#缺点-5" class="headerlink" title="缺点"></a><strong>缺点</strong></h4>      <ul><li><strong>性能开销</strong>：AT 模式需要生成反向 SQL，性能较低。</li></ul>        <h4 id="实现-5"   >          <a href="#实现-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现-5" class="headerlink" title="实现"></a><strong>实现</strong></h4>      <ul><li><strong>Java 实现</strong>：<ul><li>使用 Seata 的 AT 模式：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    orderService.create(order);</span><br><span class="line">    inventoryService.deduct(order.getProductId(), order.getCount());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <div class="table-container"><table><thead><tr><th>方案</th><th>一致性</th><th>性能</th><th>实现复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>2PC</strong></td><td>强一致性</td><td>低</td><td>高</td><td>传统单体应用，强一致性场景</td></tr><tr><td><strong>Saga</strong></td><td>最终一致</td><td>高</td><td>中</td><td>微服务架构，长事务场景</td></tr><tr><td><strong>本地消息表</strong></td><td>最终一致</td><td>中</td><td>低</td><td>中小型系统，异步场景</td></tr><tr><td><strong>TCC</strong></td><td>强一致性</td><td>高</td><td>高</td><td>高并发场景，强一致性要求</td></tr><tr><td><strong>可靠消息最终一致</strong></td><td>最终一致</td><td>中</td><td>中</td><td>微服务架构，异步场景</td></tr><tr><td><strong>Seata</strong></td><td>多种模式</td><td>中</td><td>低</td><td>微服务架构，多种场景</td></tr></tbody></table></div><p>根据具体的业务场景和性能需求，选择合适的分布式事务方案：</p><ul><li><strong>强一致性</strong>：2PC、TCC、Seata XA。</li><li><strong>最终一致性</strong>：Saga、本地消息表、可靠消息最终一致性、Seata AT&#x2F;Saga。</li></ul>]]></content>
    
    
    <summary type="html">Java分布式事务方案</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ljd0620.github.io/tags/Java/"/>
    
    <category term="分布式" scheme="https://ljd0620.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>DDD之DP设计原则</title>
    <link href="https://ljd0620.github.io/2023/08/09/DDD%E4%B9%8BDP%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://ljd0620.github.io/2023/08/09/DDD%E4%B9%8BDP%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2023-08-09T04:42:21.000Z</published>
    <updated>2025-03-19T02:01:45.606Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Domain Primitive (DP)</strong> 是一种领域驱动设计（DDD）中的设计原则，旨在通过将领域中的基本概念封装为不可变的值对象（Value Object），从而提高代码的可读性、可维护性和安全性。DP 的核心思想是将领域中的原始类型（如字符串、数字）封装为具有明确语义和行为的对象。</p><p>以下是 DP 设计原则的详细解析：</p><hr>        <h3 id="1-DP-的核心概念"   >          <a href="#1-DP-的核心概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-DP-的核心概念" class="headerlink" title="1. DP 的核心概念"></a><strong>1. DP 的核心概念</strong></h3>              <h4 id="1-什么是-Domain-Primitive？"   >          <a href="#1-什么是-Domain-Primitive？" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-什么是-Domain-Primitive？" class="headerlink" title="(1) 什么是 Domain Primitive？"></a><strong>(1) 什么是 Domain Primitive？</strong></h4>      <ul><li><strong>定义</strong>：<ul><li>DP 是领域中最基本的概念，通常是一个不可变的值对象。</li><li>它封装了领域中的原始类型，并赋予其明确的语义和行为。</li></ul></li><li><strong>示例</strong>：<ul><li>将 <code>String</code> 类型的电话号码封装为 <code>PhoneNumber</code> 类。</li><li>将 <code>int</code> 类型的年龄封装为 <code>Age</code> 类。</li></ul></li></ul>        <h4 id="2-DP-的特点"   >          <a href="#2-DP-的特点" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-DP-的特点" class="headerlink" title="(2) DP 的特点"></a><strong>(2) DP 的特点</strong></h4>      <ul><li><strong>不可变性（Immutable）</strong>：<ul><li>DP 对象一旦创建，其值不可更改。</li></ul></li><li><strong>自验证（Self-Validating）</strong>：<ul><li>DP 对象在创建时自动验证其值的合法性。</li></ul></li><li><strong>明确语义（Explicit Semantics）</strong>：<ul><li>DP 对象具有明确的领域语义，避免原始类型的模糊性。</li></ul></li><li><strong>行为封装（Encapsulated Behavior）</strong>：<ul><li>DP 对象可以封装与领域相关的行为（如格式化、比较）。</li></ul></li></ul><hr>        <h3 id="2-DP-的设计原则"   >          <a href="#2-DP-的设计原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-DP-的设计原则" class="headerlink" title="2. DP 的设计原则"></a><strong>2. DP 的设计原则</strong></h3>              <h4 id="1-封装原始类型"   >          <a href="#1-封装原始类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-封装原始类型" class="headerlink" title="(1) 封装原始类型"></a><strong>(1) 封装原始类型</strong></h4>      <ul><li><strong>问题</strong>：<ul><li>原始类型（如 <code>String</code>、<code>int</code>）缺乏明确的语义，容易导致错误。</li></ul></li><li><strong>解决方案</strong>：<ul><li>将原始类型封装为 DP 对象，赋予其明确的语义。</li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhoneNumber</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span> || !value.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid phone number&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-自验证"   >          <a href="#2-自验证" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-自验证" class="headerlink" title="(2) 自验证"></a><strong>(2) 自验证</strong></h4>      <ul><li><strong>问题</strong>：<ul><li>原始类型的值可能不合法，需要在业务逻辑中手动验证。</li></ul></li><li><strong>解决方案</strong>：<ul><li>DP 对象在创建时自动验证其值的合法性。</li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Age</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Age</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &lt; <span class="number">0</span> || value &gt; <span class="number">150</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid age&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="3-不可变性"   >          <a href="#3-不可变性" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-不可变性" class="headerlink" title="(3) 不可变性"></a><strong>(3) 不可变性</strong></h4>      <ul><li><strong>问题</strong>：<ul><li>可变对象可能导致意外的状态变化。</li></ul></li><li><strong>解决方案</strong>：<ul><li>DP 对象一旦创建，其值不可更改。</li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigDecimal amount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Currency currency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Money</span><span class="params">(BigDecimal amount, Currency currency)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">        <span class="built_in">this</span>.currency = currency;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getAmount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Currency <span class="title function_">getCurrency</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="4-行为封装"   >          <a href="#4-行为封装" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-行为封装" class="headerlink" title="(4) 行为封装"></a><strong>(4) 行为封装</strong></h4>      <ul><li><strong>问题</strong>：<ul><li>与领域相关的行为分散在业务逻辑中，导致代码重复。</li></ul></li><li><strong>解决方案</strong>：<ul><li>将与领域相关的行为封装到 DP 对象中。</li></ul></li><li><strong>示例</strong>：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Email</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span> || !value.matches(<span class="string">&quot;[^@]+@[^@]+\\.[^@]+&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid email&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDomain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.substring(value.indexOf(<span class="string">&#x27;@&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="3-DP-的优势"   >          <a href="#3-DP-的优势" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-DP-的优势" class="headerlink" title="3. DP 的优势"></a><strong>3. DP 的优势</strong></h3>              <h4 id="1-提高代码可读性"   >          <a href="#1-提高代码可读性" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-提高代码可读性" class="headerlink" title="(1) 提高代码可读性"></a><strong>(1) 提高代码可读性</strong></h4>      <ul><li>DP 对象具有明确的语义，使代码更易于理解。</li><li>示例：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="string">&quot;12345678901&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP 对象</span></span><br><span class="line"><span class="type">PhoneNumber</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="string">&quot;12345678901&quot;</span>);</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-提高代码可维护性"   >          <a href="#2-提高代码可维护性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-提高代码可维护性" class="headerlink" title="(2) 提高代码可维护性"></a><strong>(2) 提高代码可维护性</strong></h4>      <ul><li>DP 对象封装了验证逻辑和行为，减少了重复代码。</li><li>示例：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类型</span></span><br><span class="line"><span class="keyword">if</span> (phoneNumber == <span class="literal">null</span> || !phoneNumber.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid phone number&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DP 对象</span></span><br><span class="line"><span class="type">PhoneNumber</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="string">&quot;12345678901&quot;</span>);</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="3-提高代码安全性"   >          <a href="#3-提高代码安全性" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-提高代码安全性" class="headerlink" title="(3) 提高代码安全性"></a><strong>(3) 提高代码安全性</strong></h4>      <ul><li>DP 对象在创建时自动验证其值的合法性，避免了非法值的传播。</li><li>示例：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 非法值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DP 对象</span></span><br><span class="line"><span class="type">Age</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Age</span>(-<span class="number">1</span>); <span class="comment">// 抛出异常</span></span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="4-DP-的实现示例"   >          <a href="#4-DP-的实现示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-DP-的实现示例" class="headerlink" title="4. DP 的实现示例"></a><strong>4. DP 的实现示例</strong></h3>      <p>以下是一个完整的 DP 实现示例：</p>        <h4 id="1-DP-类"   >          <a href="#1-DP-类" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-DP-类" class="headerlink" title="(1) DP 类"></a><strong>(1) DP 类</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhoneNumber</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span> || !value.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid phone number&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">PhoneNumber</span> <span class="variable">that</span> <span class="operator">=</span> (PhoneNumber) o;</span><br><span class="line">        <span class="keyword">return</span> value.equals(that.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PhoneNumber&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&#x27;&quot;</span> + value + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="2-使用-DP-类"   >          <a href="#2-使用-DP-类" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-使用-DP-类" class="headerlink" title="(2) 使用 DP 类"></a><strong>(2) 使用 DP 类</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PhoneNumber phoneNumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, PhoneNumber phoneNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.phoneNumber = phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PhoneNumber <span class="title function_">getPhoneNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phoneNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="3-测试-DP-类"   >          <a href="#3-测试-DP-类" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-测试-DP-类" class="headerlink" title="(3) 测试 DP 类"></a><strong>(3) 测试 DP 类</strong></h4>      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PhoneNumber</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneNumber</span>(<span class="string">&quot;12345678901&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Alice&quot;</span>, phoneNumber);</span><br><span class="line">        System.out.println(user.getPhoneNumber().getValue()); <span class="comment">// 输出：12345678901</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><hr>        <h3 id="5-DP-的最佳实践"   >          <a href="#5-DP-的最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-DP-的最佳实践" class="headerlink" title="5. DP 的最佳实践"></a><strong>5. DP 的最佳实践</strong></h3>      <ol><li><strong>识别领域中的原始类型</strong>：<ul><li>将领域中的原始类型（如 <code>String</code>、<code>int</code>）封装为 DP 对象。</li></ul></li><li><strong>封装验证逻辑</strong>：<ul><li>在 DP 对象的构造函数中验证其值的合法性。</li></ul></li><li><strong>保持不可变性</strong>：<ul><li>DP 对象一旦创建，其值不可更改。</li></ul></li><li><strong>封装领域行为</strong>：<ul><li>将与领域相关的行为封装到 DP 对象中。</li></ul></li><li><strong>避免过度设计</strong>：<ul><li>只在必要时使用 DP，避免过度封装。</li></ul></li></ol><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>DP 设计原则通过将领域中的原始类型封装为具有明确语义和行为的值对象，提高了代码的可读性、可维护性和安全性。通过遵循 DP 的设计原则，可以构建更加健壮和清晰的领域模型。</p>]]></content>
    
    
    <summary type="html">DDD之DP设计原则</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="DDD" scheme="https://ljd0620.github.io/tags/DDD/"/>
    
    <category term="设计模式" scheme="https://ljd0620.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PromQL数据分析指南</title>
    <link href="https://ljd0620.github.io/2023/02/26/PromQL%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97/"/>
    <id>https://ljd0620.github.io/2023/02/26/PromQL%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%8C%87%E5%8D%97/</id>
    <published>2023-02-26T04:38:04.000Z</published>
    <updated>2025-03-19T02:02:50.827Z</updated>
    
    <content type="html"><![CDATA[<p>PromQL（Prometheus Query Language）是 Prometheus 用于查询和分析时间序列数据的强大语言。通过 PromQL，你可以从 Prometheus 中提取、聚合和操作时间序列数据，从而进行监控、告警和数据分析。以下是使用 PromQL 进行数据分析的详细指南：</p><hr>        <h3 id="1-PromQL-基础概念"   >          <a href="#1-PromQL-基础概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-PromQL-基础概念" class="headerlink" title="1. PromQL 基础概念"></a><strong>1. PromQL 基础概念</strong></h3>      <p>在开始使用 PromQL 之前，需要了解一些基本概念：</p><ul><li><strong>时间序列（Time Series）</strong>：<ul><li>时间序列是由指标名称（Metric Name）和一组标签（Labels）唯一标识的数据流。</li><li>例如：<code>http_requests_total&#123;method=&quot;GET&quot;, status=&quot;200&quot;&#125;</code>。</li></ul></li><li><strong>指标类型</strong>：<ul><li><strong>Counter</strong>：单调递增的计数器（如请求总数）。</li><li><strong>Gauge</strong>：可增可减的仪表盘（如 CPU 使用率）。</li><li><strong>Histogram</strong>：直方图，用于统计数据的分布（如请求延迟）。</li><li><strong>Summary</strong>：摘要，用于统计数据的分布（如请求延迟）。</li></ul></li></ul><hr>        <h3 id="2-PromQL-基本语法"   >          <a href="#2-PromQL-基本语法" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-PromQL-基本语法" class="headerlink" title="2. PromQL 基本语法"></a><strong>2. PromQL 基本语法</strong></h3>      <p>PromQL 支持多种查询和操作符，以下是常用的语法：</p>        <h4 id="1-查询时间序列"   >          <a href="#1-查询时间序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-查询时间序列" class="headerlink" title="(1) 查询时间序列"></a><strong>(1) 查询时间序列</strong></h4>      <ul><li><strong>查询所有时间序列</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total</span><br></pre></td></tr></table></div></figure></li><li><strong>根据标签过滤</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;method=&quot;GET&quot;, status=&quot;200&quot;&#125;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-范围查询"   >          <a href="#2-范围查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-范围查询" class="headerlink" title="(2) 范围查询"></a><strong>(2) 范围查询</strong></h4>      <ul><li><strong>查询过去 5 分钟的数据</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total[5m]</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="3-聚合操作"   >          <a href="#3-聚合操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-聚合操作" class="headerlink" title="(3) 聚合操作"></a><strong>(3) 聚合操作</strong></h4>      <ul><li><strong>求和（Sum）</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total)</span><br></pre></td></tr></table></div></figure></li><li><strong>按标签分组求和</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(http_requests_total) by (method)</span><br></pre></td></tr></table></div></figure></li><li><strong>平均值（Avg）</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avg(http_requests_total)</span><br></pre></td></tr></table></div></figure></li><li><strong>最大值（Max）</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(http_requests_total)</span><br></pre></td></tr></table></div></figure></li><li><strong>最小值（Min）</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min(http_requests_total)</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="4-数学运算"   >          <a href="#4-数学运算" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-数学运算" class="headerlink" title="(4) 数学运算"></a><strong>(4) 数学运算</strong></h4>      <ul><li><strong>加法</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total&#123;method=&quot;GET&quot;&#125; + http_requests_total&#123;method=&quot;POST&quot;&#125;</span><br></pre></td></tr></table></div></figure></li><li><strong>除法</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m]) / 100</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="5-函数"   >          <a href="#5-函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-函数" class="headerlink" title="(5) 函数"></a><strong>(5) 函数</strong></h4>      <ul><li><strong><code>rate()</code></strong>：计算时间序列的增长率（适用于 Counter 类型）。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></div></figure></li><li><strong><code>increase()</code></strong>：计算时间序列的增长量（适用于 Counter 类型）。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increase(http_requests_total[5m])</span><br></pre></td></tr></table></div></figure></li><li><strong><code>irate()</code></strong>：计算时间序列的瞬时增长率。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate(http_requests_total[5m])</span><br></pre></td></tr></table></div></figure></li><li><strong><code>histogram_quantile()</code></strong>：计算直方图的分位数。<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))</span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="3-常见数据分析场景"   >          <a href="#3-常见数据分析场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-常见数据分析场景" class="headerlink" title="3. 常见数据分析场景"></a><strong>3. 常见数据分析场景</strong></h3>      <p>以下是使用 PromQL 进行数据分析的常见场景和示例：</p>        <h4 id="1-计算请求速率"   >          <a href="#1-计算请求速率" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-计算请求速率" class="headerlink" title="(1) 计算请求速率"></a><strong>(1) 计算请求速率</strong></h4>      <ul><li><strong>每秒请求数（QPS）</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-计算错误率"   >          <a href="#2-计算错误率" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-计算错误率" class="headerlink" title="(2) 计算错误率"></a><strong>(2) 计算错误率</strong></h4>      <ul><li><strong>错误请求的比例</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m])) / sum(rate(http_requests_total[5m]))</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="3-计算-CPU-使用率"   >          <a href="#3-计算-CPU-使用率" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-计算-CPU-使用率" class="headerlink" title="(3) 计算 CPU 使用率"></a><strong>(3) 计算 CPU 使用率</strong></h4>      <ul><li><strong>CPU 使用率</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 - (avg(irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[5m])) * 100</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="4-计算内存使用率"   >          <a href="#4-计算内存使用率" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-计算内存使用率" class="headerlink" title="(4) 计算内存使用率"></a><strong>(4) 计算内存使用率</strong></h4>      <ul><li><strong>内存使用率</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_memory_MemTotal_bytes - node_memory_MemFree_bytes) / node_memory_MemTotal_bytes * 100</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="5-计算请求延迟"   >          <a href="#5-计算请求延迟" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-计算请求延迟" class="headerlink" title="(5) 计算请求延迟"></a><strong>(5) 计算请求延迟</strong></h4>      <ul><li><strong>95% 的请求延迟</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m]))</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="6-计算磁盘使用率"   >          <a href="#6-计算磁盘使用率" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-计算磁盘使用率" class="headerlink" title="(6) 计算磁盘使用率"></a><strong>(6) 计算磁盘使用率</strong></h4>      <ul><li><strong>磁盘使用率</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(node_filesystem_size_bytes&#123;mountpoint=&quot;/&quot;&#125; - node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;&#125;) / node_filesystem_size_bytes&#123;mountpoint=&quot;/&quot;&#125; * 100</span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="4-高级数据分析"   >          <a href="#4-高级数据分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-高级数据分析" class="headerlink" title="4. 高级数据分析"></a><strong>4. 高级数据分析</strong></h3>              <h4 id="1-多指标联合查询"   >          <a href="#1-多指标联合查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-多指标联合查询" class="headerlink" title="(1) 多指标联合查询"></a><strong>(1) 多指标联合查询</strong></h4>      <ul><li><strong>计算每个实例的请求速率和错误率</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total&#123;instance=&quot;localhost:9090&quot;&#125;[5m])</span><br><span class="line">/</span><br><span class="line">rate(http_requests_total&#123;instance=&quot;localhost:9090&quot;, status=~&quot;5..&quot;&#125;[5m])</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-预测未来趋势"   >          <a href="#2-预测未来趋势" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-预测未来趋势" class="headerlink" title="(2) 预测未来趋势"></a><strong>(2) 预测未来趋势</strong></h4>      <ul><li><strong>使用 <code>predict_linear()</code> 预测磁盘空间耗尽时间</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free_bytes&#123;mountpoint=&quot;/&quot;&#125;[1h], 3600 * 24) &lt; 0</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="3-时间偏移"   >          <a href="#3-时间偏移" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-时间偏移" class="headerlink" title="(3) 时间偏移"></a><strong>(3) 时间偏移</strong></h4>      <ul><li><strong>比较当前和 1 小时前的请求速率</strong>：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m]) - rate(http_requests_total[5m] offset 1h)</span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="5-可视化与告警"   >          <a href="#5-可视化与告警" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-可视化与告警" class="headerlink" title="5. 可视化与告警"></a><strong>5. 可视化与告警</strong></h3>              <h4 id="1-可视化"   >          <a href="#1-可视化" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-可视化" class="headerlink" title="(1) 可视化"></a><strong>(1) 可视化</strong></h4>      <ul><li>使用 Grafana 等工具将 PromQL 查询结果可视化。</li><li>示例：在 Grafana 中创建一个面板，显示 CPU 使用率：<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 - (avg(irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[5m])) * 100</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-告警"   >          <a href="#2-告警" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-告警" class="headerlink" title="(2) 告警"></a><strong>(2) 告警</strong></h4>      <ul><li>使用 Prometheus 的告警规则（Alerting Rules）定义告警条件。</li><li>示例：当 CPU 使用率超过 80% 时触发告警：<figure class="highlight yaml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">HighCpuUsage</span></span><br><span class="line">    <span class="attr">expr:</span> <span class="number">100</span> <span class="bullet">-</span> <span class="string">(avg(irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[5m]))</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&gt;</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">severity:</span> <span class="string">critical</span></span><br><span class="line">    <span class="attr">annotations:</span></span><br><span class="line">      <span class="attr">summary:</span> <span class="string">&quot;High CPU usage detected&quot;</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">&quot;CPU usage is above 80% for more than 5 minutes.&quot;</span></span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="6-最佳实践"   >          <a href="#6-最佳实践" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-最佳实践" class="headerlink" title="6. 最佳实践"></a><strong>6. 最佳实践</strong></h3>      <ul><li><strong>合理选择时间范围</strong>：<ul><li>根据分析需求选择合适的时间范围（如 <code>[5m]</code>、<code>[1h]</code>）。</li></ul></li><li><strong>避免过度聚合</strong>：<ul><li>聚合操作会丢失细节，根据需求选择合适的聚合粒度。</li></ul></li><li><strong>使用标签过滤</strong>：<ul><li>通过标签过滤减少查询的数据量，提高查询性能。</li></ul></li><li><strong>监控查询性能</strong>：<ul><li>复杂的查询可能影响 Prometheus 的性能，定期优化查询。</li></ul></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>PromQL 是 Prometheus 的核心查询语言，通过它可以灵活地查询和分析时间序列数据。掌握 PromQL 的基本语法和常见场景，可以帮助你更好地进行监控、告警和数据分析。结合 Grafana 等可视化工具，可以更直观地展示分析结果。</p>]]></content>
    
    
    <summary type="html">PromQL数据分析指南</summary>
    
    
    
    <category term="Prometheus" scheme="https://ljd0620.github.io/categories/Prometheus/"/>
    
    
    <category term="PromQL" scheme="https://ljd0620.github.io/tags/PromQL/"/>
    
    <category term="数据分析" scheme="https://ljd0620.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JVM和JMM的区别</title>
    <link href="https://ljd0620.github.io/2022/11/17/JVM%E5%92%8CJMM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://ljd0620.github.io/2022/11/17/JVM%E5%92%8CJMM%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-11-17T04:12:27.000Z</published>
    <updated>2025-03-19T02:02:27.138Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 内存模型和 JMM（Java Memory Model，Java 内存模型）是两个不同的概念，尽管它们都与 Java 程序的内存管理相关，但它们的目标、范围和实现方式有显著区别。以下是它们的详细对比：</p><hr>        <h3 id="1-定义与目标"   >          <a href="#1-定义与目标" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-定义与目标" class="headerlink" title="1. 定义与目标"></a><strong>1. 定义与目标</strong></h3>              <h4 id="1-JVM-内存模型"   >          <a href="#1-JVM-内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JVM-内存模型" class="headerlink" title="(1) JVM 内存模型"></a><strong>(1) JVM 内存模型</strong></h4>      <ul><li><strong>定义</strong>：<ul><li>JVM 内存模型是 Java 虚拟机（JVM）规范中定义的一种内存管理模型，用于描述 Java 程序在运行时的内存分配和管理。</li></ul></li><li><strong>目标</strong>：<ul><li>管理 Java 程序运行时的内存分配，包括堆、栈、方法区等内存区域。</li><li>确保 Java 程序能够高效地使用内存资源。</li></ul></li></ul>        <h4 id="2-JMM-内存模型"   >          <a href="#2-JMM-内存模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-JMM-内存模型" class="headerlink" title="(2) JMM 内存模型"></a><strong>(2) JMM 内存模型</strong></h4>      <ul><li><strong>定义</strong>：<ul><li>JMM 是 Java 语言规范中定义的一种抽象模型，用于描述多线程环境下，线程如何与内存交互以及如何保证内存的可见性、有序性和原子性。</li></ul></li><li><strong>目标</strong>：<ul><li>解决多线程并发编程中的内存一致性问题。</li><li>定义线程之间的内存交互规则，确保多线程程序的正确性。</li></ul></li></ul><hr>        <h3 id="2-组成部分"   >          <a href="#2-组成部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-组成部分" class="headerlink" title="2. 组成部分"></a><strong>2. 组成部分</strong></h3>              <h4 id="1-JVM-内存模型-1"   >          <a href="#1-JVM-内存模型-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JVM-内存模型-1" class="headerlink" title="(1) JVM 内存模型"></a><strong>(1) JVM 内存模型</strong></h4>      <p>JVM 内存模型将内存划分为以下几个主要区域：</p><ol><li><strong>程序计数器（Program Counter Register）</strong>：<ul><li>记录当前线程执行的字节码指令地址。</li></ul></li><li><strong>Java 虚拟机栈（Java Virtual Machine Stacks）</strong>：<ul><li>存储方法的局部变量、操作数栈、动态链接和方法返回地址。</li></ul></li><li><strong>本地方法栈（Native Method Stack）</strong>：<ul><li>支持 Native 方法的执行。</li></ul></li><li><strong>Java 堆（Java Heap）</strong>：<ul><li>存储对象实例和数组。</li></ul></li><li><strong>方法区（Method Area）</strong>：<ul><li>存储类信息、常量、静态变量、即时编译器编译后的代码等。</li></ul></li><li><strong>运行时常量池（Runtime Constant Pool）</strong>：<ul><li>存储编译期生成的字面量和符号引用。</li></ul></li><li><strong>直接内存（Direct Memory）</strong>：<ul><li>支持 NIO 操作。</li></ul></li></ol>        <h4 id="2-JMM-内存模型-1"   >          <a href="#2-JMM-内存模型-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-JMM-内存模型-1" class="headerlink" title="(2) JMM 内存模型"></a><strong>(2) JMM 内存模型</strong></h4>      <p>JMM 内存模型的核心是定义线程与内存之间的交互规则，主要包括以下内容：</p><ol><li><strong>主内存（Main Memory）</strong>：<ul><li>所有线程共享的内存区域，存储共享变量。</li></ul></li><li><strong>工作内存（Working Memory）</strong>：<ul><li>每个线程私有的内存区域，存储共享变量的副本。</li></ul></li><li><strong>内存间交互操作</strong>：<ul><li>定义线程与主内存之间的 8 种原子操作（如 <code>read</code>、<code>load</code>、<code>use</code>、<code>assign</code> 等）。</li></ul></li><li><strong>Happens-Before 规则</strong>：<ul><li>定义操作之间的可见性和有序性。</li></ul></li></ol><hr>        <h3 id="3-关注点"   >          <a href="#3-关注点" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-关注点" class="headerlink" title="3. 关注点"></a><strong>3. 关注点</strong></h3>              <h4 id="1-JVM-内存模型-2"   >          <a href="#1-JVM-内存模型-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JVM-内存模型-2" class="headerlink" title="(1) JVM 内存模型"></a><strong>(1) JVM 内存模型</strong></h4>      <ul><li><strong>内存分配</strong>：<ul><li>如何分配和管理堆、栈、方法区等内存区域。</li></ul></li><li><strong>垃圾回收</strong>：<ul><li>如何回收不再使用的对象，释放内存。</li></ul></li><li><strong>性能优化</strong>：<ul><li>如何通过调整内存参数（如堆大小、垃圾收集器等）优化性能。</li></ul></li></ul>        <h4 id="2-JMM-内存模型-2"   >          <a href="#2-JMM-内存模型-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-JMM-内存模型-2" class="headerlink" title="(2) JMM 内存模型"></a><strong>(2) JMM 内存模型</strong></h4>      <ul><li><strong>内存一致性</strong>：<ul><li>如何保证多线程环境下共享变量的可见性、有序性和原子性。</li></ul></li><li><strong>线程安全</strong>：<ul><li>如何通过锁、<code>volatile</code>、<code>final</code> 等机制实现线程安全。</li></ul></li><li><strong>并发编程</strong>：<ul><li>如何编写正确的多线程程序，避免竞态条件和死锁。</li></ul></li></ul><hr>        <h3 id="4-实现方式"   >          <a href="#4-实现方式" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-实现方式" class="headerlink" title="4. 实现方式"></a><strong>4. 实现方式</strong></h3>              <h4 id="1-JVM-内存模型-3"   >          <a href="#1-JVM-内存模型-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JVM-内存模型-3" class="headerlink" title="(1) JVM 内存模型"></a><strong>(1) JVM 内存模型</strong></h4>      <ul><li><strong>具体实现</strong>：<ul><li>JVM 内存模型是 JVM 的具体实现，不同的 JVM 实现（如 HotSpot、OpenJ9）可能有不同的内存管理策略。</li></ul></li><li><strong>调优参数</strong>：<ul><li>通过 JVM 参数（如 <code>-Xms</code>、<code>-Xmx</code>、<code>-XX:MaxMetaspaceSize</code> 等）调整内存分配。</li></ul></li></ul>        <h4 id="2-JMM-内存模型-3"   >          <a href="#2-JMM-内存模型-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-JMM-内存模型-3" class="headerlink" title="(2) JMM 内存模型"></a><strong>(2) JMM 内存模型</strong></h4>      <ul><li><strong>抽象规范</strong>：<ul><li>JMM 是 Java 语言规范的一部分，定义了多线程环境下的内存交互规则。</li></ul></li><li><strong>实现机制</strong>：<ul><li>通过 <code>volatile</code>、<code>synchronized</code>、<code>final</code> 等关键字和 Happens-Before 规则实现内存一致性。</li></ul></li></ul><hr>        <h3 id="5-应用场景"   >          <a href="#5-应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a><strong>5. 应用场景</strong></h3>              <h4 id="1-JVM-内存模型-4"   >          <a href="#1-JVM-内存模型-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JVM-内存模型-4" class="headerlink" title="(1) JVM 内存模型"></a><strong>(1) JVM 内存模型</strong></h4>      <ul><li><strong>单线程和多线程</strong>：<ul><li>适用于所有 Java 程序，无论是否涉及多线程。</li></ul></li><li><strong>性能调优</strong>：<ul><li>通过调整内存参数优化应用程序的性能。</li></ul></li></ul>        <h4 id="2-JMM-内存模型-4"   >          <a href="#2-JMM-内存模型-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-JMM-内存模型-4" class="headerlink" title="(2) JMM 内存模型"></a><strong>(2) JMM 内存模型</strong></h4>      <ul><li><strong>多线程编程</strong>：<ul><li>主要适用于多线程并发编程。</li></ul></li><li><strong>线程安全</strong>：<ul><li>用于确保多线程程序的正确性和一致性。</li></ul></li></ul><hr>        <h3 id="6-示例对比"   >          <a href="#6-示例对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-示例对比" class="headerlink" title="6. 示例对比"></a><strong>6. 示例对比</strong></h3>              <h4 id="1-JVM-内存模型示例"   >          <a href="#1-JVM-内存模型示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-JVM-内存模型示例" class="headerlink" title="(1) JVM 内存模型示例"></a><strong>(1) JVM 内存模型示例</strong></h4>      <ul><li>设置堆内存大小：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512m -Xmx2048m MyApp</span><br></pre></td></tr></table></div></figure></li><li>监控堆内存使用：<figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc &lt;pid&gt;</span><br></pre></td></tr></table></div></figure></li></ul>        <h4 id="2-JMM-内存模型示例"   >          <a href="#2-JMM-内存模型示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-JMM-内存模型示例" class="headerlink" title="(2) JMM 内存模型示例"></a><strong>(2) JMM 内存模型示例</strong></h4>      <ul><li>使用 <code>volatile</code> 保证可见性：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedData</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li>使用 <code>synchronized</code> 保证原子性：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <div class="table-container"><table><thead><tr><th>特性</th><th>JVM 内存模型</th><th>JMM 内存模型</th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>描述 Java 程序运行时的内存分配和管理。</td><td>描述多线程环境下的内存交互规则。</td></tr><tr><td><strong>目标</strong></td><td>管理内存资源，优化性能。</td><td>解决多线程内存一致性问题。</td></tr><tr><td><strong>组成部分</strong></td><td>堆、栈、方法区、直接内存等。</td><td>主内存、工作内存、Happens-Before 规则等。</td></tr><tr><td><strong>关注点</strong></td><td>内存分配、垃圾回收、性能优化。</td><td>内存一致性、线程安全、并发编程。</td></tr><tr><td><strong>实现方式</strong></td><td>JVM 的具体实现，通过参数调优。</td><td>抽象规范，通过关键字和规则实现。</td></tr><tr><td><strong>应用场景</strong></td><td>所有 Java 程序。</td><td>多线程并发编程。</td></tr></tbody></table></div><p>理解 JVM 内存模型和 JMM 内存模型的区别，有助于更好地掌握 Java 程序的内存管理和多线程编程。</p>]]></content>
    
    
    <summary type="html">JVM和JMM的区别</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ljd0620.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://ljd0620.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型解析</title>
    <link href="https://ljd0620.github.io/2022/11/15/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://ljd0620.github.io/2022/11/15/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2022-11-15T04:11:44.000Z</published>
    <updated>2025-03-19T04:22:49.789Z</updated>
    
    <content type="html"><![CDATA[<p>JVM（Java Virtual Machine，Java 虚拟机）内存模型是 JVM 规范中定义的一种抽象模型，用于描述 Java 程序在运行时的内存分配和管理。JVM 内存模型将内存划分为多个区域，每个区域有不同的用途和生命周期。以下是 JVM 内存模型的主要组成部分及其详细解析：</p><hr>        <h3 id="1-程序计数器（Program-Counter-Register）"   >          <a href="#1-程序计数器（Program-Counter-Register）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-程序计数器（Program-Counter-Register）" class="headerlink" title="1. 程序计数器（Program Counter Register）"></a><strong>1. 程序计数器（Program Counter Register）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>程序计数器是一块较小的内存空间，用于记录当前线程执行的字节码指令地址。</li></ul></li><li><strong>特点</strong>：<ul><li>每个线程都有一个独立的程序计数器。</li><li>如果线程正在执行 Java 方法，程序计数器记录的是当前字节码指令的地址；如果执行的是 Native 方法，程序计数器的值为空（Undefined）。</li><li>程序计数器是唯一一个不会发生 <code>OutOfMemoryError</code> 的内存区域。</li></ul></li></ul><hr>        <h3 id="2-Java-虚拟机栈（Java-Virtual-Machine-Stacks）"   >          <a href="#2-Java-虚拟机栈（Java-Virtual-Machine-Stacks）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Java-虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="2. Java 虚拟机栈（Java Virtual Machine Stacks）"></a><strong>2. Java 虚拟机栈（Java Virtual Machine Stacks）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>Java 虚拟机栈是线程私有的内存区域，用于存储方法的局部变量、操作数栈、动态链接和方法返回地址等信息。</li></ul></li><li><strong>特点</strong>：<ul><li>每个方法在执行时都会创建一个栈帧（Stack Frame），栈帧用于存储方法的局部变量表、操作数栈、动态链接和方法返回地址。</li><li>栈帧随着方法的调用而创建，随着方法的结束而销毁。</li><li>如果线程请求的栈深度超过虚拟机允许的最大深度，会抛出 <code>StackOverflowError</code>。</li><li>如果虚拟机栈可以动态扩展，但无法申请到足够的内存时，会抛出 <code>OutOfMemoryError</code>。</li></ul></li></ul><hr>        <h3 id="3-本地方法栈（Native-Method-Stack）"   >          <a href="#3-本地方法栈（Native-Method-Stack）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3. 本地方法栈（Native Method Stack）"></a><strong>3. 本地方法栈（Native Method Stack）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>本地方法栈是线程私有的内存区域，用于支持 Native 方法的执行。</li></ul></li><li><strong>特点</strong>：<ul><li>与 Java 虚拟机栈类似，本地方法栈也会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code>。</li><li>本地方法栈的具体实现由虚拟机自行决定。</li></ul></li></ul><hr>        <h3 id="4-Java-堆（Java-Heap）"   >          <a href="#4-Java-堆（Java-Heap）" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-Java-堆（Java-Heap）" class="headerlink" title="4. Java 堆（Java Heap）"></a><strong>4. Java 堆（Java Heap）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>Java 堆是 JVM 中最大的一块内存区域，用于存储对象实例和数组。</li></ul></li><li><strong>特点</strong>：<ul><li>Java 堆是所有线程共享的内存区域。</li><li>Java 堆是垃圾收集器管理的主要区域，因此也被称为“GC 堆”。</li><li>Java 堆可以细分为新生代（Young Generation）和老年代（Old Generation），新生代又可以细分为 Eden 区、From Survivor 区和 To Survivor 区。</li><li>如果堆中没有足够的内存分配对象实例，并且堆无法扩展时，会抛出 <code>OutOfMemoryError</code>。</li></ul></li></ul><hr>        <h3 id="5-方法区（Method-Area）"   >          <a href="#5-方法区（Method-Area）" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-方法区（Method-Area）" class="headerlink" title="5. 方法区（Method Area）"></a><strong>5. 方法区（Method Area）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>方法区是 JVM 中用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域。</li></ul></li><li><strong>特点</strong>：<ul><li>方法区是所有线程共享的内存区域。</li><li>方法区是堆的一个逻辑部分，但在某些实现中（如 HotSpot 虚拟机），方法区被称为“永久代”（Permanent Generation）或“元空间”（Metaspace）。</li><li>如果方法区无法满足内存分配需求时，会抛出 <code>OutOfMemoryError</code>。</li></ul></li></ul><hr>        <h3 id="6-运行时常量池（Runtime-Constant-Pool）"   >          <a href="#6-运行时常量池（Runtime-Constant-Pool）" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="6. 运行时常量池（Runtime Constant Pool）"></a><strong>6. 运行时常量池（Runtime Constant Pool）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>运行时常量池是方法区的一部分，用于存储编译期生成的字面量和符号引用。</li></ul></li><li><strong>特点</strong>：<ul><li>运行时常量池是动态的，可以在运行时将新的常量放入池中。</li><li>如果运行时常量池无法满足内存分配需求时，会抛出 <code>OutOfMemoryError</code>。</li></ul></li></ul><hr>        <h3 id="7-直接内存（Direct-Memory）"   >          <a href="#7-直接内存（Direct-Memory）" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-直接内存（Direct-Memory）" class="headerlink" title="7. 直接内存（Direct Memory）"></a><strong>7. 直接内存（Direct Memory）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>直接内存是 JVM 外的内存区域，用于支持 NIO（New Input&#x2F;Output）操作。</li></ul></li><li><strong>特点</strong>：<ul><li>直接内存不是 JVM 运行时数据区的一部分，但可以通过 <code>ByteBuffer</code> 类直接分配和释放。</li><li>直接内存的分配不受 Java 堆大小的限制，但受操作系统内存的限制。</li><li>如果直接内存无法满足内存分配需求时，会抛出 <code>OutOfMemoryError</code>。</li></ul></li></ul><hr>        <h3 id="8-JVM-内存模型总结"   >          <a href="#8-JVM-内存模型总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-JVM-内存模型总结" class="headerlink" title="8. JVM 内存模型总结"></a><strong>8. JVM 内存模型总结</strong></h3>      <p>以下是 JVM 内存模型的主要组成部分及其特点：</p><div class="table-container"><table><thead><tr><th>内存区域</th><th>线程共享</th><th>作用</th><th>异常</th></tr></thead><tbody><tr><td>程序计数器</td><td>私有</td><td>记录当前线程执行的字节码指令地址。</td><td>无</td></tr><tr><td>Java 虚拟机栈</td><td>私有</td><td>存储方法的局部变量、操作数栈、动态链接和方法返回地址。</td><td><code>StackOverflowError</code>、<code>OutOfMemoryError</code></td></tr><tr><td>本地方法栈</td><td>私有</td><td>支持 Native 方法的执行。</td><td><code>StackOverflowError</code>、<code>OutOfMemoryError</code></td></tr><tr><td>Java 堆</td><td>共享</td><td>存储对象实例和数组。</td><td><code>OutOfMemoryError</code></td></tr><tr><td>方法区</td><td>共享</td><td>存储类信息、常量、静态变量、即时编译器编译后的代码等。</td><td><code>OutOfMemoryError</code></td></tr><tr><td>运行时常量池</td><td>共享</td><td>存储编译期生成的字面量和符号引用。</td><td><code>OutOfMemoryError</code></td></tr><tr><td>直接内存</td><td>共享</td><td>支持 NIO 操作。</td><td><code>OutOfMemoryError</code></td></tr></tbody></table></div><hr>        <h3 id="9-JVM-内存模型的优化"   >          <a href="#9-JVM-内存模型的优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-JVM-内存模型的优化" class="headerlink" title="9. JVM 内存模型的优化"></a><strong>9. JVM 内存模型的优化</strong></h3>      <ul><li><strong>垃圾收集（Garbage Collection）</strong>：<ul><li>JVM 通过垃圾收集器自动回收不再使用的对象，释放内存。</li></ul></li><li><strong>内存分配策略</strong>：<ul><li>JVM 根据对象的生命周期和大小，采用不同的内存分配策略（如新生代、老年代）。</li></ul></li><li><strong>内存调优</strong>：<ul><li>通过调整 JVM 参数（如 <code>-Xmx</code>、<code>-Xms</code>、<code>-XX:MaxMetaspaceSize</code> 等），优化内存使用。</li></ul></li></ul><hr>        <h3 id="总结"   >          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3>      <p>JVM 内存模型是 Java 程序运行时的内存管理基础，它将内存划分为多个区域，每个区域有不同的用途和生命周期。理解 JVM 内存模型的组成部分及其特点，有助于更好地掌握 Java 程序的运行机制和内存管理。</p>]]></content>
    
    
    <summary type="html">JVM内存模型解析</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://ljd0620.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JMM内存模型解析</title>
    <link href="https://ljd0620.github.io/2022/11/11/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/"/>
    <id>https://ljd0620.github.io/2022/11/11/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</id>
    <published>2022-11-11T04:11:07.000Z</published>
    <updated>2025-03-19T04:22:56.745Z</updated>
    
    <content type="html"><![CDATA[<p>JMM（Java Memory Model，Java 内存模型）是 Java 虚拟机（JVM）规范中定义的一种抽象模型，用于描述多线程环境下，线程如何与内存交互以及如何保证内存的可见性、有序性和原子性。JMM 的主要目标是解决多线程并发编程中的内存一致性问题。以下是 JMM 的主要组成部分及其详细解析：</p><hr>        <h3 id="1-主内存（Main-Memory）"   >          <a href="#1-主内存（Main-Memory）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-主内存（Main-Memory）" class="headerlink" title="1. 主内存（Main Memory）"></a><strong>1. 主内存（Main Memory）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>主内存是所有线程共享的内存区域，存储了所有的变量（包括实例字段、静态字段等）。</li></ul></li><li><strong>特点</strong>：<ul><li>主内存是线程之间通信的桥梁。</li><li>线程对变量的读写操作最终都会反映到主内存中。</li></ul></li></ul><hr>        <h3 id="2-工作内存（Working-Memory）"   >          <a href="#2-工作内存（Working-Memory）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-工作内存（Working-Memory）" class="headerlink" title="2. 工作内存（Working Memory）"></a><strong>2. 工作内存（Working Memory）</strong></h3>      <ul><li><strong>定义</strong>：<ul><li>每个线程都有自己的工作内存，工作内存是线程私有的内存区域。</li><li>工作内存存储了线程对主内存中变量的副本。</li></ul></li><li><strong>特点</strong>：<ul><li>线程对变量的所有操作（读取、赋值等）都在工作内存中进行。</li><li>线程不能直接操作主内存中的变量，而是通过工作内存间接操作。</li></ul></li></ul><hr>        <h3 id="3-内存间的交互操作"   >          <a href="#3-内存间的交互操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-内存间的交互操作" class="headerlink" title="3. 内存间的交互操作"></a><strong>3. 内存间的交互操作</strong></h3>      <p>JMM 定义了以下 8 种原子操作，用于描述主内存和工作内存之间的交互：</p><div class="table-container"><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td><code>lock</code>（锁定）</td><td>作用于主内存的变量，将其标识为线程独占状态。</td></tr><tr><td><code>unlock</code>（解锁）</td><td>作用于主内存的变量，释放锁定状态。</td></tr><tr><td><code>read</code>（读取）</td><td>作用于主内存的变量，将变量的值从主内存传输到工作内存。</td></tr><tr><td><code>load</code>（载入）</td><td>作用于工作内存的变量，将 <code>read</code> 操作得到的值放入工作内存的变量副本中。</td></tr><tr><td><code>use</code>（使用）</td><td>作用于工作内存的变量，将变量的值传递给执行引擎。</td></tr><tr><td><code>assign</code>（赋值）</td><td>作用于工作内存的变量，将执行引擎接收到的值赋给工作内存的变量。</td></tr><tr><td><code>store</code>（存储）</td><td>作用于工作内存的变量，将变量的值传输到主内存。</td></tr><tr><td><code>write</code>（写入）</td><td>作用于主内存的变量，将 <code>store</code> 操作得到的值放入主内存的变量中。</td></tr></tbody></table></div><hr>        <h3 id="4-内存模型的三大特性"   >          <a href="#4-内存模型的三大特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#4-内存模型的三大特性" class="headerlink" title="4. 内存模型的三大特性"></a><strong>4. 内存模型的三大特性</strong></h3>      <p>JMM 的核心目标是保证多线程环境下的内存可见性、有序性和原子性。</p>        <h4 id="1-可见性（Visibility）"   >          <a href="#1-可见性（Visibility）" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-可见性（Visibility）" class="headerlink" title="(1) 可见性（Visibility）"></a><strong>(1) 可见性（Visibility）</strong></h4>      <ul><li><strong>定义</strong>：<ul><li>当一个线程修改了共享变量的值，其他线程能够立即看到修改后的值。</li></ul></li><li><strong>实现机制</strong>：<ul><li>通过 <code>volatile</code> 关键字、<code>synchronized</code> 锁、<code>final</code> 关键字等保证可见性。</li></ul></li></ul>        <h4 id="2-有序性（Ordering）"   >          <a href="#2-有序性（Ordering）" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-有序性（Ordering）" class="headerlink" title="(2) 有序性（Ordering）"></a><strong>(2) 有序性（Ordering）</strong></h4>      <ul><li><strong>定义</strong>：<ul><li>程序执行的顺序按照代码的先后顺序执行。</li></ul></li><li><strong>实现机制</strong>：<ul><li>通过 <code>volatile</code> 关键字、<code>synchronized</code> 锁、<code>happens-before</code> 规则等保证有序性。</li></ul></li></ul>        <h4 id="3-原子性（Atomicity）"   >          <a href="#3-原子性（Atomicity）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-原子性（Atomicity）" class="headerlink" title="(3) 原子性（Atomicity）"></a><strong>(3) 原子性（Atomicity）</strong></h4>      <ul><li><strong>定义</strong>：<ul><li>一个操作是不可中断的，要么全部执行成功，要么全部不执行。</li></ul></li><li><strong>实现机制</strong>：<ul><li>通过 <code>synchronized</code> 锁、<code>java.util.concurrent.atomic</code> 包中的原子类等保证原子性。</li></ul></li></ul><hr>        <h3 id="5-Happens-Before-规则"   >          <a href="#5-Happens-Before-规则" class="heading-link"><i class="fas fa-link"></i></a><a href="#5-Happens-Before-规则" class="headerlink" title="5. Happens-Before 规则"></a><strong>5. Happens-Before 规则</strong></h3>      <p>Happens-Before 是 JMM 中定义的一组规则，用于描述操作之间的可见性和有序性。以下是 Happens-Before 的主要规则：</p><div class="table-container"><table><thead><tr><th>规则</th><th>描述</th></tr></thead><tbody><tr><td><strong>程序顺序规则</strong></td><td>在一个线程中，前面的操作 Happens-Before 后面的操作。</td></tr><tr><td><strong>锁规则</strong></td><td>解锁操作 Happens-Before 后续的加锁操作。</td></tr><tr><td><strong>volatile 变量规则</strong></td><td>对 <code>volatile</code> 变量的写操作 Happens-Before 后续的读操作。</td></tr><tr><td><strong>线程启动规则</strong></td><td>线程的 <code>start()</code> 方法 Happens-Before 该线程的任何操作。</td></tr><tr><td><strong>线程终止规则</strong></td><td>线程的所有操作 Happens-Before 其他线程检测到该线程已经终止。</td></tr><tr><td><strong>线程中断规则</strong></td><td>对线程的 <code>interrupt()</code> 方法 Happens-Before 被中断线程检测到中断事件。</td></tr><tr><td><strong>对象终结规则</strong></td><td>对象的构造函数 Happens-Before 该对象的 <code>finalize()</code> 方法。</td></tr><tr><td><strong>传递性规则</strong></td><td>如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。</td></tr></tbody></table></div><hr>        <h3 id="6-volatile-关键字"   >          <a href="#6-volatile-关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#6-volatile-关键字" class="headerlink" title="6. volatile 关键字"></a><strong>6. volatile 关键字</strong></h3>      <p><code>volatile</code> 是 JMM 中用于保证可见性和有序性的关键字。</p>        <h4 id="1-可见性"   >          <a href="#1-可见性" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-可见性" class="headerlink" title="(1) 可见性"></a><strong>(1) 可见性</strong></h4>      <ul><li>对 <code>volatile</code> 变量的写操作会立即刷新到主内存。</li><li>对 <code>volatile</code> 变量的读操作会从主内存中读取最新的值。</li></ul>        <h4 id="2-有序性"   >          <a href="#2-有序性" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-有序性" class="headerlink" title="(2) 有序性"></a><strong>(2) 有序性</strong></h4>      <ul><li>禁止指令重排序优化，确保 <code>volatile</code> 变量的读写操作按照代码顺序执行。</li></ul><hr>        <h3 id="7-synchronized-关键字"   >          <a href="#7-synchronized-关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#7-synchronized-关键字" class="headerlink" title="7. synchronized 关键字"></a><strong>7. synchronized 关键字</strong></h3>      <p><code>synchronized</code> 是 JMM 中用于保证可见性、有序性和原子性的关键字。</p>        <h4 id="1-可见性-1"   >          <a href="#1-可见性-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-可见性-1" class="headerlink" title="(1) 可见性"></a><strong>(1) 可见性</strong></h4>      <ul><li>线程在进入 <code>synchronized</code> 块时，会清空工作内存中的变量副本，从主内存中重新读取。</li><li>线程在退出 <code>synchronized</code> 块时，会将工作内存中的变量副本写回主内存。</li></ul>        <h4 id="2-有序性-1"   >          <a href="#2-有序性-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-有序性-1" class="headerlink" title="(2) 有序性"></a><strong>(2) 有序性</strong></h4>      <ul><li><code>synchronized</code> 块内的操作不会被重排序到块外。</li></ul>        <h4 id="3-原子性"   >          <a href="#3-原子性" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-原子性" class="headerlink" title="(3) 原子性"></a><strong>(3) 原子性</strong></h4>      <ul><li><code>synchronized</code> 块内的操作是不可分割的，确保线程安全。</li></ul><hr>        <h3 id="8-final-关键字"   >          <a href="#8-final-关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#8-final-关键字" class="headerlink" title="8. final 关键字"></a><strong>8. final 关键字</strong></h3>      <p><code>final</code> 是 JMM 中用于保证可见性的关键字。</p>        <h4 id="1-可见性-2"   >          <a href="#1-可见性-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-可见性-2" class="headerlink" title="(1) 可见性"></a><strong>(1) 可见性</strong></h4>      <ul><li>被 <code>final</code> 修饰的字段在构造函数中初始化后，对其他线程立即可见。</li></ul>        <h4 id="2-禁止重排序"   >          <a href="#2-禁止重排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-禁止重排序" class="headerlink" title="(2) 禁止重排序"></a><strong>(2) 禁止重排序</strong></h4>      <ul><li>禁止对 <code>final</code> 字段的写操作重排序到构造函数之外。</li></ul><hr>        <h3 id="9-总结"   >          <a href="#9-总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#9-总结" class="headerlink" title="9. 总结"></a><strong>9. 总结</strong></h3>      <p>JMM 是 Java 多线程编程的核心基础，它通过定义主内存、工作内存和内存间交互操作，解决了多线程环境下的内存一致性问题。JMM 的三大特性（可见性、有序性、原子性）以及 Happens-Before 规则，为开发者提供了编写线程安全程序的指导。理解 JMM 的组成部分及其工作原理，有助于更好地掌握 Java 并发编程。</p>]]></content>
    
    
    <summary type="html">JMM内存模型解析</summary>
    
    
    
    <category term="Java" scheme="https://ljd0620.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ljd0620.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
